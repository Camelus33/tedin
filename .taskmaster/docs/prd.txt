# Habitus33 사용량 기반 결제 시스템 PRD (Product Requirements Document)

## 1. 프로젝트 개요

### 목표
Habitus33의 기존 결제 인프라를 완성하여 사용자 친화적인 2-tier 사용량 기반 구독 시스템을 제공한다.

### 현재 상태 분석
- ✅ Stripe 기본 설정 완료
- ✅ 체크아웃/구독 취소/상태 조회 API 구현
- ✅ 웹훅 처리 구현  
- ✅ 3-tier 플랜 UI 완성 (Premium 제거 필요)
- ❌ 실제 결제 API 연동 (현재 테스트 상태)
- ❌ 사용량 추적 시스템 구축
- ❌ 책 등록 제한 (10권) 로직
- ❌ AI-Link 생성 제한 (월 15회) 로직
- ❌ 사용량 대시보드 UI

### 새로운 플랜 구조
**FREE 플랜 (₩0)**
- 모든 기능 무제한 사용 (TS 모드, ZenGo, 33일 루틴, 메모 등)
- 내 서재: 10권까지 등록 가능
- AI-Link 생성: 월 15회 제한

**PRO 플랜 (₩9,900/월)**
- 모든 기능 완전 무제한
- 내 서재: 무제한 책 등록
- AI-Link 생성: 무제한
- 고급 분석 리포트
- 우선 고객지원

## 2. 핵심 요구사항

### 2.1 필수 기능 (Must Have)
1. **사용량 추적 시스템**
   - 사용자별 책 등록 수 추적
   - 월별 AI-Link 생성 횟수 추적
   - 사용량 초기화 스케줄러 (매월 1일)

2. **사용량 제한 로직**
   - 책 등록 시 10권 제한 체크 (FREE 플랜)
   - AI-Link 생성 시 월 15회 제한 체크 (FREE 플랜)
   - 제한 도달 시 업그레이드 안내 UI

3. **실제 결제 플로우 완성**
   - 업그레이드 페이지 2-tier로 수정
   - 실제 Stripe 체크아웃 연동
   - 결제 성공/실패 후 적절한 리다이렉션

4. **사용량 대시보드**
   - 현재 사용량 시각적 표시
   - 남은 사용량 알림
   - 프로그레스 바 형태의 직관적 UI

### 2.2 중요 기능 (Should Have)
1. **스마트 알림 시스템**
   - 70% 도달 시 부드러운 알림
   - 90% 도달 시 업그레이드 제안
   - 100% 도달 시 제한 안내 + 업그레이드 CTA

2. **사용량 기반 UX 개선**
   - 제한 근접 시 점진적 안내
   - 사용량 히스토리 시각화
   - 월별 사용 패턴 분석

3. **결제 관리 기능**
   - 구독 상태 확인
   - 구독 취소/재개
   - 결제 내역 조회

### 2.3 추가 기능 (Nice to Have)
1. **프로모션 시스템**
   - 첫 달 무료 체험
   - 추천인 할인 코드
   - 연간 결제 할인

2. **사용량 분석**
   - 사용자별 사용 패턴 분석
   - 전환율 최적화 데이터
   - A/B 테스트 지원

## 3. 사용자 스토리

### 3.1 일반 사용자 (Free)
- 사용자로서, 모든 기능을 자유롭게 체험하고 싶다
- 사용자로서, 내 사용량을 쉽게 확인하고 싶다
- 사용자로서, 제한에 도달하기 전에 미리 알림을 받고 싶다
- 사용자로서, 필요할 때 간편하게 업그레이드하고 싶다

### 3.2 Pro 사용자
- 사용자로서, 모든 제한 없이 자유롭게 서비스를 이용하고 싶다
- 사용자로서, 투자한 만큼의 가치를 느끼고 싶다
- 사용자로서, 언제든 구독을 관리할 수 있기를 원한다

### 3.3 운영진
- 운영진으로서, 사용량 데이터를 통해 비즈니스 인사이트를 얻고 싶다
- 운영진으로서, 전환율을 최적화하고 싶다

## 4. 기술적 요구사항

### 4.1 데이터 모델
```typescript
interface UserQuota {
  userId: string;
  month: string; // "2024-01"
  booksRegistered: number; // 총 등록 책 수
  aiLinksUsed: number; // 월 AI-Link 사용량
  resetDate: Date;
}

interface PlanLimits {
  free: { maxBooks: 10; monthlyAiLinks: 15; };
  pro: { maxBooks: -1; monthlyAiLinks: -1; };
}
```

### 4.2 성능
- 사용량 체크 응답 시간 < 100ms
- 사용량 업데이트 실시간 반영
- 월 사용량 리셋 정확도 99.9%

### 4.3 확장성
- 사용자 10만명 동시 사용량 추적 가능
- 새로운 사용량 제한 추가 용이성

## 5. 성공 지표

### 5.1 비즈니스 지표
- Free → Pro 전환율 > 8%
- 사용량 제한 도달 후 24시간 내 전환율 > 15%
- 월 이탈률 < 10%

### 5.2 기술 지표
- 사용량 추적 정확도 > 99.9%
- 시스템 가동률 > 99.9%
- 사용량 체크 지연 시간 < 50ms

## 6. 구현 우선순위

### Phase 1: 사용량 추적 인프라 (1주)
- 사용량 추적 데이터베이스 모델
- 사용량 체크 미들웨어
- 월별 리셋 스케줄러

### Phase 2: 제한 로직 및 UI (1주)
- 책 등록 제한 구현
- AI-Link 생성 제한 구현
- 사용량 대시보드 UI

### Phase 3: 결제 시스템 연동 (1주)
- 2-tier 업그레이드 페이지 수정
- 실제 Stripe 결제 연동
- 결제 후 플랜 업데이트

### Phase 4: UX 최적화 (1주)
- 스마트 알림 시스템
- 사용량 기반 개인화
- A/B 테스트 구현

## 7. 리스크 관리

### 7.1 기술적 리스크
- **리스크**: 사용량 추적 데이터 불일치
- **대응**: 정기적 데이터 검증 + 수동 조정 도구

### 7.2 비즈니스 리스크  
- **리스크**: 너무 관대한 Free 플랜으로 전환율 저조
- **대응**: 사용량 데이터 기반 제한 조정

### 7.3 사용자 경험 리스크
- **리스크**: 제한으로 인한 사용자 이탈
- **대응**: 부드러운 알림 + 체험 기회 제공 

# 인터랙티브 온보딩 가이드 구현 PRD
## 한 방울의 여정: 첫 사용자를 위한 직관적 AMFA 경험

### 프로젝트 개요
첫 가입 사용자가 AMFA의 복잡한 개념들(아토믹 메모, 메모 진화, 단권화 노트, AI-Link)을 텍스트 설명 없이도 직관적으로 이해할 수 있는 인터랙티브 스토리텔링 경험을 구현합니다.

### 핵심 목표
1. 가파른 학습곡선을 완만하게 만들어 첫 사용자의 이탈률 감소
2. 텍스트 설명을 최소화하고 시각적/인터랙티브 요소로 개념 전달
3. 사용자의 작은 행동이 다음 단계로 자연스럽게 이어지는 연속적 경험 제공
4. AMFA 4단계의 가치와 순서를 체험을 통해 이해시키기

### 기술 스택
- Frontend: Next.js 14, TypeScript, Tailwind CSS
- 애니메이션: Framer Motion, Lottie (기존 habitus-mascot.json 활용)
- 상태관리: React useState/useRef (복잡도가 낮아 Zustand 불필요)
- 아이콘: Heroicons (기존 사용 중)

### 주요 기능 요구사항

#### 1. 기존 파도 인트로 활용
- 기존 WaveAnimation 컴포넌트와 [DIVE] 버튼 완전 유지
- [DIVE] 버튼 클릭 시 4단계 인터랙티브 여정 시작
- 파도 메타포를 AMFA 4단계와 자연스럽게 연결

#### 2. 파도 메타포 기반 4단계 순차적 경험
물의 여정과 지식의 여정을 완벽하게 대응:

**Step 1: 물방울 → Atomic Memo (아토믹 메모)**
- [DIVE] 버튼 클릭 후 첫 번째 물방울이 수면에 떨어지는 애니메이션
- 카드 등장: 💧 아이콘, "생각의 첫 방울" 개념
- 최소 텍스트: "책 한 줄, 스치는 생각... 작은 물방울처럼 시작하세요"

**Step 2: 파도 → Memo Evolve (메모 진화)**
- 물방울에서 시작된 파도가 점점 커지며 확산되는 애니메이션
- 카드 등장: 🌊 아이콘, "생각의 파도" 개념
- 최소 텍스트: "5가지 질문으로 생각이 파도처럼 넓어집니다"

**Step 3: 소용돌이 → Furnace Knowledge (단권화 노트)**
- 여러 파도들이 한 곳으로 모여 소용돌이를 만드는 애니메이션
- 카드 등장: 🌀 아이콘, "지식의 소용돌이" 개념
- 최소 텍스트: "흩어진 생각들이 하나로 모여 단단해집니다"

**Step 4: 결정체 → AI-Link (AI 링크)**
- 소용돌이 중심에서 빛나는 결정체(크리스탈)가 형성되는 애니메이션
- 카드 등장: 💎🧠 아이콘, "지식의 결정체" 개념
- 최소 텍스트: "당신만의 지식 결정체, AI-Link가 탄생합니다"

#### 3. Before/After 비교 슬라이더
- 일반 AI vs AI-Link 답변 차이를 시각적으로 비교
- 인터랙티브 슬라이더로 사용자가 직접 조작 가능
- 구체적인 비즈니스 시나리오 예시 포함

#### 4. 최종 CTA
- "첫 아토믹 메모 기록하고, 나만의 AI 만들기 시작하기" 버튼
- /books 페이지로 자연스러운 이동

### 성능 요구사항
- 애니메이션 60fps 유지
- 모바일 반응형 완벽 지원 (320px-375px)
- 초기 로딩 시간 3초 이내
- 접근성 AA 수준 준수

### 디자인 요구사항
- Habitus33 브랜드 컬러 (보라/인디고) 활용
- 물개 마스코트 자연스러운 통합
- 기존 디자인 시스템과 일관성 유지
- 다크 테마 기본 적용

### 제약사항
- 기존 PC 레이아웃 절대 변경 금지
- 모바일에서만 텍스트 overflow 해결
- 기존 WaveAnimation 컴포넌트 구조 유지
- 기존 AMFACards 컴포넌트 재활용 필수

### 성공 지표
- 첫 사용자 온보딩 완료율 80% 이상
- 첫 메모 작성률 60% 이상
- 페이지 이탈률 30% 이하
- 모바일 사용성 점수 4.5/5.0 이상

### 우선순위
1. 핵심 인터랙티브 플로우 구현 (High)
2. 애니메이션 품질 및 성능 최적화 (High)
3. Before/After 슬라이더 구현 (Medium)
4. 접근성 및 반응형 최적화 (Medium)
5. A/B 테스트를 위한 분석 코드 (Low)

# Habitus33 온보딩 페이지 개선 PRD

## 프로젝트 개요
Habitus33의 온보딩 페이지를 "프롬프트 프리" 철학과 AMFA 엔진을 중심으로 한 핵심 가치에 맞게 개선하여, 사용자가 즉시 개인화된 AI 조력자(튜터/연구조교/업무보조)의 가치를 인지하고 활성화될 수 있도록 한다.

## 문제 정의
현재 온보딩 페이지는 서비스의 핵심 가치인 "프롬프트 프리"와 "AI-Link를 통한 개인화된 AI 조력자" 제공을 명확히 전달하지 못하고 있으며, 핵심 고객층(AI 활용에 능숙한 학습자/연구자/직장인)에게 맞춤화된 경험을 제공하지 못하고 있다.

## 목표
### 주요 목표
1. **핵심 가치 전달**: "프롬프트 프리" 철학과 AMFA(Atomic Reading + Atomic Memo → Memo Evolution → Focused Note → AI-Link) 프로세스 명확히 전달
2. **개인화된 경험**: 사용자 유형(학습자/연구자/직장인)에 따른 맞춤형 온보딩 경로 제공
3. **빠른 가치 인식**: 사용자가 10분 내에 개인화된 AI 조력자의 가치를 체험할 수 있도록 함
4. **활성화율 향상**: 온보딩 완료율을 현재 대비 40% 이상 향상

### 성공 지표
- 온보딩 완료율: 현재 대비 40% 향상
- 첫 AI-Link 생성까지의 시간: 평균 10분 이내
- 사용자 세그먼트별 맞춤 경험 제공률: 90% 이상
- 온보딩 후 7일 리텐션: 70% 이상

## 핵심 기능

### 1. 개인화된 웰컴 경험
- **사용자 세그먼트 식별**: 학습자/수험생, 연구자, 직장인 구분
- **맞춤형 가치 제안**: 각 세그먼트별 AI 조력자 가치 설명
  - 학습자: "완전히 나에게 맞는 AI 튜터"
  - 연구자: "완전히 나에게 맞는 AI 연구조교"
  - 직장인: "완전히 나에게 맞는 AI 업무보조"

### 2. AMFA 프로세스 체험
- **인터랙티브 데모**: 실제 콘텐츠로 AMFA 프로세스 체험
- **단계별 가이드**: A→M→F→A 각 단계의 가치와 방법 설명
- **즉시 실습**: 간단한 예제로 AI-Link 생성 체험

### 3. 개인화 설정
- **학습 목표 설정**: 사용자의 구체적 목표와 관심사 파악
- **선호도 설정**: 학습 스타일, 콘텐츠 유형, 알림 빈도 등
- **초기 데이터 입력**: 기존 메모나 관심 주제 간단 입력

### 4. 첫 AI-Link 생성 가이드
- **템플릿 제공**: 사용자 유형별 AI-Link 템플릿
- **실시간 피드백**: 입력 내용에 따른 AI-Link 품질 실시간 표시
- **성공 축하**: 첫 AI-Link 생성 완료 시 성취감 제공

### 5. 다음 단계 안내
- **추천 액션**: 사용자 프로필에 따른 다음 추천 행동
- **리소스 제공**: 도움말, 튜토리얼, 커뮤니티 링크
- **진행 상황 추적**: 온보딩 진행도와 달성 마일스톤

## 사용자 여정

### Phase 1: 웰컴 & 세그멘테이션 (2-3분)
1. 개인화된 환영 메시지
2. 사용자 유형 선택 (학습자/연구자/직장인)
3. 해당 세그먼트 맞춤 가치 제안 제시

### Phase 2: AMFA 프로세스 이해 (3-4분)
1. "프롬프트 프리" 철학 소개
2. AMFA 프로세스 인터랙티브 데모
3. AI-Link 개념과 가치 설명

### Phase 3: 개인화 설정 (2-3분)
1. 학습 목표 및 관심사 설정
2. 선호도 및 스타일 설정
3. 초기 콘텐츠 또는 메모 입력

### Phase 4: 첫 AI-Link 생성 (3-4분)
1. 템플릿 선택 또는 자유 입력
2. AMFA 프로세스 실제 체험
3. AI-Link 생성 완료 및 축하

### Phase 5: 다음 단계 안내 (1-2분)
1. 생성된 AI-Link 활용 방법 안내
2. 추천 다음 액션 제시
3. 리소스 및 지원 정보 제공

## 기술적 요구사항

### 프론트엔드
- React/Next.js 기반 인터랙티브 컴포넌트
- 반응형 디자인 (모바일/태블릿/데스크탑)
- 진행 상황 표시 및 애니메이션
- 실시간 피드백 UI

### 백엔드
- 사용자 세그먼트 분류 로직
- 개인화 설정 저장 시스템
- AI-Link 생성 API 연동
- 온보딩 진행 상황 추적

### 데이터 & 분석
- 온보딩 단계별 이탈률 추적
- 사용자 행동 분석
- A/B 테스트 기능
- 성과 지표 대시보드

## 우선순위

### P0 (필수)
- 사용자 세그먼트 식별 및 맞춤 가치 제안
- AMFA 프로세스 기본 설명 및 체험
- 첫 AI-Link 생성 가이드

### P1 (중요)
- 인터랙티브 데모 및 애니메이션
- 개인화 설정 기능
- 진행 상황 추적 및 피드백

### P2 (개선)
- 고급 개인화 옵션
- 소셜 공유 기능
- 온보딩 후 팔로우업 시퀀스

## 제약사항
- 기존 사용자 데이터 및 시스템과의 호환성 유지
- 모바일 환경에서의 원활한 동작
- 로딩 시간 최적화 (각 단계 3초 이내)
- 다국어 지원 고려

## 성공 기준
1. 온보딩 완료율 40% 이상 향상
2. 첫 AI-Link 생성률 80% 이상
3. 온보딩 후 7일 리텐션 70% 이상
4. 사용자 만족도 4.5/5.0 이상
5. 세그먼트별 맞춤 경험 제공률 90% 이상

## 타임라인
- **Week 1-2**: 사용자 리서치 및 세부 기획
- **Week 3-4**: UI/UX 디자인 및 프로토타입
- **Week 5-8**: 개발 및 구현
- **Week 9-10**: 테스트 및 QA
- **Week 11-12**: 런칭 및 성과 측정

## 리스크 및 대응방안
1. **기술적 복잡성**: 단계별 구현으로 리스크 분산
2. **사용자 이탈**: A/B 테스트를 통한 지속적 최적화
3. **성능 이슈**: 로딩 최적화 및 프로그레시브 로딩 적용
4. **사용자 피드백**: 베타 테스트 그룹 운영으로 사전 검증 

# TSNoteCard 인라인 스레드 백엔드 문제 해결 PRD

## 문제 정의
TSNoteCard 페이지의 인라인 메모 쓰레드 기능에서 새로고침 시 작성자 정보가 '익명', '정보없음'으로 표시되는 문제가 발생하고 있습니다.

## 근본 원인 분석
1. **백엔드 데이터 불일치**: User 모델에는 nickname 필드만 존재하지만, noteController.ts에서는 name/username 필드를 참조하고 있음
2. **authorName 설정 로직 오류**: `const authorName = user?.name || user?.username || '사용자'`에서 실제로는 nickname을 사용해야 함
3. **데이터 동기화 문제**: 프론트엔드 낙관적 업데이트와 서버 응답 간 불일치

## 해결 목표
- 새로고침 후에도 인라인 스레드 작성자 이름이 정확히 표시되도록 수정
- 백엔드 데이터 처리 로직 정상화
- 프론트엔드-백엔드 데이터 동기화 보장

## 기술적 요구사항
- User 모델의 nickname 필드 활용
- noteController.ts의 authorName 설정 로직 수정
- 기존 데이터 마이그레이션 (필요시)
- 프론트엔드 데이터 핸들링 검증

## 구현 범위
### 백엔드 수정
- noteController.ts의 addInlineThread 메서드 수정
- User 모델 스키마 검증 및 필드 확인
- 기존 InlineThread 데이터의 authorName 필드 업데이트

### 프론트엔드 검증
- TSNoteCard.tsx의 데이터 핸들링 로직 검증
- 새로고침 시 데이터 로딩 프로세스 확인
- 낙관적 업데이트 로직 개선

### 테스트 및 검증
- 수정 후 새로고침 테스트
- 다양한 사용자 시나리오 테스트
- 데이터 무결성 검증

## 성공 지표
- 새로고침 후 작성자 이름이 정확히 표시됨
- '익명', '정보없음' 표시 문제 해결
- 기존 데이터 손실 없음
- 새로운 스레드 생성 시 정상 작동

## 위험 요소
- 기존 데이터 마이그레이션 시 데이터 손실 가능성
- 프로덕션 환경에서의 예상치 못한 부작용
- 사용자 경험 중단 최소화 필요

## 배포 전략
1. 개발 환경에서 수정 및 테스트
2. 스테이징 환경 검증
3. 프로덕션 배포 및 모니터링 