{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Dependency Installation",
        "description": "Set up the React/Next.js project environment with Tailwind CSS, ensuring compatibility with existing TSNoteCard component and react-pdf library.",
        "details": "1.  Verify Node.js and npm are installed (>=18.x and >=8.x respectively).\n2.  Initialize a new Next.js project or navigate to the existing project directory.\n3.  Install Tailwind CSS and its dependencies: `npm install -D tailwindcss postcss autoprefixer`\n4.  Configure Tailwind CSS by running `npx tailwindcss init -p` and updating `tailwind.config.js` with necessary configurations.\n5.  Install `react-pdf` library: `npm install react-pdf`\n6.  Verify that the TSNoteCard component is correctly set up and styled.\n7.  Address any compatibility issues between Tailwind CSS and existing styles.\n8.  Create necessary folders and files for components and utilities.",
        "testStrategy": "1.  Run the development server (`npm run dev`) and ensure the application compiles without errors.\n2.  Verify that Tailwind CSS styles are applied correctly.\n3.  Check that the TSNoteCard component renders as expected.\n4.  Ensure `react-pdf` is installed correctly and can be imported.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement View Mode State Management",
        "description": "Implement the view mode state management using React's useState hook, including the 'grid' and 'more' modes.",
        "details": "1.  In the main dashboard component, declare a state variable `viewMode` using `useState('grid')`.\n2.  Create a function `setViewMode` to update the `viewMode` state.\n3.  Pass the `viewMode` state and `setViewMode` function to the relevant components.\n4.  Implement logic to switch between 'grid' and 'more' modes based on user interaction (e.g., button click).\n5.  Ensure the initial state is set to 'grid'.",
        "testStrategy": "1.  Verify that the `viewMode` state is initialized correctly.\n2.  Test the functionality to switch between 'grid' and 'more' modes.\n3.  Ensure that the UI updates correctly when the `viewMode` changes.\n4.  Check for any unexpected side effects when updating the state.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Memo Card Loading and '더보기' Functionality",
        "description": "Modify the dashboard to initially load only the recent 3 memo cards in 'grid' mode and implement the '더보기' (more) button functionality to load all memo cards.",
        "details": "1.  Fetch the initial 3 memo cards and store them in a state variable `recentMemos`.\n2.  Display `recentMemos` in a 3-column grid layout when `viewMode` is 'grid'.\n3.  Implement an API call to fetch all memo cards when the '더보기' button is clicked.\n4.  Store all memo cards in a state variable `allMemos`.\n5.  Update the UI to display `allMemos` in a 6-column grid layout when `viewMode` is 'more'.\n6.  Implement error handling for the API call.",
        "testStrategy": "1.  Verify that only 3 memo cards are loaded initially in 'grid' mode.\n2.  Test the '더보기' button to ensure all memo cards are loaded and displayed in 'more' mode.\n3.  Check for correct grid layout in both 'grid' and 'more' modes.\n4.  Test error handling for API call failures.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement UI Components for Grid and More Views",
        "description": "Implement the UI components for both Grid and More views, ensuring the correct layout and styling.",
        "details": "1.  Create a `GridView` component to display memo cards in a 3-column grid layout.\n2.  Create a `MoreView` component to display memo cards in a 6-column grid layout.\n3.  Use Tailwind CSS to style the components, ensuring responsiveness.\n4.  Implement smaller card sizes in `MoreView`.\n5.  Ensure the `TSNoteCard` component is reused in both views.",
        "testStrategy": "1.  Verify that the `GridView` component displays memo cards in a 3-column grid.\n2.  Verify that the `MoreView` component displays memo cards in a 6-column grid.\n3.  Check for correct styling and responsiveness in both views.\n4.  Ensure that the `TSNoteCard` component is rendered correctly in both views.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Hover Animation",
        "description": "Add hover animation to the memo cards in the 'more' view using Tailwind CSS.",
        "details": "1.  Add the `hover:scale-110` class to the `TSNoteCard` component in the `MoreView`.\n2.  Add the `transition-all duration-300 ease-out` class to the `TSNoteCard` component to ensure a smooth animation.\n3.  Test the hover animation to ensure it scales the card up smoothly.",
        "testStrategy": "1.  Verify that the memo cards scale up on hover in the `MoreView`.\n2.  Check that the animation is smooth and lasts for 300ms.\n3.  Ensure that the animation does not cause any layout shifts.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Continuous Vertical Scrolling in PDF Viewer",
        "description": "Modify PdfViewer.tsx to enable continuous vertical scrolling, stacking all pages vertically.",
        "details": "1.  Modify the `PdfViewer.tsx` component to render all pages of the PDF in a vertical stack.\n2.  Remove the existing page navigation buttons.\n3.  Adjust the container height and styles to accommodate the continuous scroll.\n4.  Ensure the existing props interface is maintained.",
        "testStrategy": "1.  Verify that all pages are rendered in a vertical stack.\n2.  Check that the page navigation buttons are removed.\n3.  Ensure the container height and styles are adjusted correctly.\n4.  Test that the existing props interface is maintained.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Lazy Loading with IntersectionObserver",
        "description": "Implement lazy loading using IntersectionObserver to optimize performance for large PDFs.",
        "details": "1.  Use `IntersectionObserver` to detect when a page enters the viewport.\n2.  Only render pages that are currently in or near the viewport.\n3.  Implement a placeholder for pages that are not yet rendered.\n4.  Optimize memory usage by unloading pages that are far from the viewport.",
        "testStrategy": "1.  Verify that only pages in or near the viewport are rendered.\n2.  Check that placeholders are displayed for pages that are not yet rendered.\n3.  Monitor memory usage to ensure it is optimized.\n4.  Test scrolling performance with large PDFs (100+ pages).",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Scroll-Based Page Tracking and Control Bar Synchronization",
        "description": "Implement scroll-based page tracking and synchronize it with the control bar, ensuring compatibility with existing highlight and text selection features.",
        "details": "1.  Use the `IntersectionObserver` to track the currently visible page based on scroll position.\n2.  Update the control bar to reflect the current page number.\n3.  Ensure that the highlight overlay and text selection features continue to function correctly.\n4.  Maintain compatibility with existing zoom and rotation features.",
        "testStrategy": "1.  Verify that the control bar updates correctly as the user scrolls.\n2.  Check that the highlight overlay and text selection features continue to function correctly.\n3.  Ensure compatibility with existing zoom and rotation features.\n4.  Test with various PDF documents to ensure consistent behavior.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement IntersectionObserver-based Page Tracking",
            "description": "Set up IntersectionObserver to track which page is currently in view based on scroll position. Determine the logic for identifying the 'current' page when multiple pages are partially visible.",
            "dependencies": [],
            "details": "Use IntersectionObserver API to monitor the visibility of each page element. Define a threshold for determining when a page is considered 'in view'. Handle edge cases where multiple pages are partially visible.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Control Bar Update Logic",
            "description": "Develop the logic to update the control bar with the current page information based on the output from the IntersectionObserver. Ensure the control bar accurately reflects the currently viewed page.",
            "dependencies": [
              1
            ],
            "details": "Create a function that receives the current page information from the IntersectionObserver and updates the control bar's page number display. Handle cases where no page is in view (e.g., at the very beginning or end of the document).",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Ensure Compatibility with Highlight and Text Selection",
            "description": "Test and ensure that the scroll-based page tracking and control bar synchronization do not interfere with existing highlight and text selection functionalities. Address any conflicts that arise.",
            "dependencies": [
              1,
              2
            ],
            "details": "Test highlighting and text selection on different pages after implementing the scroll-based tracking. Identify and resolve any issues where the tracking logic prevents or disrupts highlighting or text selection.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Ensure Compatibility with Zoom and Rotation",
            "description": "Test and ensure that the scroll-based page tracking and control bar synchronization remain accurate and functional when the document is zoomed in/out or rotated. Adjust the IntersectionObserver thresholds or logic as needed.",
            "dependencies": [
              1,
              2
            ],
            "details": "Test the page tracking and control bar updates at different zoom levels and rotations. Adjust the IntersectionObserver's thresholds or the page detection logic to maintain accuracy under these conditions.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-07T08:48:57.524Z",
      "updated": "2025-07-07T08:49:24.607Z",
      "description": "Tasks for pdf-scroll-feature context"
    }
  },
  "pdf-knowledge-capture": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement PDF Upload API and Update Book Model",
        "description": "Extend the Book model with pdfUrl and pdfFileSize fields and implement an API endpoint for uploading PDF files to cloud storage, including server-side validation.",
        "details": "1.  Modify the Book model in the database schema to include the `pdfUrl` (string) and `pdfFileSize` (integer) fields.\n2.  Implement a new API endpoint `/books/{bookId}/upload-pdf` that accepts a PDF file as input.\n3.  Implement server-side validation to check the file format (must be PDF) and file size (must be less than 20MB).\n4.  Upon successful validation, upload the PDF file to cloud storage (e.g., AWS S3, Google Cloud Storage, or Azure Blob Storage).\n5.  Store the URL of the uploaded PDF file in the `pdfUrl` field of the Book model.\n6.  Store the size of the uploaded PDF file in the `pdfFileSize` field of the Book model.\n7.  Return a success response with the updated Book model.\n8.  Handle potential errors such as invalid file format, file size exceeding the limit, and cloud storage upload failures, returning appropriate error responses.",
        "testStrategy": "1.  Create a test PDF file.\n2.  Send a POST request to the `/books/{bookId}/upload-pdf` endpoint with the test PDF file.\n3.  Verify that the API returns a success response with the updated Book model, including the `pdfUrl` and `pdfFileSize` fields.\n4.  Verify that the PDF file is successfully uploaded to cloud storage.\n5.  Verify that the `pdfUrl` field in the Book model contains the correct URL of the uploaded PDF file.\n6.  Verify that the `pdfFileSize` field in the Book model contains the correct size of the uploaded PDF file.\n7.  Test with a file larger than 20MB and verify that the API returns an error response.\n8.  Test with a non-PDF file and verify that the API returns an error response.\n9.  Test error handling for cloud storage upload failures.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "현재 백엔드 구조 분석",
            "description": "backend/ 폴더의 기존 코드를 분석하여 Prisma 스키마와 Book 모델 구조를 파악한다",
            "details": "- backend/prisma/schema.prisma 파일 확인\n- Book 모델의 현재 필드 구조 파악\n- 기존 Book 관련 API 엔드포인트 확인\n- 파일 업로드 관련 기존 구현 확인\n<info added on 2025-07-07T03:14:11.703Z>\n**현재 상황:**\n- 프로젝트는 MongoDB + Mongoose 사용\n- Book 모델은 `backend/src/models/Book.ts`에 정의\n- Book API는 `backend/src/routes/books.ts`에 구현\n- 이미 multer를 사용한 이미지 업로드 기능 존재 (5MB 제한)\n- 업로드 디렉토리: `uploads/` (프로젝트 루트)\n\n**Book 모델 현재 필드:**\n- userId, title, author, bookType, totalPages, currentPage\n- isbn, coverImage, category, status, completionPercentage\n- estimatedRemainingMinutes, avgPpm, readingPurpose, purchaseLink\n- createdAt, updatedAt (timestamps)\n\n**다음 단계:**\n1. Book 모델에 pdfUrl, pdfFileSize 필드 추가\n2. PDF 파일 업로드를 위한 multer 설정 추가\n3. PDF 업로드 API 엔드포인트 구현\n4. PDF 파일 검증 로직 구현\n</info added on 2025-07-07T03:14:11.703Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 1
          },
          {
            "id": 2,
            "title": "Book 모델에 PDF 필드 추가",
            "description": "Book 모델의 인터페이스와 스키마에 pdfUrl과 pdfFileSize 필드를 추가한다",
            "details": "- IBook 인터페이스에 pdfUrl?: string, pdfFileSize?: number 필드 추가\n- BookSchema에 해당 필드들의 Mongoose 스키마 정의 추가\n- 기존 Book 타입과의 호환성 유지\n<info added on 2025-07-07T03:15:28.807Z>\n- pdfUrl은 String 타입, trim 적용, 기본값 null\n- pdfFileSize는 Number 타입, 최소값 0, 기본값 null\n- backend/src/models/Book.ts 파일 수정\n- 기존 필드들에는 영향 없음\n- 새로운 필드들은 옵셔널이므로 기존 데이터와 호환\n</info added on 2025-07-07T03:15:28.807Z>",
            "status": "done",
            "dependencies": [
              1
            ],
            "parentTaskId": 1
          },
          {
            "id": 3,
            "title": "PDF 업로드를 위한 multer 설정 구성",
            "description": "PDF 파일 업로드를 위한 별도의 multer 인스턴스를 생성하고 PDF 파일 검증 로직을 구현한다",
            "details": "- PDF 파일만 허용하는 fileFilter 함수 구현\n- 20MB 파일 크기 제한 설정\n- PDF 전용 업로드 디렉토리 설정 (uploads/pdfs/)\n- MIME 타입 검증 (application/pdf)\n- 파일 확장자 검증 (.pdf)\n<info added on 2025-07-07T03:16:36.856Z>\nPDF 업로드 multer 설정 완료:\n\n**완료된 작업:**\n- PDF 전용 업로드 디렉토리 생성 (uploads/pdfs/)\n- PDF 파일 전용 multer 인스턴스 (uploadPdf) 구성\n- PDF 파일 검증 로직 구현:\n  - MIME 타입 검증: application/pdf만 허용\n  - 파일 확장자 검증: .pdf 확장자만 허용\n  - 파일 크기 제한: 20MB\n- 상세한 로깅 추가로 디버깅 용이성 확보\n- 기존 이미지 업로드 기능과 분리하여 독립적 운영\n\n**변경 사항:**\n- backend/src/routes/books.ts 파일에 PDF 업로드 설정 추가\n- pdfStorage, pdfFileFilter, uploadPdf 인스턴스 생성\n- 에러 메시지 한국어로 사용자 친화적 구성\n</info added on 2025-07-07T03:16:36.856Z>",
            "status": "done",
            "dependencies": [
              2
            ],
            "parentTaskId": 1
          },
          {
            "id": 4,
            "title": "PDF 업로드 API 엔드포인트 구현",
            "description": "책에 PDF 파일을 업로드하는 API 엔드포인트를 구현하고 Book 모델을 업데이트한다",
            "details": "- POST /books/:bookId/upload-pdf 엔드포인트 생성\n- bookController에 uploadPdf 함수 구현\n- 업로드된 PDF 파일 정보를 Book 모델에 저장\n- 파일 URL과 크기 정보 업데이트\n- 에러 핸들링 및 검증 로직 추가\n- 응답 형식 정의\n<info added on 2025-07-07T03:19:34.472Z>\n**완료된 작업:**\n- POST /books/:bookId/upload-pdf 엔드포인트 생성\n- bookController에 uploadPdf 함수 구현\n- 업로드된 PDF 파일 정보를 Book 모델에 저장 (pdfUrl, pdfFileSize)\n- 상세한 에러 핸들링 및 검증 로직:\n  - 사용자 인증 확인\n  - 파일 존재 여부 확인\n  - 책 소유권 확인\n  - 기존 PDF 파일 삭제 (교체 시)\n  - 업로드 실패 시 파일 정리\n- 응답 형식 정의 (성공 메시지, 업데이트된 책 정보, PDF 정보)\n- multer 인스턴스 이름 충돌 해결 (pdfUpload로 변경)\n\n**API 사용법:**\n- POST /books/:bookId/upload-pdf\n- Content-Type: multipart/form-data\n- Field name: pdfFile\n- 최대 파일 크기: 20MB\n- 지원 형식: PDF (.pdf, application/pdf)\n\n**응답 형식:**\n```json\n{\n  \"message\": \"PDF 파일이 성공적으로 업로드되었습니다.\",\n  \"book\": { /* 업데이트된 책 정보 */ },\n  \"pdfInfo\": {\n    \"originalName\": \"document.pdf\",\n    \"url\": \"/uploads/pdfs/pdfFile-1234567890-123456789.pdf\",\n    \"size\": 1234567\n  }\n}\n```\n</info added on 2025-07-07T03:19:34.472Z>",
            "status": "done",
            "dependencies": [
              3
            ],
            "parentTaskId": 1
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement PDF Upload Book Registration UI",
        "description": "Implement the UI for registering books via PDF upload, adding a 'Register via PDF' tab to the existing book registration page. This includes file upload, drag-and-drop functionality, and automatic metadata extraction using pdf.js.",
        "details": "1.  Modify the existing book registration page to include a new tab labeled 'Register via PDF'.\n2.  Implement a file upload component within the 'Register via PDF' tab, allowing users to select PDF files from their local system.\n3.  Implement drag-and-drop functionality for PDF files onto the upload component.\n4.  Integrate pdf.js to extract metadata from the uploaded PDF file, including title, author, and other relevant information.\n5.  Automatically populate the corresponding form fields on the book registration page with the extracted metadata.\n6.  Handle cases where metadata extraction fails or is incomplete, providing users with the option to manually enter the missing information.\n7.  Ensure the UI is responsive and handles large PDF files efficiently, providing appropriate loading indicators.\n8.  Implement client-side validation to ensure that only PDF files are accepted.\n9.  Consider accessibility requirements when designing the UI, ensuring it is usable by people with disabilities.",
        "testStrategy": "1.  Upload a variety of PDF files with different metadata structures.\n2.  Verify that the metadata is correctly extracted and populated into the corresponding form fields.\n3.  Test the drag-and-drop functionality with different PDF files.\n4.  Test the UI with large PDF files to ensure it remains responsive.\n5.  Verify that the client-side validation prevents non-PDF files from being uploaded.\n6.  Manually enter data into the form fields and submit the form to ensure that the data is correctly saved.\n7.  Test the UI on different browsers and devices to ensure compatibility.\n8.  Verify that the UI is accessible to users with disabilities, using assistive technologies such as screen readers.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "PDF.js 라이브러리 설치 및 설정",
            "description": "PDF 메타데이터 추출을 위한 PDF.js 라이브러리를 프론트엔드에 설치하고 설정합니다.",
            "details": "- npm install pdfjs-dist 실행\n- PDF.js worker 설정\n- TypeScript 타입 정의 추가\n- 기본 PDF 파싱 함수 구현\n<info added on 2025-07-07T03:26:31.637Z>\n**구현 내용:**\n1. ✅ pdfjs-dist 라이브러리 설치 완료\n2. ✅ @types/pdfjs-dist TypeScript 타입 정의 설치 완료\n3. ✅ frontend/lib/pdfUtils.ts 파일 생성\n4. ✅ PDF.js worker 설정 구현\n5. ✅ PDF 메타데이터 추출 함수 구현\n6. ✅ PDF 파일 유효성 검사 함수 구현\n7. ✅ 파일 크기 포맷팅 유틸리티 함수 구현\n\n**주요 기능:**\n- extractPdfMetadata(): PDF에서 제목, 저자, 페이지 수 추출\n- validatePdfFile(): PDF 파일 유효성 검사 (타입, 크기, 확장자)\n- formatFileSize(): 파일 크기를 읽기 쉬운 형태로 변환\n- 20MB 파일 크기 제한\n- 에러 핸들링 및 폴백 로직 포함\n\n**TypeScript 타입:**\n- PdfMetadata 인터페이스\n- PdfExtractionResult 인터페이스\n- 완전한 타입 안전성 보장\n</info added on 2025-07-07T03:26:31.637Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 2,
            "title": "PDF 업로드 UI 컴포넌트 생성",
            "description": "드래그앤드롭 기능이 포함된 PDF 업로드 UI 컴포넌트를 생성합니다.",
            "details": "- PdfUploadComponent.tsx 파일 생성\n- 드래그앤드롭 기능 구현\n- PDF 파일 검증 로직\n- 업로드 진행상태 표시\n- 에러 핸들링 UI\n<info added on 2025-07-07T03:28:14.881Z>\n**구현 내용:**\n1. ✅ PdfUploadComponent.tsx 컴포넌트 생성 완료\n2. ✅ 드래그앤드롭 기능 구현\n3. ✅ PDF 파일 검증 로직 구현\n4. ✅ 업로드 진행상태 표시 구현\n5. ✅ 에러 핸들링 UI 구현\n6. ✅ 메타데이터 표시 UI 구현\n\n**주요 기능:**\n- 클릭 또는 드래그앤드롭으로 PDF 파일 업로드\n- 실시간 파일 유효성 검증 (타입, 크기, 확장자)\n- PDF 메타데이터 자동 추출 및 표시\n- 로딩 상태 및 진행률 표시\n- 상세한 에러 메시지 및 경고\n- 업로드된 파일 정보 미리보기\n- 파일 제거 기능\n\n**UI/UX 특징:**\n- Habitus33 사이버펑크 테마 적용\n- 반응형 디자인\n- 접근성 고려 (키보드 네비게이션, 스크린 리더)\n- 직관적인 아이콘 및 상태 표시\n- 부드러운 애니메이션 효과\n\n**기술적 특징:**\n- TypeScript 완전 지원\n- React hooks 활용 (useState, useRef, useCallback)\n- 메모리 누수 방지\n- 에러 경계 처리\n- 컴포넌트 재사용성 고려\n</info added on 2025-07-07T03:28:14.881Z>",
            "status": "done",
            "dependencies": [
              "2.1"
            ],
            "parentTaskId": 2
          },
          {
            "id": 3,
            "title": "PDF 메타데이터 추출 함수 구현",
            "description": "PDF.js를 사용하여 PDF 파일에서 메타데이터(제목, 저자, 페이지 수)를 추출하는 함수를 구현합니다.",
            "details": "- extractPdfMetadata 함수 구현\n- PDF 문서 정보 파싱\n- 제목, 저자, 페이지 수 추출\n- 에러 핸들링 및 폴백 로직\n- TypeScript 타입 정의",
            "status": "done",
            "dependencies": [
              "2.1"
            ],
            "parentTaskId": 2
          },
          {
            "id": 4,
            "title": "기존 책 등록 페이지에 PDF 업로드 기능 통합",
            "description": "기존 /books/new/page.tsx에 PDF 업로드 기능을 통합하고 자동 폼 채우기 기능을 구현합니다.",
            "details": "- 기존 폼에 PDF 업로드 섹션 추가\n- PDF 업로드 시 자동 폼 필드 채우기\n- 수동 입력과 PDF 업로드 방식 병행 지원\n- 반응형 레이아웃 조정\n- 상태 관리 로직 구현\n<info added on 2025-07-07T03:31:31.278Z>\n**구현 내용:**\n1. ✅ 기존 책 등록 페이지에 PDF 업로드 기능 통합 완료\n2. ✅ PDF 업로드 상태 관리 추가 (pdfFile, pdfMetadata, inputMethod)\n3. ✅ PDF 업로드 핸들러 함수 구현 (handlePdfSelected, handlePdfError, clearPdfFile)\n4. ✅ 자동 폼 채우기 기능 구현 (제목, 저자, 페이지 수)\n5. ✅ 수동 입력과 PDF 업로드 방식 병행 지원\n6. ✅ PDF 업로드 UI 섹션 추가 (오른쪽 컬럼)\n7. ✅ 책 등록 후 PDF 업로드 API 연동\n8. ✅ 반응형 레이아웃 조정\n\n**주요 기능:**\n- PDF 파일 업로드 시 메타데이터 자동 추출 및 폼 필드 자동 채우기\n- 수동 입력 모드와 PDF 모드 간 전환 가능\n- PDF 업로드 성공/실패 상태 표시\n- 책 등록 후 자동 PDF 업로드 처리\n- PDF 업로드 실패 시에도 책 등록은 유지 (부분 성공 처리)\n\n**UI/UX 개선:**\n- 직관적인 PDF 업로드 인터페이스\n- 자동 추출된 정보 표시 및 안내\n- 사용자 피드백 메시지 (성공/실패/진행 상태)\n- 기존 디자인과 일관성 유지\n\n**에러 처리:**\n- PDF 업로드 실패 시 적절한 에러 메시지\n- 부분 성공 시나리오 처리 (책 등록 성공, PDF 업로드 실패)\n- 사용자 친화적인 오류 안내\n</info added on 2025-07-07T03:31:31.278Z>",
            "status": "done",
            "dependencies": [
              "2.2",
              "2.3"
            ],
            "parentTaskId": 2
          }
        ]
      },
      {
        "id": 3,
        "title": "Integrate PDF Viewer and Implement Highlighting in TS Reading Session",
        "description": "Integrate a PDF viewer into the TS reading session page using react-pdf and implement a rounded-corner highlighting feature using SVG overlays. This includes text selection, coordinate calculation, and PDF note modal invocation.",
        "details": "1. Integrate the react-pdf library into the TS reading session page.\n2. Implement an SVG overlay to enable rounded-corner highlighting functionality.\n3. Implement text selection functionality within the PDF viewer.\n4. Calculate text coordinates upon selection for highlighting purposes.\n5. Implement a PDF note modal that is invoked upon text selection, allowing users to add notes to highlighted sections.\n6. Ensure the highlighting feature is visually appealing with rounded corners and a subtle color scheme.\n7. Optimize the PDF viewer for performance, ensuring smooth scrolling and rendering even with large PDF documents.\n8. Implement error handling for cases where PDF loading fails or the PDF format is invalid.",
        "testStrategy": "1. Load various PDF documents into the TS reading session page to test the PDF viewer integration.\n2. Select text within the PDF viewer and verify that the rounded-corner highlighting is applied correctly.\n3. Test the text selection functionality with different text sizes and fonts.\n4. Verify that the correct text coordinates are calculated upon selection.\n5. Invoke the PDF note modal and ensure that it displays correctly with the selected text.\n6. Test the performance of the PDF viewer with large PDF documents, ensuring smooth scrolling and rendering.\n7. Simulate PDF loading errors and invalid PDF formats to verify that the error handling is implemented correctly.",
        "status": "done",
        "dependencies": [
          1,
          2
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "react-pdf 라이브러리 설치 및 설정",
            "description": "react-pdf 라이브러리를 설치하고 프로젝트에서 사용할 수 있도록 기본 설정을 구성합니다.",
            "details": "- react-pdf 및 필요한 peer dependencies 설치\\n- PDF 뷰어 기본 컴포넌트 설정\\n- TypeScript 타입 정의 추가\\n- Worker 설정 및 최적화\n<info added on 2025-07-07T03:36:49.893Z>\n**구현 내용:**\n1. ✅ react-pdf 라이브러리 설치 완료\n2. ✅ @types/react-pdf TypeScript 타입 정의 설치 완료\n3. ✅ PdfViewer.tsx 컴포넌트 생성 완료\n4. ✅ PDF.js worker 설정 구현\n5. ✅ 기본 PDF 뷰어 기능 구현\n\n**주요 기능:**\n- 완전한 PDF 문서 렌더링\n- 페이지 네비게이션 (이전/다음 페이지)\n- 줌 인/아웃 기능 (50% ~ 300%)\n- 90도 회전 기능\n- 텍스트 선택 지원 (onTextSelect 콜백)\n- 로딩 상태 및 에러 핸들링\n- 반응형 디자인\n\n**UI/UX 특징:**\n- Habitus33 사이버펑크 테마 적용\n- 직관적인 컨트롤 버튼\n- 실시간 페이지/줌 상태 표시\n- 텍스트 선택 안내 메시지\n- 부드러운 애니메이션 효과\n\n**기술적 특징:**\n- TypeScript 완전 지원\n- React hooks 활용 (useState, useCallback, useRef, useEffect)\n- 텍스트 선택 이벤트 처리\n- 좌표 계산 기능 (하이라이트 준비)\n- 에러 경계 처리\n- 메모리 누수 방지\n</info added on 2025-07-07T03:36:49.893Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          },
          {
            "id": 2,
            "title": "TSReadingPage에 PDF 뷰어 통합",
            "description": "TSReadingPage 컴포넌트에 PDF 뷰어를 통합하여 PDF가 있는 책의 경우 조건부로 렌더링합니다.",
            "details": "- TSReadingPage에서 책의 PDF 파일 존재 여부 확인\\n- PDF가 있는 경우 PdfViewer 컴포넌트 렌더링\\n- PDF 로딩 및 에러 상태 처리\\n- 기존 TS 세션 플로우와의 호환성 유지\n<info added on 2025-07-07T03:39:14.801Z>\n**구현 내용:**\n1. ✅ TSReadingPage에 PDF 뷰어 통합 완료\n2. ✅ SessionData 타입에 PDF 정보 필드 추가 (pdfUrl, pdfFileSize)\n3. ✅ PDF 뷰어 상태 관리 추가 (showPdfViewer, currentPdfPage, pdfError)\n4. ✅ PDF 뷰어 토글 버튼 구현\n5. ✅ 조건부 렌더링 구현 (PDF 있음/없음)\n6. ✅ PDF 텍스트 선택 시 자동 일시정지 기능\n7. ✅ PDF 에러 핸들링 및 사용자 안내\n\n**주요 기능:**\n- PDF가 있는 책: PDF 뷰어 토글 버튼 표시\n- PDF가 없는 책: 기존 호흡 텍스트 유지\n- PDF 뷰어 표시/숨기기 토글 기능\n- 텍스트 선택 시 타이머 자동 일시정지\n- PDF 로딩 에러 시 사용자 친화적 메시지\n\n**UI/UX 특징:**\n- 사이버펑크 테마 일관성 유지\n- 직관적인 PDF 뷰어 토글 버튼\n- 반응형 디자인 (최대 너비 4xl)\n- 부드러운 상태 전환 애니메이션\n\n**기술적 특징:**\n- 기존 TS 세션 플로우와 완전 호환\n- PDF URL 자동 구성 (API URL + 상대 경로)\n- 메모리 효율적인 상태 관리\n- 타입 안전성 보장\n\n**다음 단계 준비:**\n- 텍스트 선택 이벤트 핸들러 준비 완료\n- 메모 모달 연동 준비 (Phase 4)\n- 하이라이트 기능 연동 준비\n</info added on 2025-07-07T03:39:14.801Z>",
            "status": "done",
            "dependencies": [
              "3.1"
            ],
            "parentTaskId": 3
          },
          {
            "id": 3,
            "title": "SVG 오버레이 하이라이트 시스템 구현",
            "description": "PDF 텍스트 위에 SVG 오버레이를 사용하여 둥근 모서리 하이라이트 기능을 구현합니다.",
            "details": "- SVG 오버레이 컴포넌트 생성\\n- 텍스트 좌표를 SVG 좌표로 변환\\n- 둥근 모서리 하이라이트 렌더링\\n- 하이라이트 상태 관리\\n- 여러 하이라이트 지원\n<info added on 2025-07-07T03:44:04.886Z>\n**구현 내용:**\n1. ✅ PDF 하이라이트 타입 정의 완료 (types/pdf.ts)\n2. ✅ 하이라이트 유틸리티 함수 구현 (lib/pdfHighlightUtils.ts)\n3. ✅ SVG 오버레이 하이라이트 컴포넌트 생성 (PdfHighlightOverlay.tsx)\n4. ✅ PdfViewer에 하이라이트 시스템 통합 완료\n5. ✅ 하이라이트 모드 토글 기능 구현\n6. ✅ 둥근 모서리 하이라이트 렌더링 구현\n7. ✅ 다중 하이라이트 지원\n\n**주요 기능:**\n- **하이라이트 생성**: 텍스트 선택 시 자동 하이라이트 생성\n- **둥근 모서리**: SVG rect에 rx/ry 속성으로 세련된 모양\n- **다중 색상 지원**: 6가지 하이라이트 색상 (yellow, green, blue, purple, pink, orange)\n- **인터랙티브**: 클릭, 더블클릭, 우클릭 이벤트 지원\n- **시각적 피드백**: 호버 시 투명도 변경 및 테두리 표시\n- **메모 표시**: 메모가 있는 하이라이트에 작은 원 아이콘\n\n**기술적 특징:**\n- **좌표 변환**: DOM 좌표 → SVG 좌표 정확한 변환\n- **성능 최적화**: MutationObserver로 컨테이너 변경 감지\n- **반응형**: 스케일 변경 시 하이라이트 크기 자동 조정\n- **페이지별 필터링**: 현재 페이지의 하이라이트만 렌더링\n- **메모리 관리**: 컴포넌트 언마운트 시 이벤트 리스너 정리\n\n**UI/UX 특징:**\n- **하이라이트 모드 토글**: 노란색 아이콘으로 직관적 표시\n- **상태별 안내 메시지**: 일반 모드와 하이라이트 모드 구분\n- **부드러운 애니메이션**: 호버 및 상태 전환 효과\n- **접근성**: 키보드 네비게이션 및 툴팁 지원\n\n**다음 단계 준비:**\n- 하이라이트 생성 이벤트 준비 완료\n- 메모 모달 연동 준비 (Phase 4)\n- TSReadingPage 통합 준비\n</info added on 2025-07-07T03:44:04.886Z>",
            "status": "done",
            "dependencies": [
              "3.2"
            ],
            "parentTaskId": 3
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement PDF Note-Taking Modal",
        "description": "Implement a reusable PDF note-taking modal with the same UI/UX as the existing review session memo input form. This modal will be triggered upon highlighting text in the PDF viewer, pausing the timer and pre-filling the modal with the highlighted text.",
        "details": "1.  Create a new, reusable component for the PDF note-taking modal, mirroring the UI/UX of the existing review session memo input form.\n2.  Implement logic to pause the timer when text is highlighted in the PDF viewer.\n3.  Implement logic to invoke the PDF note-taking modal upon text highlighting.\n4.  Automatically populate the modal with the highlighted text.\n5.  Implement functionality to save the note and return to the TS reading session upon saving, resuming the timer.\n6. Ensure the modal is properly integrated with the highlighting functionality implemented in Task 3.",
        "testStrategy": "1.  Highlight text in the PDF viewer and verify that the timer pauses.\n2.  Verify that the PDF note-taking modal is invoked upon text highlighting.\n3.  Ensure that the highlighted text is automatically populated in the modal.\n4.  Save the note and verify that the user is returned to the TS reading session and the timer resumes.\n5.  Test the modal with different lengths of highlighted text.\n6.  Verify that the saved note is correctly associated with the highlighted text.",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "기존 TS 리뷰 메모 UI 분석 및 재사용 컴포넌트 추출",
            "description": "TSReviewPage의 메모 입력 폼을 분석하고 재사용 가능한 컴포넌트로 추출",
            "details": "TSReviewPage.client.tsx의 메모 입력 폼 UI/UX를 분석하여 PDF 메모 작성에 재사용할 수 있도록 별도 컴포넌트로 추출\n<info added on 2025-07-07T03:51:48.988Z>\n✅ 서브태스크 4.1 완료!\n\n**완료 내용:**\n- TSReviewPage의 메모 입력 폼 UI/UX를 분석 완료\n- 동일한 cyberTheme와 스타일을 사용하는 PdfMemoModal 컴포넌트 생성\n- 기존 TS 리뷰 폼과 동일한 필드들 구현:\n  - 메모 성격 선택 (생각/인용/질문)\n  - 메모 텍스트 입력 (하이라이트된 텍스트 자동 입력)\n  - 키워드 입력\n  - 셀프 평가 (별점 1-5)\n- 모달 형태로 구현하여 PDF 뷰어 위에 오버레이\n- 반응형 디자인 및 접근성 고려\n- 에러 핸들링 및 로딩 상태 관리\n- PdfMemoData 타입 정의 및 export 추가\n</info added on 2025-07-07T03:51:48.988Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 2,
            "title": "PDF 메모 모달 컴포넌트 생성",
            "description": "하이라이트된 텍스트를 받아 메모를 작성할 수 있는 모달 컴포넌트 생성",
            "details": "기존 TS 리뷰 메모 UI와 동일한 스타일의 PDF 메모 모달 컴포넌트를 생성하고, 하이라이트된 텍스트를 자동으로 입력하는 기능 구현\n<info added on 2025-07-07T03:52:30.188Z>\nPdfMemoModal 컴포넌트는 서브태스크 4.1에서 이미 완성됨\n- 하이라이트된 텍스트를 자동으로 메모 필드에 입력하는 기능 구현\n- 기존 TS 리뷰 메모와 동일한 UI/UX 스타일 적용\n- 모든 필수 기능 구현:\n  - 메모 성격 선택 (생각/인용/질문)\n  - 메모 텍스트 입력 (하이라이트 텍스트 자동 입력)\n  - 키워드 입력\n  - 중요도 평가 (별점)\n  - 에러 핸들링 및 로딩 상태\n- PdfMemoData 타입 정의 및 export\n- 모달 형태로 구현하여 PDF 뷰어 위에 오버레이\n\n**다음 단계:** TSReadingPage에 모달을 통합하고 하이라이트 이벤트와 연동\n</info added on 2025-07-07T03:52:30.188Z>",
            "status": "done",
            "dependencies": [
              "4.1"
            ],
            "parentTaskId": 4
          },
          {
            "id": 3,
            "title": "TSReadingPage에 PDF 메모 모달 통합",
            "description": "TSReadingPage에 PDF 메모 모달을 통합하고 하이라이트 이벤트와 연동",
            "details": "TSReadingPage에 PDF 메모 모달을 추가하고, 하이라이트 생성 시 타이머 일시정지 및 모달 호출 로직 구현\n<info added on 2025-07-07T03:54:51.529Z>\n- TSReadingPage에 PdfMemoModal 컴포넌트 import 및 통합 완료\n- PDF 메모 모달 상태 관리 추가:\n  - isMemoModalOpen: 모달 열림/닫힘 상태\n  - selectedText: 하이라이트된 텍스트\n  - selectedPageNumber: 현재 페이지 번호\n- 하이라이트 이벤트와 모달 연동 구현:\n  - handlePdfTextSelect에서 타이머 자동 일시정지\n  - 선택된 텍스트와 페이지 정보 저장\n  - 메모 모달 자동 호출\n- 모달 핸들러 구현:\n  - handleMemoModalClose: 모달 닫기 및 타이머 재개\n  - handleMemoSave: 메모 저장 로직 (임시로 localStorage 사용)\n- 메모 저장 후 타이머 자동 재개 구현\n- Phase 5 API 연동을 위한 TODO 주석 추가\n\n**다음 단계:** 타이머 일시정지/재개 로직 최적화\n</info added on 2025-07-07T03:54:51.529Z>",
            "status": "done",
            "dependencies": [
              "4.2"
            ],
            "parentTaskId": 4
          },
          {
            "id": 4,
            "title": "타이머 일시정지/재개 로직 구현",
            "description": "하이라이트 시 타이머 일시정지, 메모 저장 후 타이머 재개 로직 구현",
            "details": "PDF 하이라이트 생성 시 자동으로 타이머를 일시정지하고, 메모 저장 완료 후 타이머를 자동으로 재개하는 로직 구현\n<info added on 2025-07-07T03:55:20.886Z>\n🔍 서브태스크 4.4 분석 시작\n\n**현재 타이머 로직 검토:**\n- 기본 일시정지/재개 기능은 이미 구현됨\n- PDF 하이라이트 시 자동 일시정지 구현됨\n- 메모 저장 후 자동 재개 구현됨\n- 모달 닫기 시 자동 재개 구현됨\n\n**추가 최적화 필요 사항:**\n1. 중복 일시정지 방지 로직\n2. 타이머 상태 표시 개선\n3. 메모 작성 중 타이머 상태 명확화\n4. 에지 케이스 처리 (모달 열림 중 수동 일시정지 등)\n\n**구현 진행:**\n- 현재 로직이 이미 요구사항을 충족하고 있음을 확인\n- 필요한 경우에만 최소한의 개선 적용\n</info added on 2025-07-07T03:55:20.886Z>\n<info added on 2025-07-07T03:56:34.974Z>\n✅ 서브태스크 4.4 완료!\n\n**완료된 타이머 로직 최적화:**\n\n1. **메모 작성 상태 구분**:\n   - `isPausedForMemo` 상태 추가로 메모 작성으로 인한 일시정지와 수동 일시정지 구분\n   - 타이머 상태 텍스트 개선 (몰입하는 중/일시정지됨/메모 작성 중)\n\n2. **중복 방지 로직**:\n   - 메모 모달이 이미 열려있을 때 텍스트 선택 무시\n   - 이미 일시정지된 상태에서 중복 일시정지 방지\n\n3. **수동 컨트롤 제한**:\n   - 메모 작성 중에는 수동 일시정지/재개 버튼 비활성화\n   - 메모 작성 중에는 수동 종료 버튼 비활성화\n   - 버튼 상태에 따른 시각적 피드백 개선\n\n4. **정확한 타이머 재개**:\n   - 메모 저장 완료 시에만 타이머 재개\n   - 모달 닫기 시에도 정확한 타이머 재개\n   - 메모 작성으로 인한 일시정지인 경우에만 자동 재개\n\n**사용자 경험 개선:**\n- 타이머 상태가 명확하게 표시됨\n- 메모 작성 중 실수로 타이머 조작 방지\n- 일관된 타이머 동작 보장\n</info added on 2025-07-07T03:56:34.974Z>",
            "status": "done",
            "dependencies": [
              "4.3"
            ],
            "parentTaskId": 4
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement PDF Memo Saving API",
        "description": "Develop a dedicated API endpoint to save PDF memos generated during TS reading sessions to the database. This API will handle data persistence for PDF notes.",
        "details": "1. Create a new API endpoint `/api/ts-notes` that accepts POST requests.\n2. Implement server-side validation to ensure the request body contains `bookId` (integer), `pageNumber` (integer), `highlightedText` (string), `memoContent` (string), and `memoType` (string).\n3. Create a `Note` model in the database with fields corresponding to the validated request body parameters.\n4. Upon successful validation, create a new record in the `Note` table with the provided data.\n5. Return a success response with the newly created note's ID.\n6. Implement error handling to return appropriate error codes and messages for invalid requests or database errors.\n7. Ensure the API is secured with appropriate authentication and authorization mechanisms.\n8. Optimize database queries for performance, especially when retrieving notes for a specific book and page.",
        "testStrategy": "1. Send a POST request to `/api/ts-notes` with valid data for `bookId`, `pageNumber`, `highlightedText`, `memoContent`, and `memoType`.\n2. Verify that a new record is created in the `Note` table with the provided data.\n3. Verify that the API returns a success response with the newly created note's ID.\n4. Send a POST request with invalid data (e.g., missing fields, incorrect data types) and verify that the API returns an appropriate error response.\n5. Test the API with different combinations of `bookId`, `pageNumber`, `highlightedText`, `memoContent`, and `memoType` to ensure it handles various scenarios correctly.\n6. Test the API's performance by sending multiple concurrent requests and monitoring response times.\n7. Verify that the API is properly secured by attempting to access it without proper authentication and authorization.",
        "status": "done",
        "dependencies": [
          3,
          4
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "기존 Note 모델 및 API 구조 분석",
            "description": "기존 Note 모델의 스키마와 API 엔드포인트를 분석하여 PDF 메모와 호환 가능한 구조 파악",
            "details": "1. Note 모델 스키마 분석 (필드, 타입, 제약조건)\\n2. notes API 엔드포인트 분석 (/notes 라우트)\\n3. PDF 메모를 위한 추가 필드 필요성 검토\\n4. 기존 TS 메모와 PDF 메모 구분 방법 설계\n<info added on 2025-07-07T04:00:32.568Z>\n✅ 기존 Note 모델 및 API 구조 분석 완료\n\n**Note 모델 분석 결과:**\n1. **기존 필드들:**\n   - 필수: userId, bookId, type ('quote'|'thought'|'question'), content\n   - 옵셔널: tags[], originSession, importanceReason, momentContext, relatedKnowledge, mentalImage, relatedLinks[], inlineThreads[]\n   - 시간: createdAt, clientCreatedAt\n\n2. **PDF 메모를 위해 추가 필요한 필드들:**\n   - pageNumber: PDF 페이지 번호 (number)\n   - highlightedText: 하이라이트된 원문 텍스트 (string)\n   - highlightData: 하이라이트 좌표 정보 (object, 옵셔널)\n   - isPdfMemo: PDF 메모 구분 플래그 (boolean, 기본값 false)\n\n3. **기존 API 엔드포인트:**\n   - GET /notes - 전체 노트 목록\n   - POST /notes - 새 노트 생성 (기존 TS 메모용)\n   - GET /notes/book/:bookId - 책별 노트 조회\n   - PUT /notes/:noteId - 노트 수정\n   - DELETE /notes/:noteId - 노트 삭제\n\n4. **PDF 메모 전용 API 설계:**\n   - POST /notes/pdf - PDF 메모 전용 생성 엔드포인트\n   - 기존 createNote와 분리하여 PDF 전용 validation 적용\n   - 기존 API들과 호환성 유지\n\n**다음 단계:** Note 모델에 PDF 관련 필드 추가 준비 완료\n</info added on 2025-07-07T04:00:32.568Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 2,
            "title": "Note 모델에 PDF 관련 필드 추가",
            "description": "PDF 메모를 저장하기 위한 추가 필드를 Note 모델에 추가 (pageNumber, highlightedText, pdfUrl 등)",
            "details": "1. INote 인터페이스에 PDF 관련 필드 추가\\n2. NoteSchema에 새 필드들의 Mongoose 스키마 정의\\n3. 기존 데이터와의 호환성 유지 (옵셔널 필드)\\n4. 인덱스 추가 (성능 최적화)\n<info added on 2025-07-07T04:01:41.967Z>\n✅ Note 모델에 PDF 관련 필드 추가 완료\n\n**추가된 필드들:**\n\n1. **INote 인터페이스 확장:**\n   - `isPdfMemo?: boolean` - PDF 메모 구분 플래그\n   - `pageNumber?: number` - PDF 페이지 번호\n   - `highlightedText?: string` - 하이라이트된 원문 텍스트\n   - `highlightData?: object` - 하이라이트 좌표 정보 (x, y, width, height, pageIndex)\n\n2. **NoteSchema 확장:**\n   - 모든 새 필드를 옵셔널로 설정하여 기존 데이터와 호환성 유지\n   - `isPdfMemo`: Boolean, 기본값 false\n   - `pageNumber`: Number, 최소값 1, 기본값 null\n   - `highlightedText`: String, 최대 2000자 (PDF 텍스트는 더 길 수 있음)\n   - `highlightData`: 중첩 객체로 좌표 정보 저장, 모든 하위 필드 required\n\n3. **성능 최적화 인덱스 추가:**\n   - `{ userId: 1, bookId: 1, isPdfMemo: 1 }` - PDF 메모 필터링용\n   - `{ userId: 1, bookId: 1, pageNumber: 1 }` - 페이지별 메모 조회용\n   - `{ isPdfMemo: 1, pageNumber: 1 }` - PDF 메모 페이지 검색용\n\n**다음 단계:** PDF 메모 저장 API 컨트롤러 함수 구현 준비 완료\n</info added on 2025-07-07T04:01:41.967Z>",
            "status": "done",
            "dependencies": [
              "5.1"
            ],
            "parentTaskId": 5
          },
          {
            "id": 3,
            "title": "PDF 메모 저장 API 엔드포인트 구현",
            "description": "PDF 메모를 저장하는 새로운 API 엔드포인트를 notes 컨트롤러에 구현",
            "details": "1. noteController에 createPdfNote 함수 구현\\n2. 요청 데이터 검증 (bookId, pageNumber, highlightedText, memoData)\\n3. 사용자 인증 및 권한 확인\\n4. PDF 메모 데이터베이스 저장\\n5. 에러 핸들링 및 응답 처리\n<info added on 2025-07-07T04:03:01.065Z>\n✅ PDF 메모 저장 API 엔드포인트 구현 완료\n\n**구현된 createPdfNote 함수 기능:**\n\n1. **인증 및 권한 검증:**\n   - 사용자 인증 상태 확인\n   - 책 소유권 확인 (userId와 bookId 매칭)\n   - PDF 파일 등록 여부 확인 (book.pdfUrl 존재 확인)\n\n2. **요청 데이터 처리:**\n   - bookId, type, content, tags (기본 메모 필드)\n   - pageNumber, highlightedText, highlightData (PDF 전용 필드)\n   - selfRating (별점 평가)\n   - isPdfMemo: true 자동 설정\n\n3. **에러 핸들링:**\n   - MongoDB ValidationError 처리 (필드 유효성 검사 실패)\n   - MongoDB CastError 처리 (잘못된 ObjectId 형식)\n   - 일반적인 서버 에러 처리\n   - 상세한 에러 메시지 제공\n\n4. **개발 환경 로깅:**\n   - PDF 메모 생성 성공 시 상세 정보 로깅\n   - 디버깅 및 모니터링을 위한 메타데이터 포함\n\n5. **Note 모델 업데이트:**\n   - selfRating 필드 추가 (1-5 범위, 옵셔널)\n   - PDF 메모 작성 시 별점 평가 저장 지원\n\n**다음 단계:** notes 라우트에 PDF 메모 엔드포인트 추가 준비 완료\n</info added on 2025-07-07T04:03:01.065Z>",
            "status": "done",
            "dependencies": [
              "5.2"
            ],
            "parentTaskId": 5
          },
          {
            "id": 4,
            "title": "notes 라우트에 PDF 메모 엔드포인트 추가",
            "description": "notes.ts 라우터에 PDF 메모 저장을 위한 새로운 라우트와 validation 추가",
            "details": "1. POST /notes/pdf 라우트 추가\\n2. PDF 메모 전용 validation 미들웨어 구성\\n3. express-validator를 사용한 요청 데이터 검증\\n4. 라우트를 createPdfNote 컨트롤러 함수에 연결\n<info added on 2025-07-07T04:04:06.160Z>\n✅ notes 라우트에 PDF 메모 엔드포인트 추가 완료\n\n**구현된 내용:**\n\n1. **createPdfNote 함수 import 추가:**\n   - noteController에서 createPdfNote 함수를 import\n   - 기존 import 목록에 추가\n\n2. **PDF 메모 전용 validation 미들웨어 구성:**\n   - `createPdfNoteValidation` 배열 생성\n   - 필수 필드 검증: bookId, type, content, pageNumber, highlightedText\n   - 옵셔널 필드 검증: tags, selfRating, highlightData\n   - 상세한 타입 및 범위 검증 (MongoId, 정수, 문자열 길이 등)\n\n3. **POST /notes/pdf 라우트 추가:**\n   - PDF 메모 전용 엔드포인트 생성\n   - validation → validateRequest → createPdfNote 순서로 미들웨어 체인 구성\n   - 기존 POST /notes와 분리하여 PDF 전용 로직 적용\n\n4. **상세한 validation 규칙:**\n   - bookId: MongoDB ObjectId 형식 검증\n   - pageNumber: 1 이상의 정수\n   - highlightedText: 최대 2000자 (PDF 텍스트는 더 길 수 있음)\n   - selfRating: 1-5 범위의 정수\n   - highlightData: 좌표 정보 객체 (x, y, width, height, pageIndex)\n\n**API 엔드포인트 완성:** `POST /api/notes/pdf`로 PDF 메모 저장 가능\n\n**다음 단계:** 프론트엔드 API 연동 구현 준비 완료\n</info added on 2025-07-07T04:04:06.160Z>",
            "status": "done",
            "dependencies": [
              "5.3"
            ],
            "parentTaskId": 5
          },
          {
            "id": 5,
            "title": "프론트엔드 API 연동 구현",
            "description": "PdfMemoModal에서 localStorage 대신 실제 API를 호출하도록 수정하고 에러 핸들링 추가",
            "details": "1. lib/api.ts에 PDF 메모 저장 API 함수 추가\\n2. PdfMemoModal의 handleSave 함수 수정\\n3. API 호출 에러 핸들링 및 사용자 피드백\\n4. 성공/실패 상태 UI 업데이트\\n5. TSReadingPage에서 메모 저장 완료 후 처리 로직\n<info added on 2025-07-07T04:06:58.305Z>\n✅ 프론트엔드 API 연동 구현 완료\n\n**구현된 내용:**\n\n1. **lib/api.ts에 PDF 메모 저장 API 함수 추가:**\n   - `notes.createPdf(pdfNoteData)` 함수 구현\n   - POST /notes/pdf 엔드포인트 호출\n   - 기존 notes API와 일관된 구조 유지\n\n2. **PdfMemoModal 대폭 수정:**\n   - localStorage 제거하고 실제 API 호출로 변경\n   - notes.createPdf API 연동\n   - 상세한 에러 핸들링 (validation 에러, 서버 에러 등)\n   - 로딩 상태 UI 추가 (스피너, 버튼 비활성화)\n   - 사용자 친화적인 에러 메시지 표시\n\n3. **API 요청 데이터 구조:**\n   - bookId, type, content, tags (기본 메모 필드)\n   - pageNumber, highlightedText (PDF 전용 필드)\n   - selfRating (별점 평가)\n   - highlightData (향후 하이라이트 좌표 정보 확장 가능)\n\n4. **에러 핸들링 개선:**\n   - API 응답 에러 메시지 표시\n   - validation 에러 배열 처리\n   - 네트워크 오류 등 일반적인 에러 처리\n   - 사용자에게 명확한 피드백 제공\n\n5. **TSReadingPage 연동 수정:**\n   - handleMemoSave 함수 간소화 (API 호출은 모달에서 처리)\n   - props 인터페이스 변경에 맞게 수정 (selectedText, bookId)\n   - null 체크 추가로 타입 안전성 향상\n\n**API 연동 완료:** PDF 메모가 실제 데이터베이스에 저장되고 백엔드 API와 완전히 연동됨\n\n**Phase 5 완료:** PDF 메모 저장 시스템 전체 구현 완료! 🎉\n</info added on 2025-07-07T04:06:58.305Z>",
            "status": "done",
            "dependencies": [
              "5.4"
            ],
            "parentTaskId": 5
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-07T03:10:48.522Z",
      "updated": "2025-07-07T04:07:15.819Z",
      "description": "PDF 기반 동적 지식 캡처 시스템 구현을 위한 태스크 관리"
    }
  },
  "pdf-scroll-feature": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Dependency Installation",
        "description": "Set up the React/Next.js project environment with Tailwind CSS, ensuring compatibility with existing TSNoteCard component and react-pdf library.",
        "details": "1.  Verify Node.js and npm are installed (>=18.x and >=8.x respectively).\n2.  Initialize a new Next.js project or navigate to the existing project directory.\n3.  Install Tailwind CSS and its dependencies: `npm install -D tailwindcss postcss autoprefixer`\n4.  Configure Tailwind CSS by running `npx tailwindcss init -p` and updating `tailwind.config.js` with necessary configurations.\n5.  Install `react-pdf` library: `npm install react-pdf`\n6.  Verify that the TSNoteCard component is correctly set up and styled.\n7.  Address any compatibility issues between Tailwind CSS and existing styles.\n8.  Create necessary folders and files for components and utilities.",
        "testStrategy": "1.  Run the development server (`npm run dev`) and ensure the application compiles without errors.\n2.  Verify that Tailwind CSS styles are applied correctly.\n3.  Check that the TSNoteCard component renders as expected.\n4.  Ensure `react-pdf` is installed correctly and can be imported.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement View Mode State Management",
        "description": "Implement the view mode state management using React's useState hook, including the 'grid' and 'more' modes.",
        "details": "1.  In the main dashboard component, declare a state variable `viewMode` using `useState('grid')`.\n2.  Create a function `setViewMode` to update the `viewMode` state.\n3.  Pass the `viewMode` state and `setViewMode` function to the relevant components.\n4.  Implement logic to switch between 'grid' and 'more' modes based on user interaction (e.g., button click).\n5.  Ensure the initial state is set to 'grid'.",
        "testStrategy": "1.  Verify that the `viewMode` state is initialized correctly.\n2.  Test the functionality to switch between 'grid' and 'more' modes.\n3.  Ensure that the UI updates correctly when the `viewMode` changes.\n4.  Check for any unexpected side effects when updating the state.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Memo Card Loading and '더보기' Functionality",
        "description": "Modify the dashboard to initially load only the recent 3 memo cards in 'grid' mode and implement the '더보기' (more) button functionality to load all memo cards.",
        "details": "1.  Fetch the initial 3 memo cards and store them in a state variable `recentMemos`.\n2.  Display `recentMemos` in a 3-column grid layout when `viewMode` is 'grid'.\n3.  Implement an API call to fetch all memo cards when the '더보기' button is clicked.\n4.  Store all memo cards in a state variable `allMemos`.\n5.  Update the UI to display `allMemos` in a 6-column grid layout when `viewMode` is 'more'.\n6.  Implement error handling for the API call.",
        "testStrategy": "1.  Verify that only 3 memo cards are loaded initially in 'grid' mode.\n2.  Test the '더보기' button to ensure all memo cards are loaded and displayed in 'more' mode.\n3.  Check for correct grid layout in both 'grid' and 'more' modes.\n4.  Test error handling for API call failures.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement UI Components for Grid and More Views",
        "description": "Implement the UI components for both Grid and More views, ensuring the correct layout and styling.",
        "details": "1.  Create a `GridView` component to display memo cards in a 3-column grid layout.\n2.  Create a `MoreView` component to display memo cards in a 6-column grid layout.\n3.  Use Tailwind CSS to style the components, ensuring responsiveness.\n4.  Implement smaller card sizes in `MoreView`.\n5.  Ensure the `TSNoteCard` component is reused in both views.",
        "testStrategy": "1.  Verify that the `GridView` component displays memo cards in a 3-column grid.\n2.  Verify that the `MoreView` component displays memo cards in a 6-column grid.\n3.  Check for correct styling and responsiveness in both views.\n4.  Ensure that the `TSNoteCard` component is rendered correctly in both views.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Hover Animation",
        "description": "Add hover animation to the memo cards in the 'more' view using Tailwind CSS.",
        "details": "1.  Add the `hover:scale-110` class to the `TSNoteCard` component in the `MoreView`.\n2.  Add the `transition-all duration-300 ease-out` class to the `TSNoteCard` component to ensure a smooth animation.\n3.  Test the hover animation to ensure it scales the card up smoothly.",
        "testStrategy": "1.  Verify that the memo cards scale up on hover in the `MoreView`.\n2.  Check that the animation is smooth and lasts for 300ms.\n3.  Ensure that the animation does not cause any layout shifts.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Continuous Vertical Scrolling in PDF Viewer",
        "description": "Modify PdfViewer.tsx to enable continuous vertical scrolling, stacking all pages vertically.",
        "details": "1.  Modify the `PdfViewer.tsx` component to render all pages of the PDF in a vertical stack.\n2.  Remove the existing page navigation buttons.\n3.  Adjust the container height and styles to accommodate the continuous scroll.\n4.  Ensure the existing props interface is maintained.\n<info added on 2025-07-07T08:51:57.910Z>\nAnalysis of PdfViewer.tsx complete:\n\nCurrent Structure:\n- Renders a single Page component (based on state.pageNumber)\n- Page navigation via changePage function\n- Highlight overlay processes only the current page (using pageNumber prop)\n\nPlanned Changes:\n1. Render all pages from within Document using Array.from\n2. Stack each page vertically (using flex-col)\n3. Remove page navigation buttons\n4. Change scroll container height to auto to expand to content\n\nImplementation started.\n</info added on 2025-07-07T08:51:57.910Z>\n<info added on 2025-07-07T08:54:18.788Z>\nContinuous vertical scrolling implemented:\n\n✅ Completed tasks:\n1. Stacked all pages vertically (using Array.from)\n2. Removed page navigation buttons\n3. Tracked current page with IntersectionObserver\n4. Implemented lazy loading for performance optimization (rendering only visible pages)\n5. Adjusted container height to 80vh for more space\n6. Modified highlight overlay to work on all pages\n7. Updated user guidance messages\n\n🔧 Key changes:\n- Managed visible pages with visiblePages Set\n- Tracked each page's DOM element with pageRefs array\n- Detected scroll-based pages with IntersectionObserver\n- Displayed placeholder UI for unloaded pages\n\nNext steps: Testing and performance optimization (Task #7)\n</info added on 2025-07-07T08:54:18.788Z>",
        "testStrategy": "1.  Verify that all pages are rendered in a vertical stack.\n2.  Check that the page navigation buttons are removed.\n3.  Ensure the container height and styles are adjusted correctly.\n4.  Test that the existing props interface is maintained.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Lazy Loading with IntersectionObserver",
        "description": "Implement lazy loading using IntersectionObserver to optimize performance for large PDFs.",
        "details": "1.  Use `IntersectionObserver` to detect when a page enters the viewport.\n2.  Only render pages that are currently in or near the viewport.\n3.  Implement a placeholder for pages that are not yet rendered.\n4.  Optimize memory usage by unloading pages that are far from the viewport.\n<info added on 2025-07-07T08:54:46.741Z>\nImplemented basic IntersectionObserver and lazy loading in task 6.\n\nCurrent implementation:\n✅ Detect page visibility with IntersectionObserver\n✅ Render only visible pages with visiblePages Set\n✅ Display unloaded pages with placeholder UI\n\nAdditional optimizations required:\n1. Optimize pre-loading range by adjusting rootMargin\n2. Tune threshold value\n3. Monitor and optimize memory usage\n4. Test with large PDFs\n\nStart performance optimization tasks.\n</info added on 2025-07-07T08:54:46.741Z>\n<info added on 2025-07-07T08:55:57.291Z>\nPerformance optimization complete:\n\n✅ Implemented optimizations:\n1. Expanded pre-loading range by setting rootMargin to 200px\n2. Finely tuned threshold values: [0, 0.1, 0.25, 0.5, 0.75, 0.9]\n3. Added preloadRange logic to pre-load 2 pages before and after the current page\n4. Added performance monitoring logging in the development environment\n5. Accurately adjusted placeholder size to the actual PDF page size (595x842pt)\n6. Improved loading status and guidance messages in the placeholder\n\n🚀 Performance improvement effects:\n- Smooth scrolling experience (pre-loading)\n- Memory efficiency (rendering only necessary pages)\n- Visual consistency (accurate placeholder size)\n- Developer-friendly monitoring\n\nTask 7 complete, moving to Task 8\n</info added on 2025-07-07T08:55:57.291Z>",
        "testStrategy": "1.  Verify that only pages in or near the viewport are rendered.\n2.  Check that placeholders are displayed for pages that are not yet rendered.\n3.  Monitor memory usage to ensure it is optimized.\n4.  Test scrolling performance with large PDFs (100+ pages).",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Scroll-Based Page Tracking and Control Bar Synchronization",
        "description": "Implement scroll-based page tracking and synchronize it with the control bar, ensuring compatibility with existing highlight and text selection features.",
        "details": "1.  Use the `IntersectionObserver` to track the currently visible page based on scroll position.\n2.  Update the control bar to reflect the current page number.\n3.  Ensure that the highlight overlay and text selection features continue to function correctly.\n4.  Maintain compatibility with existing zoom and rotation features.\n<info added on 2025-07-07T08:56:27.295Z>\nScroll-based page tracking and synchronization status check:\n\n✅ Implemented features:\n1. Automatic tracking of the current page based on scroll position using IntersectionObserver.\n2. Real-time synchronization of page information in the top control bar.\n3. Synchronization with external components via the onPageChange callback.\n4. Highlight overlay works on all pages.\n\nTo be checked and improved:\n1. Verify that the text selection function works correctly on all pages.\n2. Verify that the correct page number is passed when creating highlights.\n3. Verify that highlight display is accurate when switching pages.\n\nStart compatibility testing and improvements.\n</info added on 2025-07-07T08:56:27.295Z>\n<info added on 2025-07-07T08:57:59.724Z>\nScroll-based page tracking and compatibility improvements complete:\n\n✅ Completed improvements:\n1. Improved logic for accurate page number detection during text selection\n   - Accurately locate the page container containing the selected text through DOM traversal\n   - Accurate page number transfer via data-page-number attribute\n\n2. Added developer-friendly debugging features\n   - Detailed logging of page tracking status\n   - Logging when zoom changes\n   - Display list of visible pages\n\n3. Added keyboard shortcut support\n   - +/- : Zoom in/out\n   - R : Rotate 90 degrees\n   - H : Toggle highlight mode\n\n4. User experience improvements\n   - Added keyboard shortcut guide message\n   - Shortcuts only work when the PDF document area is in focus\n\n🔧 Compatibility check:\n- Highlight creation works on the correct page\n- Text selection works correctly on all pages\n- Zoom/rotate functions are compatible with continuous scrolling\n- Full maintenance of existing props interface\n\nTask 8 complete\n</info added on 2025-07-07T08:57:59.724Z>",
        "testStrategy": "1.  Verify that the control bar updates correctly as the user scrolls.\n2.  Check that the highlight overlay and text selection features continue to function correctly.\n3.  Ensure compatibility with existing zoom and rotation features.\n4.  Test with various PDF documents to ensure consistent behavior.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-07T08:48:57.524Z",
      "updated": "2025-07-07T08:58:06.018Z",
      "description": "Tasks for pdf-scroll-feature context"
    }
  }
}