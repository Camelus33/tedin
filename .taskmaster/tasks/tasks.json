{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Dependency Installation",
        "description": "Set up the React/Next.js project environment with Tailwind CSS, ensuring compatibility with existing TSNoteCard component and react-pdf library.",
        "details": "1.  Verify Node.js and npm are installed (>=18.x and >=8.x respectively).\n2.  Initialize a new Next.js project or navigate to the existing project directory.\n3.  Install Tailwind CSS and its dependencies: `npm install -D tailwindcss postcss autoprefixer`\n4.  Configure Tailwind CSS by running `npx tailwindcss init -p` and updating `tailwind.config.js` with necessary configurations.\n5.  Install `react-pdf` library: `npm install react-pdf`\n6.  Verify that the TSNoteCard component is correctly set up and styled.\n7.  Address any compatibility issues between Tailwind CSS and existing styles.\n8.  Create necessary folders and files for components and utilities.",
        "testStrategy": "1.  Run the development server (`npm run dev`) and ensure the application compiles without errors.\n2.  Verify that Tailwind CSS styles are applied correctly.\n3.  Check that the TSNoteCard component renders as expected.\n4.  Ensure `react-pdf` is installed correctly and can be imported.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement View Mode State Management",
        "description": "Implement the view mode state management using React's useState hook, including the 'grid' and 'more' modes.",
        "details": "1.  In the main dashboard component, declare a state variable `viewMode` using `useState('grid')`.\n2.  Create a function `setViewMode` to update the `viewMode` state.\n3.  Pass the `viewMode` state and `setViewMode` function to the relevant components.\n4.  Implement logic to switch between 'grid' and 'more' modes based on user interaction (e.g., button click).\n5.  Ensure the initial state is set to 'grid'.",
        "testStrategy": "1.  Verify that the `viewMode` state is initialized correctly.\n2.  Test the functionality to switch between 'grid' and 'more' modes.\n3.  Ensure that the UI updates correctly when the `viewMode` changes.\n4.  Check for any unexpected side effects when updating the state.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Memo Card Loading and '더보기' Functionality",
        "description": "Modify the dashboard to initially load only the recent 3 memo cards in 'grid' mode and implement the '더보기' (more) button functionality to load all memo cards.",
        "details": "1.  Fetch the initial 3 memo cards and store them in a state variable `recentMemos`.\n2.  Display `recentMemos` in a 3-column grid layout when `viewMode` is 'grid'.\n3.  Implement an API call to fetch all memo cards when the '더보기' button is clicked.\n4.  Store all memo cards in a state variable `allMemos`.\n5.  Update the UI to display `allMemos` in a 6-column grid layout when `viewMode` is 'more'.\n6.  Implement error handling for the API call.",
        "testStrategy": "1.  Verify that only 3 memo cards are loaded initially in 'grid' mode.\n2.  Test the '더보기' button to ensure all memo cards are loaded and displayed in 'more' mode.\n3.  Check for correct grid layout in both 'grid' and 'more' modes.\n4.  Test error handling for API call failures.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement UI Components for Grid and More Views",
        "description": "Implement the UI components for both Grid and More views, ensuring the correct layout and styling.",
        "details": "1.  Create a `GridView` component to display memo cards in a 3-column grid layout.\n2.  Create a `MoreView` component to display memo cards in a 6-column grid layout.\n3.  Use Tailwind CSS to style the components, ensuring responsiveness.\n4.  Implement smaller card sizes in `MoreView`.\n5.  Ensure the `TSNoteCard` component is reused in both views.",
        "testStrategy": "1.  Verify that the `GridView` component displays memo cards in a 3-column grid.\n2.  Verify that the `MoreView` component displays memo cards in a 6-column grid.\n3.  Check for correct styling and responsiveness in both views.\n4.  Ensure that the `TSNoteCard` component is rendered correctly in both views.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Hover Animation",
        "description": "Add hover animation to the memo cards in the 'more' view using Tailwind CSS.",
        "details": "1.  Add the `hover:scale-110` class to the `TSNoteCard` component in the `MoreView`.\n2.  Add the `transition-all duration-300 ease-out` class to the `TSNoteCard` component to ensure a smooth animation.\n3.  Test the hover animation to ensure it scales the card up smoothly.",
        "testStrategy": "1.  Verify that the memo cards scale up on hover in the `MoreView`.\n2.  Check that the animation is smooth and lasts for 300ms.\n3.  Ensure that the animation does not cause any layout shifts.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Continuous Vertical Scrolling in PDF Viewer",
        "description": "Modify PdfViewer.tsx to enable continuous vertical scrolling, stacking all pages vertically.",
        "details": "1.  Modify the `PdfViewer.tsx` component to render all pages of the PDF in a vertical stack.\n2.  Remove the existing page navigation buttons.\n3.  Adjust the container height and styles to accommodate the continuous scroll.\n4.  Ensure the existing props interface is maintained.",
        "testStrategy": "1.  Verify that all pages are rendered in a vertical stack.\n2.  Check that the page navigation buttons are removed.\n3.  Ensure the container height and styles are adjusted correctly.\n4.  Test that the existing props interface is maintained.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Lazy Loading with IntersectionObserver",
        "description": "Implement lazy loading using IntersectionObserver to optimize performance for large PDFs.",
        "details": "1.  Use `IntersectionObserver` to detect when a page enters the viewport.\n2.  Only render pages that are currently in or near the viewport.\n3.  Implement a placeholder for pages that are not yet rendered.\n4.  Optimize memory usage by unloading pages that are far from the viewport.",
        "testStrategy": "1.  Verify that only pages in or near the viewport are rendered.\n2.  Check that placeholders are displayed for pages that are not yet rendered.\n3.  Monitor memory usage to ensure it is optimized.\n4.  Test scrolling performance with large PDFs (100+ pages).",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Scroll-Based Page Tracking and Control Bar Synchronization",
        "description": "Implement scroll-based page tracking and synchronize it with the control bar, ensuring compatibility with existing highlight and text selection features.",
        "details": "1.  Use the `IntersectionObserver` to track the currently visible page based on scroll position.\n2.  Update the control bar to reflect the current page number.\n3.  Ensure that the highlight overlay and text selection features continue to function correctly.\n4.  Maintain compatibility with existing zoom and rotation features.",
        "testStrategy": "1.  Verify that the control bar updates correctly as the user scrolls.\n2.  Check that the highlight overlay and text selection features continue to function correctly.\n3.  Ensure compatibility with existing zoom and rotation features.\n4.  Test with various PDF documents to ensure consistent behavior.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement IntersectionObserver-based Page Tracking",
            "description": "Set up IntersectionObserver to track which page is currently in view based on scroll position. Determine the logic for identifying the 'current' page when multiple pages are partially visible.",
            "dependencies": [],
            "details": "Use IntersectionObserver API to monitor the visibility of each page element. Define a threshold for determining when a page is considered 'in view'. Handle edge cases where multiple pages are partially visible.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Control Bar Update Logic",
            "description": "Develop the logic to update the control bar with the current page information based on the output from the IntersectionObserver. Ensure the control bar accurately reflects the currently viewed page.",
            "dependencies": [
              1
            ],
            "details": "Create a function that receives the current page information from the IntersectionObserver and updates the control bar's page number display. Handle cases where no page is in view (e.g., at the very beginning or end of the document).",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Ensure Compatibility with Highlight and Text Selection",
            "description": "Test and ensure that the scroll-based page tracking and control bar synchronization do not interfere with existing highlight and text selection functionalities. Address any conflicts that arise.",
            "dependencies": [
              1,
              2
            ],
            "details": "Test highlighting and text selection on different pages after implementing the scroll-based tracking. Identify and resolve any issues where the tracking logic prevents or disrupts highlighting or text selection.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Ensure Compatibility with Zoom and Rotation",
            "description": "Test and ensure that the scroll-based page tracking and control bar synchronization remain accurate and functional when the document is zoomed in/out or rotated. Adjust the IntersectionObserver thresholds or logic as needed.",
            "dependencies": [
              1,
              2
            ],
            "details": "Test the page tracking and control bar updates at different zoom levels and rotations. Adjust the IntersectionObserver's thresholds or the page detection logic to maintain accuracy under these conditions.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-07T08:48:57.524Z",
      "updated": "2025-07-07T08:49:24.607Z",
      "description": "Tasks for pdf-scroll-feature context"
    }
  },
  "pdf-knowledge-capture": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement PDF Upload API and Update Book Model",
        "description": "Extend the Book model with pdfUrl and pdfFileSize fields and implement an API endpoint for uploading PDF files to cloud storage, including server-side validation.",
        "details": "1.  Modify the Book model in the database schema to include the `pdfUrl` (string) and `pdfFileSize` (integer) fields.\n2.  Implement a new API endpoint `/books/{bookId}/upload-pdf` that accepts a PDF file as input.\n3.  Implement server-side validation to check the file format (must be PDF) and file size (must be less than 20MB).\n4.  Upon successful validation, upload the PDF file to cloud storage (e.g., AWS S3, Google Cloud Storage, or Azure Blob Storage).\n5.  Store the URL of the uploaded PDF file in the `pdfUrl` field of the Book model.\n6.  Store the size of the uploaded PDF file in the `pdfFileSize` field of the Book model.\n7.  Return a success response with the updated Book model.\n8.  Handle potential errors such as invalid file format, file size exceeding the limit, and cloud storage upload failures, returning appropriate error responses.",
        "testStrategy": "1.  Create a test PDF file.\n2.  Send a POST request to the `/books/{bookId}/upload-pdf` endpoint with the test PDF file.\n3.  Verify that the API returns a success response with the updated Book model, including the `pdfUrl` and `pdfFileSize` fields.\n4.  Verify that the PDF file is successfully uploaded to cloud storage.\n5.  Verify that the `pdfUrl` field in the Book model contains the correct URL of the uploaded PDF file.\n6.  Verify that the `pdfFileSize` field in the Book model contains the correct size of the uploaded PDF file.\n7.  Test with a file larger than 20MB and verify that the API returns an error response.\n8.  Test with a non-PDF file and verify that the API returns an error response.\n9.  Test error handling for cloud storage upload failures.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "현재 백엔드 구조 분석",
            "description": "backend/ 폴더의 기존 코드를 분석하여 Prisma 스키마와 Book 모델 구조를 파악한다",
            "details": "- backend/prisma/schema.prisma 파일 확인\n- Book 모델의 현재 필드 구조 파악\n- 기존 Book 관련 API 엔드포인트 확인\n- 파일 업로드 관련 기존 구현 확인\n<info added on 2025-07-07T03:14:11.703Z>\n**현재 상황:**\n- 프로젝트는 MongoDB + Mongoose 사용\n- Book 모델은 `backend/src/models/Book.ts`에 정의\n- Book API는 `backend/src/routes/books.ts`에 구현\n- 이미 multer를 사용한 이미지 업로드 기능 존재 (5MB 제한)\n- 업로드 디렉토리: `uploads/` (프로젝트 루트)\n\n**Book 모델 현재 필드:**\n- userId, title, author, bookType, totalPages, currentPage\n- isbn, coverImage, category, status, completionPercentage\n- estimatedRemainingMinutes, avgPpm, readingPurpose, purchaseLink\n- createdAt, updatedAt (timestamps)\n\n**다음 단계:**\n1. Book 모델에 pdfUrl, pdfFileSize 필드 추가\n2. PDF 파일 업로드를 위한 multer 설정 추가\n3. PDF 업로드 API 엔드포인트 구현\n4. PDF 파일 검증 로직 구현\n</info added on 2025-07-07T03:14:11.703Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 1
          },
          {
            "id": 2,
            "title": "Book 모델에 PDF 필드 추가",
            "description": "Book 모델의 인터페이스와 스키마에 pdfUrl과 pdfFileSize 필드를 추가한다",
            "details": "- IBook 인터페이스에 pdfUrl?: string, pdfFileSize?: number 필드 추가\n- BookSchema에 해당 필드들의 Mongoose 스키마 정의 추가\n- 기존 Book 타입과의 호환성 유지\n<info added on 2025-07-07T03:15:28.807Z>\n- pdfUrl은 String 타입, trim 적용, 기본값 null\n- pdfFileSize는 Number 타입, 최소값 0, 기본값 null\n- backend/src/models/Book.ts 파일 수정\n- 기존 필드들에는 영향 없음\n- 새로운 필드들은 옵셔널이므로 기존 데이터와 호환\n</info added on 2025-07-07T03:15:28.807Z>",
            "status": "done",
            "dependencies": [
              1
            ],
            "parentTaskId": 1
          },
          {
            "id": 3,
            "title": "PDF 업로드를 위한 multer 설정 구성",
            "description": "PDF 파일 업로드를 위한 별도의 multer 인스턴스를 생성하고 PDF 파일 검증 로직을 구현한다",
            "details": "- PDF 파일만 허용하는 fileFilter 함수 구현\n- 20MB 파일 크기 제한 설정\n- PDF 전용 업로드 디렉토리 설정 (uploads/pdfs/)\n- MIME 타입 검증 (application/pdf)\n- 파일 확장자 검증 (.pdf)\n<info added on 2025-07-07T03:16:36.856Z>\nPDF 업로드 multer 설정 완료:\n\n**완료된 작업:**\n- PDF 전용 업로드 디렉토리 생성 (uploads/pdfs/)\n- PDF 파일 전용 multer 인스턴스 (uploadPdf) 구성\n- PDF 파일 검증 로직 구현:\n  - MIME 타입 검증: application/pdf만 허용\n  - 파일 확장자 검증: .pdf 확장자만 허용\n  - 파일 크기 제한: 20MB\n- 상세한 로깅 추가로 디버깅 용이성 확보\n- 기존 이미지 업로드 기능과 분리하여 독립적 운영\n\n**변경 사항:**\n- backend/src/routes/books.ts 파일에 PDF 업로드 설정 추가\n- pdfStorage, pdfFileFilter, uploadPdf 인스턴스 생성\n- 에러 메시지 한국어로 사용자 친화적 구성\n</info added on 2025-07-07T03:16:36.856Z>",
            "status": "done",
            "dependencies": [
              2
            ],
            "parentTaskId": 1
          },
          {
            "id": 4,
            "title": "PDF 업로드 API 엔드포인트 구현",
            "description": "책에 PDF 파일을 업로드하는 API 엔드포인트를 구현하고 Book 모델을 업데이트한다",
            "details": "- POST /books/:bookId/upload-pdf 엔드포인트 생성\n- bookController에 uploadPdf 함수 구현\n- 업로드된 PDF 파일 정보를 Book 모델에 저장\n- 파일 URL과 크기 정보 업데이트\n- 에러 핸들링 및 검증 로직 추가\n- 응답 형식 정의\n<info added on 2025-07-07T03:19:34.472Z>\n**완료된 작업:**\n- POST /books/:bookId/upload-pdf 엔드포인트 생성\n- bookController에 uploadPdf 함수 구현\n- 업로드된 PDF 파일 정보를 Book 모델에 저장 (pdfUrl, pdfFileSize)\n- 상세한 에러 핸들링 및 검증 로직:\n  - 사용자 인증 확인\n  - 파일 존재 여부 확인\n  - 책 소유권 확인\n  - 기존 PDF 파일 삭제 (교체 시)\n  - 업로드 실패 시 파일 정리\n- 응답 형식 정의 (성공 메시지, 업데이트된 책 정보, PDF 정보)\n- multer 인스턴스 이름 충돌 해결 (pdfUpload로 변경)\n\n**API 사용법:**\n- POST /books/:bookId/upload-pdf\n- Content-Type: multipart/form-data\n- Field name: pdfFile\n- 최대 파일 크기: 20MB\n- 지원 형식: PDF (.pdf, application/pdf)\n\n**응답 형식:**\n```json\n{\n  \"message\": \"PDF 파일이 성공적으로 업로드되었습니다.\",\n  \"book\": { /* 업데이트된 책 정보 */ },\n  \"pdfInfo\": {\n    \"originalName\": \"document.pdf\",\n    \"url\": \"/uploads/pdfs/pdfFile-1234567890-123456789.pdf\",\n    \"size\": 1234567\n  }\n}\n```\n</info added on 2025-07-07T03:19:34.472Z>",
            "status": "done",
            "dependencies": [
              3
            ],
            "parentTaskId": 1
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement PDF Upload Book Registration UI",
        "description": "Implement the UI for registering books via PDF upload, adding a 'Register via PDF' tab to the existing book registration page. This includes file upload, drag-and-drop functionality, and automatic metadata extraction using pdf.js.",
        "details": "1.  Modify the existing book registration page to include a new tab labeled 'Register via PDF'.\n2.  Implement a file upload component within the 'Register via PDF' tab, allowing users to select PDF files from their local system.\n3.  Implement drag-and-drop functionality for PDF files onto the upload component.\n4.  Integrate pdf.js to extract metadata from the uploaded PDF file, including title, author, and other relevant information.\n5.  Automatically populate the corresponding form fields on the book registration page with the extracted metadata.\n6.  Handle cases where metadata extraction fails or is incomplete, providing users with the option to manually enter the missing information.\n7.  Ensure the UI is responsive and handles large PDF files efficiently, providing appropriate loading indicators.\n8.  Implement client-side validation to ensure that only PDF files are accepted.\n9.  Consider accessibility requirements when designing the UI, ensuring it is usable by people with disabilities.",
        "testStrategy": "1.  Upload a variety of PDF files with different metadata structures.\n2.  Verify that the metadata is correctly extracted and populated into the corresponding form fields.\n3.  Test the drag-and-drop functionality with different PDF files.\n4.  Test the UI with large PDF files to ensure it remains responsive.\n5.  Verify that the client-side validation prevents non-PDF files from being uploaded.\n6.  Manually enter data into the form fields and submit the form to ensure that the data is correctly saved.\n7.  Test the UI on different browsers and devices to ensure compatibility.\n8.  Verify that the UI is accessible to users with disabilities, using assistive technologies such as screen readers.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "PDF.js 라이브러리 설치 및 설정",
            "description": "PDF 메타데이터 추출을 위한 PDF.js 라이브러리를 프론트엔드에 설치하고 설정합니다.",
            "details": "- npm install pdfjs-dist 실행\n- PDF.js worker 설정\n- TypeScript 타입 정의 추가\n- 기본 PDF 파싱 함수 구현\n<info added on 2025-07-07T03:26:31.637Z>\n**구현 내용:**\n1. ✅ pdfjs-dist 라이브러리 설치 완료\n2. ✅ @types/pdfjs-dist TypeScript 타입 정의 설치 완료\n3. ✅ frontend/lib/pdfUtils.ts 파일 생성\n4. ✅ PDF.js worker 설정 구현\n5. ✅ PDF 메타데이터 추출 함수 구현\n6. ✅ PDF 파일 유효성 검사 함수 구현\n7. ✅ 파일 크기 포맷팅 유틸리티 함수 구현\n\n**주요 기능:**\n- extractPdfMetadata(): PDF에서 제목, 저자, 페이지 수 추출\n- validatePdfFile(): PDF 파일 유효성 검사 (타입, 크기, 확장자)\n- formatFileSize(): 파일 크기를 읽기 쉬운 형태로 변환\n- 20MB 파일 크기 제한\n- 에러 핸들링 및 폴백 로직 포함\n\n**TypeScript 타입:**\n- PdfMetadata 인터페이스\n- PdfExtractionResult 인터페이스\n- 완전한 타입 안전성 보장\n</info added on 2025-07-07T03:26:31.637Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 2,
            "title": "PDF 업로드 UI 컴포넌트 생성",
            "description": "드래그앤드롭 기능이 포함된 PDF 업로드 UI 컴포넌트를 생성합니다.",
            "details": "- PdfUploadComponent.tsx 파일 생성\n- 드래그앤드롭 기능 구현\n- PDF 파일 검증 로직\n- 업로드 진행상태 표시\n- 에러 핸들링 UI\n<info added on 2025-07-07T03:28:14.881Z>\n**구현 내용:**\n1. ✅ PdfUploadComponent.tsx 컴포넌트 생성 완료\n2. ✅ 드래그앤드롭 기능 구현\n3. ✅ PDF 파일 검증 로직 구현\n4. ✅ 업로드 진행상태 표시 구현\n5. ✅ 에러 핸들링 UI 구현\n6. ✅ 메타데이터 표시 UI 구현\n\n**주요 기능:**\n- 클릭 또는 드래그앤드롭으로 PDF 파일 업로드\n- 실시간 파일 유효성 검증 (타입, 크기, 확장자)\n- PDF 메타데이터 자동 추출 및 표시\n- 로딩 상태 및 진행률 표시\n- 상세한 에러 메시지 및 경고\n- 업로드된 파일 정보 미리보기\n- 파일 제거 기능\n\n**UI/UX 특징:**\n- Habitus33 사이버펑크 테마 적용\n- 반응형 디자인\n- 접근성 고려 (키보드 네비게이션, 스크린 리더)\n- 직관적인 아이콘 및 상태 표시\n- 부드러운 애니메이션 효과\n\n**기술적 특징:**\n- TypeScript 완전 지원\n- React hooks 활용 (useState, useRef, useCallback)\n- 메모리 누수 방지\n- 에러 경계 처리\n- 컴포넌트 재사용성 고려\n</info added on 2025-07-07T03:28:14.881Z>",
            "status": "done",
            "dependencies": [
              "2.1"
            ],
            "parentTaskId": 2
          },
          {
            "id": 3,
            "title": "PDF 메타데이터 추출 함수 구현",
            "description": "PDF.js를 사용하여 PDF 파일에서 메타데이터(제목, 저자, 페이지 수)를 추출하는 함수를 구현합니다.",
            "details": "- extractPdfMetadata 함수 구현\n- PDF 문서 정보 파싱\n- 제목, 저자, 페이지 수 추출\n- 에러 핸들링 및 폴백 로직\n- TypeScript 타입 정의",
            "status": "done",
            "dependencies": [
              "2.1"
            ],
            "parentTaskId": 2
          },
          {
            "id": 4,
            "title": "기존 책 등록 페이지에 PDF 업로드 기능 통합",
            "description": "기존 /books/new/page.tsx에 PDF 업로드 기능을 통합하고 자동 폼 채우기 기능을 구현합니다.",
            "details": "- 기존 폼에 PDF 업로드 섹션 추가\n- PDF 업로드 시 자동 폼 필드 채우기\n- 수동 입력과 PDF 업로드 방식 병행 지원\n- 반응형 레이아웃 조정\n- 상태 관리 로직 구현\n<info added on 2025-07-07T03:31:31.278Z>\n**구현 내용:**\n1. ✅ 기존 책 등록 페이지에 PDF 업로드 기능 통합 완료\n2. ✅ PDF 업로드 상태 관리 추가 (pdfFile, pdfMetadata, inputMethod)\n3. ✅ PDF 업로드 핸들러 함수 구현 (handlePdfSelected, handlePdfError, clearPdfFile)\n4. ✅ 자동 폼 채우기 기능 구현 (제목, 저자, 페이지 수)\n5. ✅ 수동 입력과 PDF 업로드 방식 병행 지원\n6. ✅ PDF 업로드 UI 섹션 추가 (오른쪽 컬럼)\n7. ✅ 책 등록 후 PDF 업로드 API 연동\n8. ✅ 반응형 레이아웃 조정\n\n**주요 기능:**\n- PDF 파일 업로드 시 메타데이터 자동 추출 및 폼 필드 자동 채우기\n- 수동 입력 모드와 PDF 모드 간 전환 가능\n- PDF 업로드 성공/실패 상태 표시\n- 책 등록 후 자동 PDF 업로드 처리\n- PDF 업로드 실패 시에도 책 등록은 유지 (부분 성공 처리)\n\n**UI/UX 개선:**\n- 직관적인 PDF 업로드 인터페이스\n- 자동 추출된 정보 표시 및 안내\n- 사용자 피드백 메시지 (성공/실패/진행 상태)\n- 기존 디자인과 일관성 유지\n\n**에러 처리:**\n- PDF 업로드 실패 시 적절한 에러 메시지\n- 부분 성공 시나리오 처리 (책 등록 성공, PDF 업로드 실패)\n- 사용자 친화적인 오류 안내\n</info added on 2025-07-07T03:31:31.278Z>",
            "status": "done",
            "dependencies": [
              "2.2",
              "2.3"
            ],
            "parentTaskId": 2
          }
        ]
      },
      {
        "id": 3,
        "title": "Integrate PDF Viewer and Implement Highlighting in TS Reading Session",
        "description": "Integrate a PDF viewer into the TS reading session page using react-pdf and implement a rounded-corner highlighting feature using SVG overlays. This includes text selection, coordinate calculation, and PDF note modal invocation.",
        "details": "1. Integrate the react-pdf library into the TS reading session page.\n2. Implement an SVG overlay to enable rounded-corner highlighting functionality.\n3. Implement text selection functionality within the PDF viewer.\n4. Calculate text coordinates upon selection for highlighting purposes.\n5. Implement a PDF note modal that is invoked upon text selection, allowing users to add notes to highlighted sections.\n6. Ensure the highlighting feature is visually appealing with rounded corners and a subtle color scheme.\n7. Optimize the PDF viewer for performance, ensuring smooth scrolling and rendering even with large PDF documents.\n8. Implement error handling for cases where PDF loading fails or the PDF format is invalid.",
        "testStrategy": "1. Load various PDF documents into the TS reading session page to test the PDF viewer integration.\n2. Select text within the PDF viewer and verify that the rounded-corner highlighting is applied correctly.\n3. Test the text selection functionality with different text sizes and fonts.\n4. Verify that the correct text coordinates are calculated upon selection.\n5. Invoke the PDF note modal and ensure that it displays correctly with the selected text.\n6. Test the performance of the PDF viewer with large PDF documents, ensuring smooth scrolling and rendering.\n7. Simulate PDF loading errors and invalid PDF formats to verify that the error handling is implemented correctly.",
        "status": "done",
        "dependencies": [
          1,
          2
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "react-pdf 라이브러리 설치 및 설정",
            "description": "react-pdf 라이브러리를 설치하고 프로젝트에서 사용할 수 있도록 기본 설정을 구성합니다.",
            "details": "- react-pdf 및 필요한 peer dependencies 설치\\n- PDF 뷰어 기본 컴포넌트 설정\\n- TypeScript 타입 정의 추가\\n- Worker 설정 및 최적화\n<info added on 2025-07-07T03:36:49.893Z>\n**구현 내용:**\n1. ✅ react-pdf 라이브러리 설치 완료\n2. ✅ @types/react-pdf TypeScript 타입 정의 설치 완료\n3. ✅ PdfViewer.tsx 컴포넌트 생성 완료\n4. ✅ PDF.js worker 설정 구현\n5. ✅ 기본 PDF 뷰어 기능 구현\n\n**주요 기능:**\n- 완전한 PDF 문서 렌더링\n- 페이지 네비게이션 (이전/다음 페이지)\n- 줌 인/아웃 기능 (50% ~ 300%)\n- 90도 회전 기능\n- 텍스트 선택 지원 (onTextSelect 콜백)\n- 로딩 상태 및 에러 핸들링\n- 반응형 디자인\n\n**UI/UX 특징:**\n- Habitus33 사이버펑크 테마 적용\n- 직관적인 컨트롤 버튼\n- 실시간 페이지/줌 상태 표시\n- 텍스트 선택 안내 메시지\n- 부드러운 애니메이션 효과\n\n**기술적 특징:**\n- TypeScript 완전 지원\n- React hooks 활용 (useState, useCallback, useRef, useEffect)\n- 텍스트 선택 이벤트 처리\n- 좌표 계산 기능 (하이라이트 준비)\n- 에러 경계 처리\n- 메모리 누수 방지\n</info added on 2025-07-07T03:36:49.893Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          },
          {
            "id": 2,
            "title": "TSReadingPage에 PDF 뷰어 통합",
            "description": "TSReadingPage 컴포넌트에 PDF 뷰어를 통합하여 PDF가 있는 책의 경우 조건부로 렌더링합니다.",
            "details": "- TSReadingPage에서 책의 PDF 파일 존재 여부 확인\\n- PDF가 있는 경우 PdfViewer 컴포넌트 렌더링\\n- PDF 로딩 및 에러 상태 처리\\n- 기존 TS 세션 플로우와의 호환성 유지\n<info added on 2025-07-07T03:39:14.801Z>\n**구현 내용:**\n1. ✅ TSReadingPage에 PDF 뷰어 통합 완료\n2. ✅ SessionData 타입에 PDF 정보 필드 추가 (pdfUrl, pdfFileSize)\n3. ✅ PDF 뷰어 상태 관리 추가 (showPdfViewer, currentPdfPage, pdfError)\n4. ✅ PDF 뷰어 토글 버튼 구현\n5. ✅ 조건부 렌더링 구현 (PDF 있음/없음)\n6. ✅ PDF 텍스트 선택 시 자동 일시정지 기능\n7. ✅ PDF 에러 핸들링 및 사용자 안내\n\n**주요 기능:**\n- PDF가 있는 책: PDF 뷰어 토글 버튼 표시\n- PDF가 없는 책: 기존 호흡 텍스트 유지\n- PDF 뷰어 표시/숨기기 토글 기능\n- 텍스트 선택 시 타이머 자동 일시정지\n- PDF 로딩 에러 시 사용자 친화적 메시지\n\n**UI/UX 특징:**\n- 사이버펑크 테마 일관성 유지\n- 직관적인 PDF 뷰어 토글 버튼\n- 반응형 디자인 (최대 너비 4xl)\n- 부드러운 상태 전환 애니메이션\n\n**기술적 특징:**\n- 기존 TS 세션 플로우와 완전 호환\n- PDF URL 자동 구성 (API URL + 상대 경로)\n- 메모리 효율적인 상태 관리\n- 타입 안전성 보장\n\n**다음 단계 준비:**\n- 텍스트 선택 이벤트 핸들러 준비 완료\n- 메모 모달 연동 준비 (Phase 4)\n- 하이라이트 기능 연동 준비\n</info added on 2025-07-07T03:39:14.801Z>",
            "status": "done",
            "dependencies": [
              "3.1"
            ],
            "parentTaskId": 3
          },
          {
            "id": 3,
            "title": "SVG 오버레이 하이라이트 시스템 구현",
            "description": "PDF 텍스트 위에 SVG 오버레이를 사용하여 둥근 모서리 하이라이트 기능을 구현합니다.",
            "details": "- SVG 오버레이 컴포넌트 생성\\n- 텍스트 좌표를 SVG 좌표로 변환\\n- 둥근 모서리 하이라이트 렌더링\\n- 하이라이트 상태 관리\\n- 여러 하이라이트 지원\n<info added on 2025-07-07T03:44:04.886Z>\n**구현 내용:**\n1. ✅ PDF 하이라이트 타입 정의 완료 (types/pdf.ts)\n2. ✅ 하이라이트 유틸리티 함수 구현 (lib/pdfHighlightUtils.ts)\n3. ✅ SVG 오버레이 하이라이트 컴포넌트 생성 (PdfHighlightOverlay.tsx)\n4. ✅ PdfViewer에 하이라이트 시스템 통합 완료\n5. ✅ 하이라이트 모드 토글 기능 구현\n6. ✅ 둥근 모서리 하이라이트 렌더링 구현\n7. ✅ 다중 하이라이트 지원\n\n**주요 기능:**\n- **하이라이트 생성**: 텍스트 선택 시 자동 하이라이트 생성\n- **둥근 모서리**: SVG rect에 rx/ry 속성으로 세련된 모양\n- **다중 색상 지원**: 6가지 하이라이트 색상 (yellow, green, blue, purple, pink, orange)\n- **인터랙티브**: 클릭, 더블클릭, 우클릭 이벤트 지원\n- **시각적 피드백**: 호버 시 투명도 변경 및 테두리 표시\n- **메모 표시**: 메모가 있는 하이라이트에 작은 원 아이콘\n\n**기술적 특징:**\n- **좌표 변환**: DOM 좌표 → SVG 좌표 정확한 변환\n- **성능 최적화**: MutationObserver로 컨테이너 변경 감지\n- **반응형**: 스케일 변경 시 하이라이트 크기 자동 조정\n- **페이지별 필터링**: 현재 페이지의 하이라이트만 렌더링\n- **메모리 관리**: 컴포넌트 언마운트 시 이벤트 리스너 정리\n\n**UI/UX 특징:**\n- **하이라이트 모드 토글**: 노란색 아이콘으로 직관적 표시\n- **상태별 안내 메시지**: 일반 모드와 하이라이트 모드 구분\n- **부드러운 애니메이션**: 호버 및 상태 전환 효과\n- **접근성**: 키보드 네비게이션 및 툴팁 지원\n\n**다음 단계 준비:**\n- 하이라이트 생성 이벤트 준비 완료\n- 메모 모달 연동 준비 (Phase 4)\n- TSReadingPage 통합 준비\n</info added on 2025-07-07T03:44:04.886Z>",
            "status": "done",
            "dependencies": [
              "3.2"
            ],
            "parentTaskId": 3
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement PDF Note-Taking Modal",
        "description": "Implement a reusable PDF note-taking modal with the same UI/UX as the existing review session memo input form. This modal will be triggered upon highlighting text in the PDF viewer, pausing the timer and pre-filling the modal with the highlighted text.",
        "details": "1.  Create a new, reusable component for the PDF note-taking modal, mirroring the UI/UX of the existing review session memo input form.\n2.  Implement logic to pause the timer when text is highlighted in the PDF viewer.\n3.  Implement logic to invoke the PDF note-taking modal upon text highlighting.\n4.  Automatically populate the modal with the highlighted text.\n5.  Implement functionality to save the note and return to the TS reading session upon saving, resuming the timer.\n6. Ensure the modal is properly integrated with the highlighting functionality implemented in Task 3.",
        "testStrategy": "1.  Highlight text in the PDF viewer and verify that the timer pauses.\n2.  Verify that the PDF note-taking modal is invoked upon text highlighting.\n3.  Ensure that the highlighted text is automatically populated in the modal.\n4.  Save the note and verify that the user is returned to the TS reading session and the timer resumes.\n5.  Test the modal with different lengths of highlighted text.\n6.  Verify that the saved note is correctly associated with the highlighted text.",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "기존 TS 리뷰 메모 UI 분석 및 재사용 컴포넌트 추출",
            "description": "TSReviewPage의 메모 입력 폼을 분석하고 재사용 가능한 컴포넌트로 추출",
            "details": "TSReviewPage.client.tsx의 메모 입력 폼 UI/UX를 분석하여 PDF 메모 작성에 재사용할 수 있도록 별도 컴포넌트로 추출\n<info added on 2025-07-07T03:51:48.988Z>\n✅ 서브태스크 4.1 완료!\n\n**완료 내용:**\n- TSReviewPage의 메모 입력 폼 UI/UX를 분석 완료\n- 동일한 cyberTheme와 스타일을 사용하는 PdfMemoModal 컴포넌트 생성\n- 기존 TS 리뷰 폼과 동일한 필드들 구현:\n  - 메모 성격 선택 (생각/인용/질문)\n  - 메모 텍스트 입력 (하이라이트된 텍스트 자동 입력)\n  - 키워드 입력\n  - 셀프 평가 (별점 1-5)\n- 모달 형태로 구현하여 PDF 뷰어 위에 오버레이\n- 반응형 디자인 및 접근성 고려\n- 에러 핸들링 및 로딩 상태 관리\n- PdfMemoData 타입 정의 및 export 추가\n</info added on 2025-07-07T03:51:48.988Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 2,
            "title": "PDF 메모 모달 컴포넌트 생성",
            "description": "하이라이트된 텍스트를 받아 메모를 작성할 수 있는 모달 컴포넌트 생성",
            "details": "기존 TS 리뷰 메모 UI와 동일한 스타일의 PDF 메모 모달 컴포넌트를 생성하고, 하이라이트된 텍스트를 자동으로 입력하는 기능 구현\n<info added on 2025-07-07T03:52:30.188Z>\nPdfMemoModal 컴포넌트는 서브태스크 4.1에서 이미 완성됨\n- 하이라이트된 텍스트를 자동으로 메모 필드에 입력하는 기능 구현\n- 기존 TS 리뷰 메모와 동일한 UI/UX 스타일 적용\n- 모든 필수 기능 구현:\n  - 메모 성격 선택 (생각/인용/질문)\n  - 메모 텍스트 입력 (하이라이트 텍스트 자동 입력)\n  - 키워드 입력\n  - 중요도 평가 (별점)\n  - 에러 핸들링 및 로딩 상태\n- PdfMemoData 타입 정의 및 export\n- 모달 형태로 구현하여 PDF 뷰어 위에 오버레이\n\n**다음 단계:** TSReadingPage에 모달을 통합하고 하이라이트 이벤트와 연동\n</info added on 2025-07-07T03:52:30.188Z>",
            "status": "done",
            "dependencies": [
              "4.1"
            ],
            "parentTaskId": 4
          },
          {
            "id": 3,
            "title": "TSReadingPage에 PDF 메모 모달 통합",
            "description": "TSReadingPage에 PDF 메모 모달을 통합하고 하이라이트 이벤트와 연동",
            "details": "TSReadingPage에 PDF 메모 모달을 추가하고, 하이라이트 생성 시 타이머 일시정지 및 모달 호출 로직 구현\n<info added on 2025-07-07T03:54:51.529Z>\n- TSReadingPage에 PdfMemoModal 컴포넌트 import 및 통합 완료\n- PDF 메모 모달 상태 관리 추가:\n  - isMemoModalOpen: 모달 열림/닫힘 상태\n  - selectedText: 하이라이트된 텍스트\n  - selectedPageNumber: 현재 페이지 번호\n- 하이라이트 이벤트와 모달 연동 구현:\n  - handlePdfTextSelect에서 타이머 자동 일시정지\n  - 선택된 텍스트와 페이지 정보 저장\n  - 메모 모달 자동 호출\n- 모달 핸들러 구현:\n  - handleMemoModalClose: 모달 닫기 및 타이머 재개\n  - handleMemoSave: 메모 저장 로직 (임시로 localStorage 사용)\n- 메모 저장 후 타이머 자동 재개 구현\n- Phase 5 API 연동을 위한 TODO 주석 추가\n\n**다음 단계:** 타이머 일시정지/재개 로직 최적화\n</info added on 2025-07-07T03:54:51.529Z>",
            "status": "done",
            "dependencies": [
              "4.2"
            ],
            "parentTaskId": 4
          },
          {
            "id": 4,
            "title": "타이머 일시정지/재개 로직 구현",
            "description": "하이라이트 시 타이머 일시정지, 메모 저장 후 타이머 재개 로직 구현",
            "details": "PDF 하이라이트 생성 시 자동으로 타이머를 일시정지하고, 메모 저장 완료 후 타이머를 자동으로 재개하는 로직 구현\n<info added on 2025-07-07T03:55:20.886Z>\n🔍 서브태스크 4.4 분석 시작\n\n**현재 타이머 로직 검토:**\n- 기본 일시정지/재개 기능은 이미 구현됨\n- PDF 하이라이트 시 자동 일시정지 구현됨\n- 메모 저장 후 자동 재개 구현됨\n- 모달 닫기 시 자동 재개 구현됨\n\n**추가 최적화 필요 사항:**\n1. 중복 일시정지 방지 로직\n2. 타이머 상태 표시 개선\n3. 메모 작성 중 타이머 상태 명확화\n4. 에지 케이스 처리 (모달 열림 중 수동 일시정지 등)\n\n**구현 진행:**\n- 현재 로직이 이미 요구사항을 충족하고 있음을 확인\n- 필요한 경우에만 최소한의 개선 적용\n</info added on 2025-07-07T03:55:20.886Z>\n<info added on 2025-07-07T03:56:34.974Z>\n✅ 서브태스크 4.4 완료!\n\n**완료된 타이머 로직 최적화:**\n\n1. **메모 작성 상태 구분**:\n   - `isPausedForMemo` 상태 추가로 메모 작성으로 인한 일시정지와 수동 일시정지 구분\n   - 타이머 상태 텍스트 개선 (몰입하는 중/일시정지됨/메모 작성 중)\n\n2. **중복 방지 로직**:\n   - 메모 모달이 이미 열려있을 때 텍스트 선택 무시\n   - 이미 일시정지된 상태에서 중복 일시정지 방지\n\n3. **수동 컨트롤 제한**:\n   - 메모 작성 중에는 수동 일시정지/재개 버튼 비활성화\n   - 메모 작성 중에는 수동 종료 버튼 비활성화\n   - 버튼 상태에 따른 시각적 피드백 개선\n\n4. **정확한 타이머 재개**:\n   - 메모 저장 완료 시에만 타이머 재개\n   - 모달 닫기 시에도 정확한 타이머 재개\n   - 메모 작성으로 인한 일시정지인 경우에만 자동 재개\n\n**사용자 경험 개선:**\n- 타이머 상태가 명확하게 표시됨\n- 메모 작성 중 실수로 타이머 조작 방지\n- 일관된 타이머 동작 보장\n</info added on 2025-07-07T03:56:34.974Z>",
            "status": "done",
            "dependencies": [
              "4.3"
            ],
            "parentTaskId": 4
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement PDF Memo Saving API",
        "description": "Develop a dedicated API endpoint to save PDF memos generated during TS reading sessions to the database. This API will handle data persistence for PDF notes.",
        "details": "1. Create a new API endpoint `/api/ts-notes` that accepts POST requests.\n2. Implement server-side validation to ensure the request body contains `bookId` (integer), `pageNumber` (integer), `highlightedText` (string), `memoContent` (string), and `memoType` (string).\n3. Create a `Note` model in the database with fields corresponding to the validated request body parameters.\n4. Upon successful validation, create a new record in the `Note` table with the provided data.\n5. Return a success response with the newly created note's ID.\n6. Implement error handling to return appropriate error codes and messages for invalid requests or database errors.\n7. Ensure the API is secured with appropriate authentication and authorization mechanisms.\n8. Optimize database queries for performance, especially when retrieving notes for a specific book and page.",
        "testStrategy": "1. Send a POST request to `/api/ts-notes` with valid data for `bookId`, `pageNumber`, `highlightedText`, `memoContent`, and `memoType`.\n2. Verify that a new record is created in the `Note` table with the provided data.\n3. Verify that the API returns a success response with the newly created note's ID.\n4. Send a POST request with invalid data (e.g., missing fields, incorrect data types) and verify that the API returns an appropriate error response.\n5. Test the API with different combinations of `bookId`, `pageNumber`, `highlightedText`, `memoContent`, and `memoType` to ensure it handles various scenarios correctly.\n6. Test the API's performance by sending multiple concurrent requests and monitoring response times.\n7. Verify that the API is properly secured by attempting to access it without proper authentication and authorization.",
        "status": "done",
        "dependencies": [
          3,
          4
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "기존 Note 모델 및 API 구조 분석",
            "description": "기존 Note 모델의 스키마와 API 엔드포인트를 분석하여 PDF 메모와 호환 가능한 구조 파악",
            "details": "1. Note 모델 스키마 분석 (필드, 타입, 제약조건)\\n2. notes API 엔드포인트 분석 (/notes 라우트)\\n3. PDF 메모를 위한 추가 필드 필요성 검토\\n4. 기존 TS 메모와 PDF 메모 구분 방법 설계\n<info added on 2025-07-07T04:00:32.568Z>\n✅ 기존 Note 모델 및 API 구조 분석 완료\n\n**Note 모델 분석 결과:**\n1. **기존 필드들:**\n   - 필수: userId, bookId, type ('quote'|'thought'|'question'), content\n   - 옵셔널: tags[], originSession, importanceReason, momentContext, relatedKnowledge, mentalImage, relatedLinks[], inlineThreads[]\n   - 시간: createdAt, clientCreatedAt\n\n2. **PDF 메모를 위해 추가 필요한 필드들:**\n   - pageNumber: PDF 페이지 번호 (number)\n   - highlightedText: 하이라이트된 원문 텍스트 (string)\n   - highlightData: 하이라이트 좌표 정보 (object, 옵셔널)\n   - isPdfMemo: PDF 메모 구분 플래그 (boolean, 기본값 false)\n\n3. **기존 API 엔드포인트:**\n   - GET /notes - 전체 노트 목록\n   - POST /notes - 새 노트 생성 (기존 TS 메모용)\n   - GET /notes/book/:bookId - 책별 노트 조회\n   - PUT /notes/:noteId - 노트 수정\n   - DELETE /notes/:noteId - 노트 삭제\n\n4. **PDF 메모 전용 API 설계:**\n   - POST /notes/pdf - PDF 메모 전용 생성 엔드포인트\n   - 기존 createNote와 분리하여 PDF 전용 validation 적용\n   - 기존 API들과 호환성 유지\n\n**다음 단계:** Note 모델에 PDF 관련 필드 추가 준비 완료\n</info added on 2025-07-07T04:00:32.568Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 2,
            "title": "Note 모델에 PDF 관련 필드 추가",
            "description": "PDF 메모를 저장하기 위한 추가 필드를 Note 모델에 추가 (pageNumber, highlightedText, pdfUrl 등)",
            "details": "1. INote 인터페이스에 PDF 관련 필드 추가\\n2. NoteSchema에 새 필드들의 Mongoose 스키마 정의\\n3. 기존 데이터와의 호환성 유지 (옵셔널 필드)\\n4. 인덱스 추가 (성능 최적화)\n<info added on 2025-07-07T04:01:41.967Z>\n✅ Note 모델에 PDF 관련 필드 추가 완료\n\n**추가된 필드들:**\n\n1. **INote 인터페이스 확장:**\n   - `isPdfMemo?: boolean` - PDF 메모 구분 플래그\n   - `pageNumber?: number` - PDF 페이지 번호\n   - `highlightedText?: string` - 하이라이트된 원문 텍스트\n   - `highlightData?: object` - 하이라이트 좌표 정보 (x, y, width, height, pageIndex)\n\n2. **NoteSchema 확장:**\n   - 모든 새 필드를 옵셔널로 설정하여 기존 데이터와 호환성 유지\n   - `isPdfMemo`: Boolean, 기본값 false\n   - `pageNumber`: Number, 최소값 1, 기본값 null\n   - `highlightedText`: String, 최대 2000자 (PDF 텍스트는 더 길 수 있음)\n   - `highlightData`: 중첩 객체로 좌표 정보 저장, 모든 하위 필드 required\n\n3. **성능 최적화 인덱스 추가:**\n   - `{ userId: 1, bookId: 1, isPdfMemo: 1 }` - PDF 메모 필터링용\n   - `{ userId: 1, bookId: 1, pageNumber: 1 }` - 페이지별 메모 조회용\n   - `{ isPdfMemo: 1, pageNumber: 1 }` - PDF 메모 페이지 검색용\n\n**다음 단계:** PDF 메모 저장 API 컨트롤러 함수 구현 준비 완료\n</info added on 2025-07-07T04:01:41.967Z>",
            "status": "done",
            "dependencies": [
              "5.1"
            ],
            "parentTaskId": 5
          },
          {
            "id": 3,
            "title": "PDF 메모 저장 API 엔드포인트 구현",
            "description": "PDF 메모를 저장하는 새로운 API 엔드포인트를 notes 컨트롤러에 구현",
            "details": "1. noteController에 createPdfNote 함수 구현\\n2. 요청 데이터 검증 (bookId, pageNumber, highlightedText, memoData)\\n3. 사용자 인증 및 권한 확인\\n4. PDF 메모 데이터베이스 저장\\n5. 에러 핸들링 및 응답 처리\n<info added on 2025-07-07T04:03:01.065Z>\n✅ PDF 메모 저장 API 엔드포인트 구현 완료\n\n**구현된 createPdfNote 함수 기능:**\n\n1. **인증 및 권한 검증:**\n   - 사용자 인증 상태 확인\n   - 책 소유권 확인 (userId와 bookId 매칭)\n   - PDF 파일 등록 여부 확인 (book.pdfUrl 존재 확인)\n\n2. **요청 데이터 처리:**\n   - bookId, type, content, tags (기본 메모 필드)\n   - pageNumber, highlightedText, highlightData (PDF 전용 필드)\n   - selfRating (별점 평가)\n   - isPdfMemo: true 자동 설정\n\n3. **에러 핸들링:**\n   - MongoDB ValidationError 처리 (필드 유효성 검사 실패)\n   - MongoDB CastError 처리 (잘못된 ObjectId 형식)\n   - 일반적인 서버 에러 처리\n   - 상세한 에러 메시지 제공\n\n4. **개발 환경 로깅:**\n   - PDF 메모 생성 성공 시 상세 정보 로깅\n   - 디버깅 및 모니터링을 위한 메타데이터 포함\n\n5. **Note 모델 업데이트:**\n   - selfRating 필드 추가 (1-5 범위, 옵셔널)\n   - PDF 메모 작성 시 별점 평가 저장 지원\n\n**다음 단계:** notes 라우트에 PDF 메모 엔드포인트 추가 준비 완료\n</info added on 2025-07-07T04:03:01.065Z>",
            "status": "done",
            "dependencies": [
              "5.2"
            ],
            "parentTaskId": 5
          },
          {
            "id": 4,
            "title": "notes 라우트에 PDF 메모 엔드포인트 추가",
            "description": "notes.ts 라우터에 PDF 메모 저장을 위한 새로운 라우트와 validation 추가",
            "details": "1. POST /notes/pdf 라우트 추가\\n2. PDF 메모 전용 validation 미들웨어 구성\\n3. express-validator를 사용한 요청 데이터 검증\\n4. 라우트를 createPdfNote 컨트롤러 함수에 연결\n<info added on 2025-07-07T04:04:06.160Z>\n✅ notes 라우트에 PDF 메모 엔드포인트 추가 완료\n\n**구현된 내용:**\n\n1. **createPdfNote 함수 import 추가:**\n   - noteController에서 createPdfNote 함수를 import\n   - 기존 import 목록에 추가\n\n2. **PDF 메모 전용 validation 미들웨어 구성:**\n   - `createPdfNoteValidation` 배열 생성\n   - 필수 필드 검증: bookId, type, content, pageNumber, highlightedText\n   - 옵셔널 필드 검증: tags, selfRating, highlightData\n   - 상세한 타입 및 범위 검증 (MongoId, 정수, 문자열 길이 등)\n\n3. **POST /notes/pdf 라우트 추가:**\n   - PDF 메모 전용 엔드포인트 생성\n   - validation → validateRequest → createPdfNote 순서로 미들웨어 체인 구성\n   - 기존 POST /notes와 분리하여 PDF 전용 로직 적용\n\n4. **상세한 validation 규칙:**\n   - bookId: MongoDB ObjectId 형식 검증\n   - pageNumber: 1 이상의 정수\n   - highlightedText: 최대 2000자 (PDF 텍스트는 더 길 수 있음)\n   - selfRating: 1-5 범위의 정수\n   - highlightData: 좌표 정보 객체 (x, y, width, height, pageIndex)\n\n**API 엔드포인트 완성:** `POST /api/notes/pdf`로 PDF 메모 저장 가능\n\n**다음 단계:** 프론트엔드 API 연동 구현 준비 완료\n</info added on 2025-07-07T04:04:06.160Z>",
            "status": "done",
            "dependencies": [
              "5.3"
            ],
            "parentTaskId": 5
          },
          {
            "id": 5,
            "title": "프론트엔드 API 연동 구현",
            "description": "PdfMemoModal에서 localStorage 대신 실제 API를 호출하도록 수정하고 에러 핸들링 추가",
            "details": "1. lib/api.ts에 PDF 메모 저장 API 함수 추가\\n2. PdfMemoModal의 handleSave 함수 수정\\n3. API 호출 에러 핸들링 및 사용자 피드백\\n4. 성공/실패 상태 UI 업데이트\\n5. TSReadingPage에서 메모 저장 완료 후 처리 로직\n<info added on 2025-07-07T04:06:58.305Z>\n✅ 프론트엔드 API 연동 구현 완료\n\n**구현된 내용:**\n\n1. **lib/api.ts에 PDF 메모 저장 API 함수 추가:**\n   - `notes.createPdf(pdfNoteData)` 함수 구현\n   - POST /notes/pdf 엔드포인트 호출\n   - 기존 notes API와 일관된 구조 유지\n\n2. **PdfMemoModal 대폭 수정:**\n   - localStorage 제거하고 실제 API 호출로 변경\n   - notes.createPdf API 연동\n   - 상세한 에러 핸들링 (validation 에러, 서버 에러 등)\n   - 로딩 상태 UI 추가 (스피너, 버튼 비활성화)\n   - 사용자 친화적인 에러 메시지 표시\n\n3. **API 요청 데이터 구조:**\n   - bookId, type, content, tags (기본 메모 필드)\n   - pageNumber, highlightedText (PDF 전용 필드)\n   - selfRating (별점 평가)\n   - highlightData (향후 하이라이트 좌표 정보 확장 가능)\n\n4. **에러 핸들링 개선:**\n   - API 응답 에러 메시지 표시\n   - validation 에러 배열 처리\n   - 네트워크 오류 등 일반적인 에러 처리\n   - 사용자에게 명확한 피드백 제공\n\n5. **TSReadingPage 연동 수정:**\n   - handleMemoSave 함수 간소화 (API 호출은 모달에서 처리)\n   - props 인터페이스 변경에 맞게 수정 (selectedText, bookId)\n   - null 체크 추가로 타입 안전성 향상\n\n**API 연동 완료:** PDF 메모가 실제 데이터베이스에 저장되고 백엔드 API와 완전히 연동됨\n\n**Phase 5 완료:** PDF 메모 저장 시스템 전체 구현 완료! 🎉\n</info added on 2025-07-07T04:06:58.305Z>",
            "status": "done",
            "dependencies": [
              "5.4"
            ],
            "parentTaskId": 5
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-07T03:10:48.522Z",
      "updated": "2025-07-07T04:07:15.819Z",
      "description": "PDF 기반 동적 지식 캡처 시스템 구현을 위한 태스크 관리"
    }
  },
  "pdf-scroll-feature": {
    "tasks": [
      {
        "id": 25,
        "title": "Initialize Backend Project",
        "description": "Set up the Node.js and Express backend project with TypeScript, including initial configurations for Prisma and necessary middleware.",
        "details": "1. Initialize a new Node.js project using `npm init -y`.\n2. Install Express, TypeScript, and required typings: `npm install express typescript @types/express @types/node --save-dev`.\n3. Configure TypeScript with `tsc --init` and adjust `tsconfig.json` for desired settings (e.g., `target`: \"es2018\", `module`: \"commonjs\", `outDir`: \"./dist\", `esModuleInterop`: true, `strict`: true).\n4. Install Prisma CLI as a development dependency: `npm install prisma --save-dev`.\n5. Initialize Prisma with `npx prisma init --datasource-provider postgresql`.\n6. Install `cors` for handling Cross-Origin Resource Sharing: `npm install cors`.\n7. Create a basic Express server in `src/index.ts`.\n8. Add scripts to `package.json` for building and running the server (e.g., `\"build\": \"tsc\", \"start\": \"node dist/index.js\", \"dev\": \"nodemon src/index.ts\")`.\n9. Install `nodemon` as a development dependency for automatic server restarts during development: `npm install -D nodemon ts-node` and configure it.",
        "testStrategy": "Verify the server starts without errors and responds to a basic health check endpoint.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Define Database Schema with Prisma",
        "description": "Define the PostgreSQL database schema using Prisma, including the `notes`, `concept_scores`, and `score_calculations` tables.",
        "details": "1.  Modify the `schema.prisma` file to define the `notes`, `concept_scores`, and `score_calculations` tables.\n2.  Include fields like `id`, `concept_score` in the `notes` table. The `concept_scores` table should include fields for `noteId`, `score`, `timestamp`, and individual scores for each of the 6 areas (생각추가, 메모진화, 지식연결, 플래시카드, 태그활용, 사용자평점). The `score_calculations` table should include fields for `version`, `calculation_logic`, and `timestamp`.\n3.  Run `npx prisma migrate dev --name init` to create the initial migration and apply the schema to the PostgreSQL database.\n4.  Use Prisma Client to interact with the database in the application code. Install Prisma Client with `npm install @prisma/client`.",
        "testStrategy": "Inspect the PostgreSQL database to ensure that the tables are created with the correct schema. Verify Prisma Client can connect to the database and perform basic CRUD operations.",
        "priority": "high",
        "dependencies": [
          25
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Implement GET Concept Score API",
        "description": "Implement the GET `/api/notes/:noteId/concept-score` endpoint to retrieve the concept score for a given note.",
        "details": "1.  Create a new route in Express for `/api/notes/:noteId/concept-score`.\n2.  Use Prisma Client to query the `notes` table and retrieve the `concept_score` for the specified `noteId`.\n3.  Return the score as a JSON response.\n4.  Implement error handling to return appropriate HTTP status codes for invalid `noteId` or database errors.",
        "testStrategy": "Use `curl` or Postman to send a GET request to `/api/notes/:noteId/concept-score` with a valid `noteId`. Verify the response contains the correct concept score. Test with an invalid `noteId` and ensure an appropriate error response is returned.",
        "priority": "high",
        "dependencies": [
          26
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Implement POST Update Score API",
        "description": "Implement the POST `/api/notes/:noteId/update-score` endpoint to trigger a score update for a given note.",
        "details": "1.  Create a new route in Express for `/api/notes/:noteId/update-score`.\n2.  This endpoint should receive data necessary for score recalculation (e.g., updates to 생각추가, 메모진화, etc.).\n3.  Call the real-time score calculation engine (implemented in task 29) to update the score.\n4.  Update the `concept_score` field in the `notes` table using Prisma Client.\n5.  Create a new entry in the `concept_scores` table to track the score history.\n6.  Return a success message as a JSON response.",
        "testStrategy": "Use `curl` or Postman to send a POST request to `/api/notes/:noteId/update-score` with relevant data. Verify the `concept_score` in the `notes` table is updated, a new entry is created in the `concept_scores` table, and a success message is returned.",
        "priority": "high",
        "dependencies": [
          26
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Express route for /api/notes/:noteId/update-score",
            "description": "Create a new route in Express for the `/api/notes/:noteId/update-score` endpoint to handle POST requests.",
            "dependencies": [],
            "details": "Define the route handler function to receive the noteId and request body.",
            "status": "done",
            "testStrategy": "Use Postman or curl to send a POST request to the endpoint and verify that the route is accessible."
          },
          {
            "id": 2,
            "title": "Parse and validate request data",
            "description": "Extract and validate the data required for score recalculation from the request body.",
            "dependencies": [],
            "details": "Implement data validation to ensure the required fields (e.g., 생각추가, 메모진화) are present and in the correct format.",
            "status": "done",
            "testStrategy": "Send POST requests with missing or invalid data and verify that appropriate error responses are returned."
          },
          {
            "id": 3,
            "title": "Call real-time score calculation engine",
            "description": "Invoke the real-time score calculation engine (Task 29) with the validated data to update the score.",
            "dependencies": [],
            "details": "Pass the necessary parameters to the score calculation engine and handle any potential errors during the calculation process.",
            "status": "done",
            "testStrategy": "Mock the score calculation engine and verify that it is called with the correct parameters."
          },
          {
            "id": 4,
            "title": "Update notes and concept_scores tables",
            "description": "Update the `concept_score` field in the `notes` table and create a new entry in the `concept_scores` table using Prisma Client.",
            "dependencies": [],
            "details": "Use Prisma Client to perform the database updates. Ensure that the updates are atomic and handle potential database errors.",
            "status": "done",
            "testStrategy": "Verify that the `concept_score` in the `notes` table is updated correctly and a new entry is created in the `concept_scores` table with the correct values."
          },
          {
            "id": 5,
            "title": "Return success message",
            "description": "Return a success message as a JSON response to the client.",
            "dependencies": [],
            "details": "Construct a JSON response indicating the successful update of the concept score.",
            "status": "done",
            "testStrategy": "Verify that the response contains a success message and an appropriate HTTP status code (e.g., 200 OK)."
          }
        ]
      },
      {
        "id": 29,
        "title": "Develop Real-time Score Calculation Engine",
        "description": "Develop the real-time score calculation engine, implementing the scoring algorithms for each of the six areas (생각추가, 메모진화, 지식연결, 플래시카드, 태그활용, 사용자평점).",
        "details": "1.  Create a function that takes relevant data as input (e.g., data related to 생각추가, 메모진화, etc.).\n2.  Implement the scoring logic for each of the six areas based on the provided formulas:\n    *   생각추가: 4단계 완성도 + 텍스트 길이 (max 20)\n    *   메모진화: 4단계 완성 + 진화 속도 (max 20)\n    *   지식연결: 연결 개수 + 다양성 + 품질 (max 20)\n    *   플래시카드: 생성 + 복습 + 난이도 (max 20)\n    *   태그 활용: 개수 + 품질 + 다양성 (max 10)\n    *   사용자 평점: 평점 존재 + 높음 + 업데이트 (max 10)\n3.  Combine the scores from each area to calculate the final concept score.\n4.  Consider using a configuration table (`score_calculations`) to manage different versions of the calculation logic.",
        "testStrategy": "Write unit tests to verify the scoring logic for each of the six areas. Ensure the scores are calculated correctly based on different input values. Test the overall score calculation with various combinations of input data.",
        "priority": "high",
        "dependencies": [
          26
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Data Input Structure",
            "description": "Define the structure and format of the input data required for the score calculation function. This includes specifying the data types and units for each input parameter related to 생각추가, 메모진화, 지식연결, 플래시카드, 태그활용, and 사용자평점.",
            "dependencies": [],
            "details": "Research and document the specific data points needed for each scoring area. For example, for '생각추가', define how '4단계 완성도' and '텍스트 길이' will be represented. Consider using a JSON schema or similar data definition language.",
            "status": "done",
            "testStrategy": "Create sample input data sets that conform to the defined structure. Verify that the data can be parsed and processed correctly by the scoring engine."
          },
          {
            "id": 2,
            "title": "Implement Scoring Logic for Individual Areas",
            "description": "Implement the scoring algorithms for each of the six areas (생각추가, 메모진화, 지식연결, 플래시카드, 태그활용, 사용자평점) based on the provided formulas. Each area should have its own dedicated function or module.",
            "dependencies": [],
            "details": "Translate the formulas into code. For example, for '생각추가', implement the logic to calculate the score based on '4단계 완성도' and '텍스트 길이', ensuring the maximum score is 20. Handle edge cases and invalid input gracefully.",
            "status": "done",
            "testStrategy": "Write unit tests for each scoring area to verify the score is calculated correctly for different input values. Test boundary conditions and edge cases."
          },
          {
            "id": 3,
            "title": "Create Score Combination Function",
            "description": "Develop a function that combines the individual scores from each of the six areas to calculate the final concept score. This function should aggregate the scores and potentially apply weighting factors if needed.",
            "dependencies": [
              "29.2"
            ],
            "details": "Implement the logic to sum the scores from each area. Consider adding the ability to configure weights for each area in the `score_calculations` table. Ensure the final score is within a reasonable range.",
            "status": "done",
            "testStrategy": "Test the score combination function with various combinations of input scores from the individual areas. Verify that the final score is calculated correctly and that the weighting factors are applied as expected."
          },
          {
            "id": 4,
            "title": "Implement Configuration Table Access",
            "description": "Implement the logic to access and utilize the `score_calculations` configuration table. This table should allow for managing different versions of the calculation logic and potentially weighting factors for each area.",
            "dependencies": [],
            "details": "Establish a connection to the database or data source where the `score_calculations` table is stored. Implement functions to retrieve the appropriate configuration based on a version identifier or other criteria. Cache the configuration data for performance.",
            "status": "done",
            "testStrategy": "Create different versions of the `score_calculations` table with varying calculation logic and weighting factors. Verify that the scoring engine uses the correct configuration based on the specified version."
          },
          {
            "id": 5,
            "title": "Integrate and Test Real-time Score Calculation",
            "description": "Integrate all the components of the score calculation engine and test the end-to-end functionality. This includes retrieving data, calculating individual area scores, combining the scores, and utilizing the configuration table.",
            "dependencies": [
              "29.1",
              "29.2",
              "29.3",
              "29.4"
            ],
            "details": "Connect the score calculation engine to the relevant data sources. Implement the API endpoint to trigger the score calculation. Monitor performance and identify any bottlenecks.",
            "status": "done",
            "testStrategy": "Perform end-to-end testing of the score calculation engine with realistic data sets. Verify that the scores are calculated correctly and that the performance is acceptable. Monitor the system for errors and performance issues."
          }
        ]
      },
      {
        "id": 30,
        "title": "Initialize Frontend Project",
        "description": "Set up the React and TypeScript frontend project using Create React App, including Tailwind CSS for styling.",
        "details": "1.  Create a new React project with TypeScript using `npx create-react-app habitus-frontend --template typescript`.\n2.  Install Tailwind CSS and its dependencies: `npm install -D tailwindcss postcss autoprefixer && npx tailwindcss init -p`.\n3.  Configure Tailwind CSS by adding the directives to `./src/index.css` and configuring the `tailwind.config.js` file.\n4.  Install Axios for making HTTP requests: `npm install axios`.",
        "testStrategy": "Verify the React application starts without errors and displays a basic UI. Ensure Tailwind CSS styles are applied correctly.",
        "priority": "high",
        "dependencies": [
          25
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Implement Concept Score Icon",
        "description": "Develop the UI component to display the concept score icon in the upper right corner of the memo card.",
        "details": "1.  Create a new React component for the concept score icon.\n2.  Fetch the concept score from the backend API (`/api/notes/:noteId/concept-score`) using Axios.\n3.  Display the score using one of the specified icons (💡🧠🎯⭐) based on the score range.\n4.  Implement color coding (red -> orange -> green -> blue) based on the score value using Tailwind CSS classes.",
        "testStrategy": "Verify the concept score icon is displayed correctly on the memo card. Ensure the icon and color coding change based on the score value. Test with different `noteId` values.",
        "priority": "high",
        "dependencies": [
          30,
          27
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create React Component for Concept Score Icon",
            "description": "Develop a new React component to display the concept score icon.",
            "dependencies": [],
            "details": "Create a functional React component that will fetch and display the concept score icon. This component will be placed in the upper right corner of the memo card.",
            "status": "done",
            "testStrategy": "Verify the component renders without errors and is positioned correctly on the memo card."
          },
          {
            "id": 2,
            "title": "Fetch Concept Score from API",
            "description": "Implement the logic to fetch the concept score from the backend API.",
            "dependencies": [],
            "details": "Use Axios to make a GET request to `/api/notes/:noteId/concept-score`. Handle potential errors and store the retrieved score in the component's state.",
            "status": "done",
            "testStrategy": "Test with different `noteId` values to ensure the correct score is fetched. Verify error handling for invalid `noteId` values."
          },
          {
            "id": 3,
            "title": "Determine Icon Based on Score Range",
            "description": "Implement the logic to select the appropriate icon based on the concept score range.",
            "dependencies": [],
            "details": "Create a function that takes the concept score as input and returns the corresponding icon (💡🧠🎯⭐) based on predefined score ranges.",
            "status": "done",
            "testStrategy": "Test with various score values to ensure the correct icon is selected for each range."
          },
          {
            "id": 4,
            "title": "Implement Color Coding with Tailwind CSS",
            "description": "Apply color coding to the icon based on the score value using Tailwind CSS classes.",
            "dependencies": [],
            "details": "Create a function that takes the concept score as input and returns the appropriate Tailwind CSS class for the color (red -> orange -> green -> blue). Apply this class to the icon element.",
            "status": "done",
            "testStrategy": "Test with various score values to ensure the correct color is applied to the icon for each range."
          },
          {
            "id": 5,
            "title": "Integrate Component into Memo Card",
            "description": "Integrate the concept score icon component into the memo card UI.",
            "dependencies": [],
            "details": "Import the concept score icon component into the memo card component and render it in the upper right corner. Pass the `noteId` as a prop to the concept score icon component.",
            "status": "done",
            "testStrategy": "Verify the concept score icon is displayed correctly on the memo card with the correct icon and color based on the note's score. Test with different `noteId` values."
          }
        ]
      },
      {
        "id": 32,
        "title": "Implement Detailed Score Popup",
        "description": "Implement the detailed score popup that appears when the concept score icon is clicked, displaying the individual scores for each of the six areas.",
        "details": "1.  Create a new React component for the score popup.\n2.  Fetch the detailed scores for each of the six areas from the backend API or calculate them on the frontend if necessary.\n3.  Display the scores in a clear and organized manner within the popup.\n4.  Use Tailwind CSS to style the popup and ensure it is visually appealing.",
        "testStrategy": "Verify the score popup appears when the concept score icon is clicked. Ensure the individual scores for each area are displayed correctly. Test with different score values and ensure the popup content updates accordingly.",
        "priority": "medium",
        "dependencies": [
          31,
          27,
          29
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create React Component for Score Popup",
            "description": "Develop a new React component to serve as the foundation for the detailed score popup.",
            "dependencies": [],
            "details": "Create a functional or class-based React component. Define the basic structure and styling placeholders. Ensure the component can be rendered and displayed on the screen.",
            "status": "done",
            "testStrategy": "Verify the component renders without errors. Check that the basic structure is in place and that styling placeholders are visible."
          },
          {
            "id": 2,
            "title": "Fetch/Calculate Detailed Scores",
            "description": "Implement the logic to retrieve or calculate the detailed scores for each of the six areas.",
            "dependencies": [],
            "details": "Determine whether to fetch the scores from the backend API (Task 27) or calculate them on the frontend. Implement the necessary API calls or calculation logic. Handle potential errors during data retrieval or calculation.",
            "status": "done",
            "testStrategy": "Check that the correct scores are fetched from the API or calculated accurately. Verify error handling for API failures or invalid data."
          },
          {
            "id": 3,
            "title": "Display Scores in Popup",
            "description": "Organize and display the fetched/calculated scores within the popup component.",
            "dependencies": [],
            "details": "Structure the score data in a clear and understandable format. Use appropriate UI elements (e.g., tables, charts, lists) to display the scores for each area. Ensure the display is responsive and adapts to different screen sizes.",
            "status": "done",
            "testStrategy": "Verify that all six area scores are displayed correctly. Check the formatting and layout for clarity and readability. Test responsiveness on different devices."
          },
          {
            "id": 4,
            "title": "Style Popup with Tailwind CSS",
            "description": "Apply Tailwind CSS classes to style the popup and ensure it is visually appealing and consistent with the application's design.",
            "dependencies": [],
            "details": "Use Tailwind CSS classes to style the popup container, headings, labels, and score values. Ensure the popup has a consistent look and feel with the rest of the UI. Pay attention to typography, spacing, and color palette.",
            "status": "done",
            "testStrategy": "Verify that the popup styling matches the design specifications. Check for consistency with other UI elements. Ensure the popup is visually appealing and easy to read."
          },
          {
            "id": 5,
            "title": "Integrate Popup with Concept Score Icon",
            "description": "Connect the score popup to the concept score icon, so that clicking the icon triggers the popup to appear.",
            "dependencies": [],
            "details": "Implement the event handler for the concept score icon click. Use React state management to control the visibility of the popup. Ensure the popup appears in the correct position relative to the icon.",
            "status": "done",
            "testStrategy": "Verify that the popup appears when the concept score icon is clicked. Check that the popup closes when clicking outside of it or on a close button (if implemented). Ensure the popup position is correct."
          }
        ]
      },
      {
        "id": 33,
        "title": "Implement Quick Action Buttons",
        "description": "Implement the quick action buttons within the score popup, allowing users to take actions related to improving their concept understanding.",
        "details": "1.  Add buttons to the score popup for actions like \"Add Thoughts,\" \"Evolve Memo,\" \"Connect Knowledge,\" \"Create Flashcard,\" \"Add Tag,\" and \"Rate.\"\n2.  Implement the functionality for each button, such as navigating to the appropriate page or triggering an API call.\n3.  Ensure the buttons are styled consistently with the rest of the UI using Tailwind CSS.",
        "testStrategy": "Verify the quick action buttons are displayed correctly in the score popup. Ensure each button performs the correct action when clicked. Test with different user roles and permissions to ensure the buttons are enabled/disabled appropriately.",
        "priority": "medium",
        "dependencies": [
          32,
          28
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Quick Action Buttons to Score Popup UI",
            "description": "Add the specified quick action buttons (Add Thoughts, Evolve Memo, Connect Knowledge, Create Flashcard, Add Tag, Rate) to the score popup React component.",
            "dependencies": [],
            "details": "Modify the React component created in Task 32 to include the quick action buttons. Use Tailwind CSS for styling to ensure consistency with the existing UI.",
            "status": "done",
            "testStrategy": "Verify the quick action buttons are displayed correctly in the score popup and are visually consistent with the rest of the UI."
          },
          {
            "id": 2,
            "title": "Implement 'Add Thoughts' Action",
            "description": "Implement the functionality for the 'Add Thoughts' button. This likely involves navigating the user to a page where they can add thoughts related to the concept.",
            "dependencies": [],
            "details": "Determine the appropriate page or component for adding thoughts. Implement the navigation logic when the 'Add Thoughts' button is clicked.",
            "status": "done",
            "testStrategy": "Click the 'Add Thoughts' button and verify that the user is navigated to the correct page or component for adding thoughts."
          },
          {
            "id": 3,
            "title": "Implement 'Evolve Memo', 'Connect Knowledge', 'Create Flashcard' Actions",
            "description": "Implement the functionality for the 'Evolve Memo', 'Connect Knowledge', and 'Create Flashcard' buttons. These actions may involve navigating to different pages or triggering API calls.",
            "dependencies": [],
            "details": "Determine the appropriate actions for each button. Implement the navigation logic or API calls when the buttons are clicked.",
            "status": "done",
            "testStrategy": "Click each button and verify that the correct action is performed (navigation or API call)."
          },
          {
            "id": 4,
            "title": "Implement 'Add Tag' and 'Rate' Actions",
            "description": "Implement the functionality for the 'Add Tag' and 'Rate' buttons. These actions may involve triggering API calls to update the concept's tags or rating.",
            "dependencies": [],
            "details": "Implement the API calls to update the concept's tags and rating when the buttons are clicked. Handle success and error responses appropriately.",
            "status": "done",
            "testStrategy": "Click each button and verify that the correct API call is made and the concept's tags or rating are updated accordingly."
          },
          {
            "id": 5,
            "title": "Test Quick Action Buttons with Different User Roles",
            "description": "Test the quick action buttons with different user roles and permissions to ensure the buttons are enabled/disabled appropriately.",
            "dependencies": [],
            "details": "Create different user roles with varying permissions. Log in with each role and verify that the quick action buttons are enabled or disabled based on the user's permissions.",
            "status": "done",
            "testStrategy": "Log in with different user roles and verify that the quick action buttons are enabled/disabled as expected based on the user's permissions."
          }
        ]
      },
      {
        "id": 34,
        "title": "Implement Score Calculation Caching",
        "description": "Implement caching for the score calculation to improve performance and reduce the load on the database.",
        "details": "1.  Use a caching library like `node-cache` or Redis to store the calculated concept scores.\n2.  Implement a cache invalidation strategy to ensure the cache is updated when the underlying data changes.\n3.  Consider using a time-to-live (TTL) value for the cache entries to prevent stale data.",
        "testStrategy": "Measure the response time of the GET `/api/notes/:noteId/concept-score` endpoint with and without caching. Verify the response time is significantly faster with caching enabled. Ensure the cache is invalidated correctly when the underlying data changes.",
        "priority": "medium",
        "dependencies": [
          29
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Optimize Real-time Score Updates",
        "description": "Optimize the real-time score updates to minimize the impact on performance and ensure a smooth user experience.",
        "details": "1.  Use techniques like debouncing or throttling to limit the frequency of score updates.\n2.  Consider using a message queue (e.g., RabbitMQ or Kafka) to handle score updates asynchronously.\n3.  Optimize the database queries used in the score calculation engine.",
        "testStrategy": "Simulate a high volume of score updates and measure the impact on performance. Verify the system can handle the load without significant degradation. Ensure the user experience remains smooth and responsive.",
        "priority": "medium",
        "dependencies": [
          28,
          29
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Debouncing/Throttling for Score Updates",
            "description": "Implement debouncing or throttling techniques to limit the frequency of score updates sent to the client, reducing server load and improving UI responsiveness.",
            "dependencies": [],
            "details": "Research and implement either debouncing or throttling. Configure the optimal delay based on testing. Ensure that the final score is always reflected eventually.",
            "status": "done",
            "testStrategy": "Simulate rapid score changes and verify that updates are sent at the configured rate. Measure the impact on server load and UI responsiveness."
          },
          {
            "id": 2,
            "title": "Evaluate and Implement Message Queue for Asynchronous Updates",
            "description": "Evaluate the feasibility of using a message queue (e.g., RabbitMQ or Kafka) to handle score updates asynchronously, decoupling the score calculation engine from the UI and improving scalability.",
            "dependencies": [],
            "details": "Research RabbitMQ and Kafka. Set up a test environment with one of the message queues. Implement a simple producer/consumer to test asynchronous score updates.",
            "status": "done",
            "testStrategy": "Simulate a high volume of score updates and measure the message queue's performance. Verify that all updates are processed correctly and eventually reflected in the UI."
          },
          {
            "id": 3,
            "title": "Optimize Database Queries in Score Calculation Engine",
            "description": "Analyze and optimize the database queries used in the real-time score calculation engine to reduce query execution time and database load.",
            "dependencies": [],
            "details": "Profile the database queries used by the score calculation engine. Identify slow queries and optimize them using techniques like indexing, query rewriting, or caching.",
            "status": "done",
            "testStrategy": "Measure the execution time of the optimized queries and compare them to the original queries. Verify that the optimization reduces database load and improves overall performance."
          },
          {
            "id": 4,
            "title": "Profile and Optimize Score Calculation Logic",
            "description": "Profile the score calculation engine to identify performance bottlenecks within the scoring algorithms themselves and optimize the code for efficiency.",
            "dependencies": [],
            "details": "Use profiling tools to identify the most time-consuming parts of the score calculation logic. Optimize the code by using efficient algorithms, data structures, and coding techniques.",
            "status": "done",
            "testStrategy": "Measure the execution time of the optimized score calculation logic and compare it to the original logic. Verify that the optimization reduces CPU usage and improves overall performance."
          },
          {
            "id": 5,
            "title": "Performance Testing and User Experience Validation",
            "description": "Conduct performance testing to simulate a high volume of score updates and validate that the system can handle the load without significant degradation. Ensure the user experience remains smooth and responsive.",
            "dependencies": [
              "35.1",
              "35.2",
              "35.3",
              "35.4"
            ],
            "details": "Simulate a realistic workload of score updates. Monitor system performance metrics such as CPU usage, memory usage, and response time. Gather user feedback on the smoothness and responsiveness of the UI.",
            "status": "done",
            "testStrategy": "Use load testing tools to simulate a high volume of concurrent users and score updates. Measure the system's throughput, latency, and error rate. Conduct user testing to gather feedback on the user experience."
          }
        ]
      },
      {
        "id": 36,
        "title": "Implement Database Indexing",
        "description": "Implement database indexing to improve the performance of queries related to concept scores.",
        "details": "1.  Identify the columns used in queries related to concept scores (e.g., `noteId` in the `concept_scores` table).\n2.  Create indexes on these columns to speed up query execution.\n3.  Use the `EXPLAIN` command in PostgreSQL to analyze query performance and identify areas for improvement.",
        "testStrategy": "Measure the response time of queries related to concept scores with and without indexing. Verify the response time is significantly faster with indexing enabled. Monitor the database performance to ensure the indexes are being used effectively.",
        "priority": "medium",
        "dependencies": [
          26
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Write Unit Tests for Score Calculation",
        "description": "Write unit tests for the score calculation logic using Jest to ensure the algorithms are accurate and reliable.",
        "details": "1.  Install Jest and its TypeScript typings: `npm install --save-dev jest @types/jest ts-jest`.\n2.  Configure Jest in `jest.config.js`.\n3.  Write unit tests for each of the six scoring areas, covering different input values and edge cases.\n4.  Use Jest's assertion library to verify the scores are calculated correctly.",
        "testStrategy": "Run the Jest unit tests and verify all tests pass. Ensure the tests cover all critical aspects of the score calculation logic.",
        "priority": "high",
        "dependencies": [
          29
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "Write Integration Tests for API Endpoints",
        "description": "Write integration tests for the API endpoints using Jest and Supertest to ensure the endpoints are functioning correctly and interacting with the database as expected.",
        "details": "1.  Install Supertest: `npm install supertest --save-dev`.\n2.  Write integration tests for the GET `/api/notes/:noteId/concept-score` and POST `/api/notes/:noteId/update-score` endpoints.\n3.  Use Supertest to send HTTP requests to the endpoints and verify the responses.\n4.  Ensure the tests cover different scenarios, such as valid and invalid input values, and database errors.",
        "testStrategy": "Run the Jest integration tests and verify all tests pass. Ensure the tests cover all critical aspects of the API endpoints.",
        "priority": "high",
        "dependencies": [
          27,
          28
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "Write E2E Tests for UI Flow",
        "description": "Write end-to-end (E2E) tests for the UI flow using Cypress or Playwright to ensure the user interface is functioning correctly and the user experience is smooth.",
        "details": "1.  Install Cypress or Playwright: `npm install cypress --save-dev` or `npm install playwright --save-dev`.\n2.  Write E2E tests to simulate user interactions with the concept score icon, score popup, and quick action buttons.\n3.  Verify the UI elements are displayed correctly and the user can navigate through the flow without errors.",
        "testStrategy": "Run the Cypress or Playwright E2E tests and verify all tests pass. Ensure the tests cover all critical aspects of the UI flow.",
        "priority": "medium",
        "dependencies": [
          31,
          32,
          33
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-07T08:48:57.524Z",
      "updated": "2025-07-24T21:47:57.985Z",
      "description": "Tasks for pdf-scroll-feature context"
    }
  },
  "seo-optimization": {
    "tasks": [
      {
        "id": 19,
        "title": "Project Setup and Dependency Installation",
        "description": "Initialize the React project with TypeScript, Tailwind CSS, Framer Motion, and Zustand.",
        "details": "Use Create React App with TypeScript template or Vite to scaffold the project. Install necessary dependencies: `npm install react react-dom typescript @types/react @types/react-dom tailwindcss framer-motion zustand`. Configure Tailwind CSS by running `npx tailwindcss init -p` and updating `tailwind.config.js` and `index.css` files. Set up Zustand store for global state management.",
        "testStrategy": "Verify that the project compiles successfully and all dependencies are correctly installed. Run initial tests to ensure basic functionality.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Create TimeBasedMemoView Component and Basic Layout",
        "description": "Create the `TimeBasedMemoView` component and define the basic layout structure.",
        "details": "Create a new component file `TimeBasedMemoView.tsx`. Implement the main container with four sections representing the time zones: Morning, Afternoon, Evening, and Night. Use Tailwind CSS to style the layout. Each section should have a fixed size (300x300px for desktop).",
        "testStrategy": "Check if the layout is rendered correctly with the specified dimensions and time zone labels. Ensure responsiveness for different screen sizes.",
        "priority": "high",
        "dependencies": [
          19
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Implement Quadrant Division Logic",
        "description": "Implement the logic to divide each time zone section into four quadrants for memo point placement.",
        "details": "Within each time zone section, create four `div` elements representing the quadrants. Use CSS Grid or Flexbox to arrange them. Calculate the position of each memo point based on its timestamp and map it to the corresponding quadrant.",
        "testStrategy": "Verify that the quadrants are correctly positioned within each time zone. Test the memo point placement logic with sample data to ensure accurate distribution.",
        "priority": "medium",
        "dependencies": [
          20
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Render Memo Points with Dynamic Styling",
        "description": "Render memo points as circles within the quadrants, with size based on memo length and color based on concept understanding score.",
        "details": "Use `div` elements with rounded corners or SVG circles to represent memo points. Apply inline styles to set the size and color based on the memo's length and understanding score. Use the following color mapping: Red (0-30), Orange (31-60), Yellow (61-80), Green (81-100), Gray (archived).",
        "testStrategy": "Check if the memo points are rendered with the correct size and color based on the data. Verify the color mapping against the specified score ranges.",
        "priority": "high",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement Memo Point Hover Effect",
        "description": "Implement hover effect on memo points to display memo title, creation time, length, and understanding score.",
        "details": "Add an `onMouseEnter` event handler to each memo point. Display a tooltip or a small popup with the memo details. Use Framer Motion for smooth transitions. Consider using a library like Tippy.js for advanced tooltip functionality.",
        "testStrategy": "Test the hover effect on different memo points. Ensure that the correct information is displayed in the tooltip. Verify the tooltip positioning and styling.",
        "priority": "medium",
        "dependencies": [
          22
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Implement Memo Point Click Event and Modal",
        "description": "Implement click event on memo points to open a detailed memo card modal.",
        "details": "Add an `onClick` event handler to each memo point. When clicked, open a modal dialog displaying the full memo content. Use Zustand to manage the modal state. Implement keyboard navigation within the modal.",
        "testStrategy": "Test the click event on different memo points. Ensure that the modal opens with the correct memo content. Verify keyboard navigation within the modal.",
        "priority": "high",
        "dependencies": [
          23
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Implement Time Zone Filter",
        "description": "Implement time zone filter (All/Morning/Afternoon/Evening/Night).",
        "details": "Create a filter component with radio buttons or a select dropdown for time zone selection. Update the memo point rendering based on the selected time zone. Use Zustand to manage the filter state.",
        "testStrategy": "Test the time zone filter with different options. Ensure that only the memos from the selected time zone are displayed.",
        "priority": "medium",
        "dependencies": [
          24
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Implement Day of the Week Filter",
        "description": "Implement day of the week filter (Monday to Sunday checkboxes).",
        "details": "Create a filter component with checkboxes for each day of the week. Update the memo point rendering based on the selected days. Use Zustand to manage the filter state.",
        "testStrategy": "Test the day of the week filter with different combinations of days. Ensure that only the memos from the selected days are displayed.",
        "priority": "medium",
        "dependencies": [
          25
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Implement Date Range Filter",
        "description": "Implement date range selection filter.",
        "details": "Use a date picker library like `react-datepicker` or a custom date range input. Update the memo point rendering based on the selected date range. Use Zustand to manage the filter state.",
        "testStrategy": "Test the date range filter with different date ranges. Ensure that only the memos within the selected date range are displayed.",
        "priority": "medium",
        "dependencies": [
          26
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Apply Debouncing to Filtering",
        "description": "Apply debouncing to the filtering logic to improve performance.",
        "details": "Use a debouncing function (e.g., from Lodash or a custom implementation) to delay the filter application until the user has stopped typing or interacting with the filter controls for a certain period (e.g., 300ms).",
        "testStrategy": "Test the filtering performance with and without debouncing. Verify that the UI remains responsive during filtering.",
        "priority": "medium",
        "dependencies": [
          27
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Implement Memo Point Virtualization",
        "description": "Implement memo point virtualization to render only the visible memo points, improving performance with large datasets.",
        "details": "Use a virtualization library like `react-window` or `react-virtualized` to render only the memo points that are currently visible within the viewport. This significantly reduces the number of DOM elements and improves rendering performance.",
        "testStrategy": "Test the rendering performance with a large number of memo points. Verify that the UI remains smooth and responsive during scrolling and filtering.",
        "priority": "high",
        "dependencies": [
          28
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Apply Memoization to Memo Point Rendering",
        "description": "Apply memoization to the memo point rendering to prevent unnecessary re-renders.",
        "details": "Use `React.memo` to memoize the memo point component. This prevents re-renders if the props haven't changed. Also, use `useMemo` hook to memoize the calculation of memo point styles.",
        "testStrategy": "Use React Profiler to analyze the rendering performance. Verify that the memo point component is not re-rendering unnecessarily.",
        "priority": "medium",
        "dependencies": [
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Implement Responsive Design",
        "description": "Implement responsive design for different screen sizes (desktop, tablet, mobile).",
        "details": "Use Tailwind CSS's responsive modifiers to adjust the layout and styling for different screen sizes. For tablet (2x2 grid), use `md:` prefixes. For mobile (vertical stack), use `sm:` prefixes. Use `react-responsive` library for conditional rendering based on screen size.",
        "testStrategy": "Test the layout on different devices and screen sizes. Verify that the layout adapts correctly and the memo points are displayed appropriately.",
        "priority": "high",
        "dependencies": [
          30
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Implement Keyboard Navigation",
        "description": "Implement keyboard navigation for memo point selection and modal interaction.",
        "details": "Use `tabIndex` to enable keyboard focus on memo points. Implement `onKeyDown` event handlers to handle arrow key navigation. Ensure that the modal is also fully keyboard accessible.",
        "testStrategy": "Test keyboard navigation with different keyboard layouts. Verify that the focus is managed correctly and the user can navigate through the memo points and modal elements.",
        "priority": "medium",
        "dependencies": [
          31
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Implement Accessibility Features",
        "description": "Ensure screen reader compatibility and implement high contrast mode support.",
        "details": "Use semantic HTML elements and ARIA attributes to improve screen reader compatibility. Provide alternative text for images and icons. Implement a high contrast mode using CSS variables and a toggle button.",
        "testStrategy": "Test the application with different screen readers (e.g., NVDA, VoiceOver). Verify that the content is read correctly and the user can navigate through the application. Test the high contrast mode and ensure that the colors are adjusted appropriately.",
        "priority": "low",
        "dependencies": [
          32
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-24T21:49:12.889Z",
      "updated": "2025-07-27T03:22:36.518Z",
      "description": "Tasks for seo-optimization context"
    }
  },
  "memo-time-view": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement TimeBasedMemoView Basic Structure and Time Zone Layout",
        "description": "Create the basic structure of the TimeBasedMemoView component and implement the time zone-based layout. This involves arranging four time zones (Morning, Afternoon, Evening, Midnight) in a clockwise direction and creating a basic UI that divides each time zone into quadrants.",
        "details": "1.  Create a new React component named `TimeBasedMemoView`.\n2.  Implement the basic structure using `div` elements to represent the main container and the four time zones.\n3.  Use CSS to arrange the time zones in a circular (clockwise) layout. Consider using flexbox or grid for layout management.\n4.  Divide each time zone into four quadrants using nested `div` elements.\n5.  Apply basic styling (e.g., borders, background colors) to visually differentiate the time zones and quadrants.\n6.  Ensure the component is responsive and adapts to different screen sizes.\n7.  Add placeholder content or icons to each quadrant to indicate where memos will be displayed.\n8.  Implement a data structure to represent the time zones and their corresponding memos. This structure should be easily adaptable for future memo integration.\n9.  Consider using a library like `styled-components` for managing component styles.\n10. Document the component's structure and usage in the project's documentation.",
        "testStrategy": "1.  Verify that the `TimeBasedMemoView` component renders correctly without any errors.\n2.  Check that the four time zones (Morning, Afternoon, Evening, Midnight) are arranged in a clockwise direction.\n3.  Ensure that each time zone is divided into four quadrants.\n4.  Test the responsiveness of the component by resizing the browser window and verifying that the layout adapts correctly.\n5.  Inspect the CSS to ensure that the correct styles are applied to the time zones and quadrants.\n6.  Verify that the placeholder content or icons are displayed correctly in each quadrant.\n7.  Manually test the component on different devices and browsers to ensure cross-browser compatibility.\n8.  Write unit tests to verify the component's rendering and layout logic.",
        "status": "pending",
        "dependencies": [
          6,
          7
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Memo Dot Rendering Component",
        "description": "Implement a memo dot rendering component with dynamic sizing based on memo length and color coding based on concept understanding score. Add hover functionality to display memo information as a mini card (same as list mode) and navigation to the book details page on click.",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "1. Create a new React component named `MemoDot`. This component will be responsible for rendering a circular dot representing a memo.\n2. Implement logic to determine the size of the dot based on the length of the memo text. Use the following sizes: 6px for short memos, 8px for medium memos, and 12px for long memos. Define thresholds for memo length to categorize them as short, medium, or long.\n3. Implement logic to determine the color of the dot based on the concept understanding score. Use the following colors: red for low scores, orange for medium-low scores, yellow for medium scores, green for medium-high scores, and gray for high scores. Define score ranges for each color.\n4. Add a hover effect to the `MemoDot` component. When the user hovers over the dot, display a mini memo card, mirroring the display from the current list mode.\n5. Implement a click event on the `MemoDot` component. Clicking the dot should navigate the user to the book details page associated with the memo.\n6. Use CSS to style the dot with the appropriate size and color. Ensure that the hover effect is visually appealing and does not obscure other elements on the screen.\n7. Consider using a library like `react-tooltip` or `react-popup` to implement the tooltip/popup functionality for the hover effect.\n8. Ensure the component is performant and handles a large number of memos efficiently.",
        "testStrategy": "1. Verify that the `MemoDot` component renders correctly with different memo lengths and concept understanding scores.\n2. Check that the size of the dot changes dynamically based on the memo length, using the specified sizes (6px, 8px, 12px).\n3. Ensure that the color of the dot changes dynamically based on the concept understanding score, using the specified colors (red, orange, yellow, green, gray).\n4. Test the hover functionality to ensure that a mini memo card (same as list mode) is displayed when the user hovers over the dot.\n5. Verify that the mini memo card is positioned correctly and does not obscure other elements on the screen.\n6. Test the click functionality to ensure that clicking the dot navigates the user to the correct book details page.\n7. Test the component with a large number of memos to ensure that it remains performant and does not cause any performance issues.\n8. Write unit tests to cover all the different scenarios and edge cases.",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Time-Based Filtering with Radio Buttons and Checkboxes",
        "description": "Implement time-based filtering functionality with radio buttons for time zones and checkboxes for days of the week, applying real-time filtering to the memo display.",
        "details": "1.  Add radio buttons for 'All', 'Morning', 'Afternoon', 'Evening', and 'Midnight' time zones.\n2.  Implement checkboxes for each day of the week (Monday to Sunday).\n3.  Use React state to manage the selected time zone and days of the week.\n4.  Implement a filtering function that filters memos based on the selected time zone and days of the week.\n5.  Ensure that the filtering is applied in real-time as the user selects or deselects options.\n6.  Update the TimeBasedMemoView component to display only the filtered memos.\n7.  Consider using a library like Moment.js or date-fns for date and time manipulation.\n8.  Optimize the filtering logic to ensure efficient performance, especially with a large number of memos.",
        "testStrategy": "1.  Verify that the radio buttons and checkboxes are rendered correctly.\n2.  Check that selecting a time zone filters the memos to display only those within the selected time zone.\n3.  Ensure that selecting multiple days of the week filters the memos to display only those on the selected days.\n4.  Test that the filtering is applied in real-time as the user interacts with the controls.\n5.  Verify that the 'All' radio button displays all memos.\n6.  Test with different combinations of time zones and days of the week to ensure accurate filtering.\n7.  Check the performance of the filtering with a large number of memos.\n8.  Ensure that the UI updates correctly when the filter is applied.",
        "status": "pending",
        "dependencies": [
          1,
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Memo Card Details Modal with Edit/Delete Functionality",
        "description": "Update the memo card details modal to navigate to the book details page on click. Modify the mini display mode to only show on hover.",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "details": "1.  Modify the existing React component for the memo card details modal.\n2.  Implement logic to open the book details page when a memo dot is clicked instead of displaying the modal.\n3.  Remove the display of memo details (title, creation time, understanding score, and content) within the modal.\n4.  Remove 'Edit' and 'Delete' buttons from the modal.\n5.  Modify the mini display mode to only show on hover, displaying memo information as a mini card (same as list mode).\n6.  Ensure the modal is styled appropriately for a clear and intuitive user experience.\n7.  Handle edge cases such as missing memo data or failed API requests.",
        "testStrategy": "1.  Verify that clicking a memo dot navigates to the book details page.\n2.  Check that the memo details modal no longer displays memo details (title, creation time, understanding score, content).\n3.  Ensure that the 'Edit' and 'Delete' buttons are removed from the modal.\n4.  Verify that the mini display mode only shows on hover, displaying memo information as a mini card (same as list mode).\n5.  Verify that appropriate error messages are displayed for edge cases such as missing memo data or failed API requests.\n6.  Test the modal's responsiveness on different screen sizes.",
        "subtasks": [
          {
            "id": 1,
            "title": "",
            "description": "Create a new React component for the memo card details modal.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "",
            "description": "Implement logic to open the modal when a memo dot is clicked.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "",
            "description": "Fetch and display the memo title, creation time, understanding score, and content within the modal.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "",
            "description": "Add 'Edit' and 'Delete' buttons to the modal.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "",
            "description": "Implement the 'Edit' functionality to allow users to modify the memo content.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "",
            "description": "Implement the 'Delete' functionality to remove the memo.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "",
            "description": "Ensure the modal is styled appropriately for a clear and intuitive user experience.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "",
            "description": "Handle edge cases such as missing memo data or failed API requests.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "",
            "description": "Modify the existing React component to navigate to the book details page on click.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "",
            "description": "Remove the display of memo details within the modal.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "",
            "description": "Remove 'Edit' and 'Delete' buttons from the modal.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 12,
            "title": "",
            "description": "Modify the mini display mode to only show on hover.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Mini Display Mode Component",
        "description": "Implement a mini display mode component that shows a mini memo card on mouseover, mirroring the list mode's appearance. This component will display memo title, creation time, understanding score, and a content preview.",
        "details": "1. Create a new React component named `MiniMemoDisplay`. This component will be responsible for rendering the mini memo card.\n2. Implement logic to display the memo title, creation time, understanding score, and a content preview within the `MiniMemoDisplay` component.\n3. Ensure the styling of the `MiniMemoDisplay` component matches the appearance of the memo card in list mode.\n4. Implement mouseover functionality to display the `MiniMemoDisplay` component when the user hovers over a memo dot or list item.\n5. Position the `MiniMemoDisplay` component appropriately relative to the hovered element.\n6. Ensure the `MiniMemoDisplay` component disappears when the mouse leaves the hovered element.",
        "testStrategy": "1. Verify that the `MiniMemoDisplay` component renders correctly with all the required information (memo title, creation time, understanding score, content preview).\n2. Check that the styling of the `MiniMemoDisplay` component matches the list mode's memo card appearance.\n3. Ensure that the `MiniMemoDisplay` component appears on mouseover of a memo dot or list item.\n4. Verify that the `MiniMemoDisplay` component is positioned correctly relative to the hovered element.\n5. Check that the `MiniMemoDisplay` component disappears when the mouse leaves the hovered element.\n6. Test with various memo lengths and content to ensure proper display and responsiveness.",
        "status": "pending",
        "dependencies": [
          2,
          4
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Memo Dot Navigation to Book Details Page",
        "description": "Implement navigation from memo details to the book details page by clicking on the memo dot. This will leverage the existing routing system.",
        "details": "1. Modify the `MemoDot` component to include a navigation link to the book details page.\n2. The navigation link should be triggered when the memo dot is clicked.\n3. Extract the book ID from the memo object.\n4. Use the `useNavigate` hook from `react-router-dom` to navigate to the book details page, passing the book ID as a parameter in the URL.\n5. Ensure that the navigation is smooth and does not cause any performance issues.\n6. Update the component to handle cases where the book ID is not available or invalid.",
        "testStrategy": "1. Verify that clicking on a memo dot navigates to the correct book details page.\n2. Check that the correct book ID is passed as a parameter in the URL.\n3. Ensure that the navigation is smooth and does not cause any performance issues.\n4. Test the navigation with different memo objects and book IDs.\n5. Verify that the component handles cases where the book ID is not available or invalid gracefully.",
        "status": "pending",
        "dependencies": [
          4
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Diagram Canvas Feature in 단권화 노트",
        "description": "Implement a diagram canvas feature in the 단권화 노트, featuring a 3-panel layout (memo cards, canvas, markdown editor), intuitive relationship representation, and screenshot saving. The implementation will involve displaying memo cards with sequential numbering and corresponding icons, arranging all icons on the top-left of the canvas panel, allowing users to drag icons onto the canvas and connect them with 5 relationship links, and saving a screenshot of the completed diagram to a fixed location on the 단권화 노트 page.",
        "status": "done",
        "dependencies": [
          2,
          4
        ],
        "priority": "medium",
        "details": "1.  **Layout Implementation:**\n    *   Create a 3-panel layout using a suitable UI framework (e.g., React with a grid system or flexbox). The panels should be resizable.\n    *   Left Panel: Memo cards with sequential numbering and corresponding icons based on the knowledge cart order. \n    *   Center Panel: Diagram canvas for relationship visualization. Use a library like react-flow or similar for interactive diagram creation. Initialize the canvas. All icons should be arranged on the top-left of this panel.\n    *   Right Panel: Markdown editor for detailed notes. Integrate a markdown editor component (e.g., react-markdown or similar).\n2.  **Relationship Representation:**\n    *   Define the 5 relationship types: cause-effect, before-after, base-extension, inclusion, contrast.\n    *   Implement visual cues for each relationship type on the diagram canvas (e.g., different arrow styles, colors, or icons).\n    *   Allow users to create and connect nodes on the canvas by dragging icons, specifying the relationship type for each connection. Users should be able to modify and delete these connections.\n3.  **Memo Card Integration:**\n    *   Assign sequential numbering to memo cards based on their order in the knowledge cart and associate them with corresponding icons.\n4.  **Markdown Editor Integration:**\n    *   Link the markdown editor to the selected node on the canvas. When a node is selected, display its associated markdown content in the editor.\n    *   Implement two-way data binding between the node content and the markdown editor. Changes in the editor should update the node content, and vice versa.\n5.  **Screenshot Saving:**\n    *   Add a button to save the diagram as a screenshot.\n    *   Use a library like html-to-image or dom-to-image to capture the canvas content as an image.\n    *   Save the screenshot to a fixed location on the 단권화 노트 page, outside the markdown editor.\n6.  **Accessibility Considerations:**\n    *   Ensure the diagram canvas is accessible to users with disabilities by providing keyboard navigation and screen reader support.\n    *   Use ARIA attributes to describe the relationships between nodes and the purpose of each element on the canvas.\n7.  **Error Handling:**\n    *   Implement error handling for cases where the diagram cannot be saved or when data cannot be loaded.\n    *   Display informative error messages to the user.\n8.  **Performance Optimization:**\n    *   Optimize the rendering of the diagram canvas to handle large diagrams with many nodes and connections.\n    *   Use virtualization techniques to render only the visible portion of the canvas.\n",
        "testStrategy": "1.  **Layout Verification:**\n    *   Verify that the 3-panel layout is rendered correctly with the memo card panel on the left, the diagram canvas in the center, and the markdown editor on the right.\n    *   Check that the panels are resizable and that the content within each panel is displayed correctly.\n    *   Verify that memo cards in the left panel are sequentially numbered and have corresponding icons.\n    *   Confirm that all icons are arranged on the top-left of the canvas panel.\n2.  **Relationship Representation Verification:**\n    *   Verify that the 5 relationship types are visually represented on the diagram canvas with distinct cues (e.g., different arrow styles, colors, or icons).\n    *   Test the creation and connection of nodes on the canvas by dragging icons, ensuring that the relationship type can be specified for each connection. Verify the ability to modify and delete connections.\n3.  **Memo Card Integration Verification:**\n    *   Verify that memo cards are sequentially numbered based on their order in the knowledge cart and associated with corresponding icons.\n4.  **Markdown Editor Integration Verification:**\n    *   Verify that the markdown editor is linked to the selected node on the canvas and that the content of the node is displayed in the editor.\n    *   Test the two-way data binding between the node content and the markdown editor, ensuring that changes in the editor update the node content, and vice versa.\n5.  **Screenshot Saving Verification:**\n    *   Verify that the diagram can be saved as a screenshot by clicking the save button.\n    *   Check that the screenshot is saved to the specified fixed location on the 단권화 노트 page.\n6.  **Accessibility Testing:**\n    *   Use a screen reader to verify that the diagram canvas is accessible to users with disabilities.\n    *   Check that keyboard navigation is supported and that ARIA attributes are used to describe the relationships between nodes and the purpose of each element on the canvas.\n7.  **Error Handling Testing:**\n    *   Simulate error conditions (e.g., failed save operation, data loading error) and verify that informative error messages are displayed to the user.\n8.  **Performance Testing:**\n    *   Create a large diagram with many nodes and connections and verify that the rendering of the canvas is optimized and that the application remains responsive.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement 3-Panel Layout and Basic Components",
            "description": "Create the 3-panel layout (memo cards, canvas, markdown editor) using React and a suitable UI framework. Implement basic rendering of memo cards with sequential numbering in the left panel. Initialize the diagram canvas in the center panel using a library like react-flow. Integrate a basic markdown editor component in the right panel.",
            "status": "done",
            "dependencies": [],
            "details": "Create a 3-panel layout using a suitable UI framework (e.g., React with a grid system or flexbox). The panels should be resizable. Left Panel: Memo cards with sequential numbering. Fetch memo data and render each memo as a card with its number. Center Panel: Diagram canvas for relationship visualization. Use a library like react-flow or similar for interactive diagram creation. Initialize the canvas. Right Panel: Markdown editor for detailed notes. Integrate a markdown editor component (e.g., react-markdown or similar).",
            "testStrategy": "Verify that the 3-panel layout is rendered correctly with the memo card panel on the left, the diagram canvas in the center, and the markdown editor on the right. Check that the panels are resizable and that the content within each panel is displayed correctly."
          },
          {
            "id": 2,
            "title": "Implement Relationship Representation on Canvas",
            "description": "Define the 5 relationship types (cause-effect, before-after, base-extension, inclusion, contrast) and implement visual cues for each type on the diagram canvas. Allow users to create and connect nodes, specifying the relationship type for each connection.",
            "status": "done",
            "dependencies": [],
            "details": "Define the 5 relationship types: cause-effect, before-after, base-extension, inclusion, contrast. Implement visual cues for each relationship type on the diagram canvas (e.g., different arrow styles, colors, or icons). Allow users to create and connect nodes on the canvas, specifying the relationship type for each connection.",
            "testStrategy": "Verify that the relationship types are correctly represented on the canvas with distinct visual cues. Check that users can create and connect nodes, specifying the relationship type for each connection."
          },
          {
            "id": 3,
            "title": "Implement Memo Card Drag-and-Drop to Canvas",
            "description": "Enable drag-and-drop functionality from the memo card panel to the diagram canvas to create nodes. When a memo card is dragged onto the canvas, create a corresponding node with the memo content.",
            "status": "done",
            "dependencies": [],
            "details": "Enable drag-and-drop functionality from the memo card panel to the diagram canvas to create nodes. When a memo card is dragged onto the canvas, create a corresponding node with the memo content.",
            "testStrategy": "Verify that memo cards can be dragged from the memo card panel to the diagram canvas. Check that a corresponding node is created on the canvas with the memo content when a card is dropped."
          },
          {
            "id": 4,
            "title": "Implement Markdown Editor Integration and Two-Way Data Binding",
            "description": "Link the markdown editor to the selected node on the canvas. When a node is selected, display its associated markdown content in the editor. Implement two-way data binding between the node content and the markdown editor.",
            "status": "done",
            "dependencies": [],
            "details": "Link the markdown editor to the selected node on the canvas. When a node is selected, display its associated markdown content in the editor. Implement two-way data binding between the node content and the markdown editor. Changes in the editor should update the node content, and vice versa.",
            "testStrategy": "Verify that the markdown editor displays the content of the selected node on the canvas. Check that changes in the editor update the node content, and vice versa."
          },
          {
            "id": 5,
            "title": "Implement Screenshot Saving Functionality",
            "description": "Add a button to save the diagram as a screenshot. Use a library like html-to-image or dom-to-image to capture the canvas content as an image. Allow users to download the image as a PNG or JPG file.",
            "status": "done",
            "dependencies": [],
            "details": "Add a button to save the diagram as a screenshot. Use a library like html-to-image or dom-to-image to capture the canvas content as an image. Allow users to download the image as a PNG or JPG file.",
            "testStrategy": "Verify that clicking the save button captures the canvas content as an image. Check that users can download the image as a PNG or JPG file."
          },
          {
            "id": 6,
            "title": "Assign Sequential Numbering and Icons to Memo Cards",
            "description": "Assign sequential numbering to memo cards based on their order in the knowledge cart and associate them with corresponding icons.",
            "status": "done",
            "dependencies": [],
            "details": "Fetch memo data and assign sequential numbers based on the order in the knowledge cart. Associate each number with a corresponding icon. Display the number and icon on the memo card.",
            "testStrategy": "Verify that memo cards are sequentially numbered based on their order in the knowledge cart. Check that each number is associated with a corresponding icon and that both are displayed on the memo card."
          },
          {
            "id": 7,
            "title": "Arrange Icons on Canvas Panel",
            "description": "Arrange all icons on the top-left of the canvas panel.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Position all icons used for relationship representation on the top-left corner of the diagram canvas. Ensure they are visually distinct and easily accessible.",
            "testStrategy": "Verify that all icons are positioned on the top-left corner of the canvas panel. Check that they are visually distinct and easily accessible."
          },
          {
            "id": 8,
            "title": "Implement Drag and Connect Functionality with Relationship Links",
            "description": "Allow users to drag icons onto the canvas and connect them with 5 relationship links. Implement functionality to modify and delete these connections.",
            "status": "done",
            "dependencies": [
              2,
              7
            ],
            "details": "Enable users to drag icons representing memos from the memo card panel or the icon list on the canvas onto the diagram canvas. Allow them to connect these icons using the 5 defined relationship links (cause-effect, before-after, base-extension, inclusion, contrast). Implement functionality to modify the type of relationship and delete existing connections.",
            "testStrategy": "Verify that users can drag icons onto the canvas. Check that they can connect icons using the 5 relationship links. Ensure that they can modify the type of relationship and delete existing connections."
          },
          {
            "id": 9,
            "title": "Save Screenshot to Fixed Location",
            "description": "Save the screenshot of the completed diagram to a fixed location on the 단권화 노트 page, outside the markdown editor.",
            "status": "done",
            "dependencies": [
              5
            ],
            "details": "Modify the screenshot saving functionality to save the captured image to a predefined, fixed location on the 단권화 노트 page. This location should be outside of the markdown editor panel.",
            "testStrategy": "Verify that the screenshot is saved to the correct fixed location on the 단권화 노트 page. Ensure that the saved image is accessible and displays the complete diagram."
          },
          {
            "id": 10,
            "title": "Replace Memo Card Drag with Icon Drag from Canvas Top-Left",
            "description": "Replace the memo card drag-and-drop functionality with the ability to drag memo icons from the top-left of the canvas onto the canvas to create nodes.",
            "status": "done",
            "dependencies": [
              3,
              7
            ],
            "details": "Instead of dragging memo cards, users should drag the sequentially numbered memo icons from the top-left of the canvas panel onto the canvas to create nodes. Remove the existing memo card drag-and-drop functionality.\n<info added on 2025-08-02T07:30:09.735Z>\n현재 구현 상태 확인:\n\n1. 메모카드 자체에는 드래그 기능이 없음 - ✅ 완료\n2. 아이콘 팔레트에서만 드래그 가능 - ✅ 완료  \n3. 순번 표시 - ✅ 완료\n4. 색상 선택 기능 - ✅ 완료\n\n현재 구현이 이미 사용자 요구사항을 만족하고 있습니다:\n- 메모카드들은 단순히 표시만 되고 드래그 기능이 없음\n- 캔버스 상단의 아이콘 팔레트에서만 드래그 가능\n- 각 아이콘에 순번이 표시됨\n- 아이콘 클릭으로 색상 변경 가능\n\n추가 개선사항:\n- 아이콘 팔레트의 UI를 더 명확하게 개선\n- 드래그 시 시각적 피드백 강화\n</info added on 2025-08-02T07:30:09.735Z>",
            "testStrategy": "Verify that users can drag memo icons from the top-left of the canvas onto the canvas to create nodes. Ensure that the original memo card drag-and-drop functionality is removed."
          }
        ]
      },
      {
        "id": 8,
        "title": "Add Diagram Field to Backend SummaryNote Schema",
        "description": "Extend the backend SummaryNote schema to include a diagram field and related subschemas for storing diagram data, enabling the persistence of visual representations within notes.",
        "details": "1.  Define the schema for the diagram field, including subschemas for nodes, edges, and other relevant diagram components. Consider using a JSON-based format for storing the diagram data.\n2.  Integrate the new diagram schema into the existing SummaryNoteSchema.\n3.  Ensure that the diagram field is optional to maintain backward compatibility with existing notes.\n4.  Implement validation logic to ensure that the diagram data conforms to the defined schema.\n5.  Update the data access layer to support saving and retrieving diagram data from the database.\n6.  Consider the performance implications of storing large diagram datasets and implement appropriate optimization strategies.",
        "testStrategy": "1.  Create new SummaryNote objects with diagram data and verify that the data is saved correctly to the database.\n2.  Retrieve SummaryNote objects with diagram data and verify that the data is loaded correctly.\n3.  Update existing SummaryNote objects to include diagram data and verify that the updates are saved correctly.\n4.  Test the validation logic to ensure that invalid diagram data is rejected.\n5.  Measure the performance of saving and retrieving SummaryNote objects with diagram data and identify any performance bottlenecks.\n6.  Verify that the diagram field is optional and that existing notes without diagram data can still be loaded and saved correctly.",
        "status": "done",
        "dependencies": [
          7
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Diagram Update Logic in Backend Controller",
        "description": "Add diagram update logic to the backend controller, including processing the diagram field in the updateSummaryNote function and implementing a diagram data validation function.",
        "details": "1.  Modify the `updateSummaryNote` function in the backend controller to handle the `diagram` field.\n2.  Implement logic to extract the diagram data from the request body.\n3.  Implement a diagram data validation function to ensure that the diagram data conforms to the defined schema (defined in Task 8).\n4.  If the diagram data is valid, update the `diagram` field in the SummaryNote object.\n5.  If the diagram data is invalid, return an error response to the client.\n6.  Ensure that the existing functionality of the `updateSummaryNote` function is not affected by the changes.\n7.  Add logging to track diagram updates and validation results.",
        "testStrategy": "1.  Create a new SummaryNote object with diagram data.\n2.  Update the SummaryNote object with valid diagram data and verify that the data is updated correctly in the database.\n3.  Update the SummaryNote object with invalid diagram data and verify that an error response is returned to the client.\n4.  Verify that the existing functionality of the `updateSummaryNote` function is not affected by the changes.\n5.  Check the logs to ensure that diagram updates and validation results are being tracked correctly.",
        "status": "done",
        "dependencies": [
          8
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Update Frontend Type Definitions for Diagram Field",
        "description": "Update frontend type definitions to include the diagram field and related types in the SummaryNoteData interface, ensuring type safety for diagram data.",
        "details": "1.  Modify the `SummaryNoteData` interface in the frontend to include the `diagram` field.\n2.  Define the type for the `diagram` field based on the backend schema defined in Task 8. This should include types for nodes, edges, and any other relevant diagram components.\n3.  Ensure that the `diagram` field is optional to maintain compatibility with existing notes that may not have diagram data.\n4.  Update any components or services that use the `SummaryNoteData` interface to handle the new `diagram` field.\n5.  Implement type checking and validation to ensure that the diagram data conforms to the defined schema.\n6.  Update the frontend data models to reflect the changes in the backend schema.",
        "testStrategy": "1.  Verify that the `SummaryNoteData` interface includes the `diagram` field with the correct type.\n2.  Create a new SummaryNote object with diagram data in the frontend and verify that it conforms to the updated type definitions.\n3.  Update an existing SummaryNote object with diagram data and verify that the frontend correctly handles the new `diagram` field.\n4.  Test the application with different diagram data scenarios to ensure that the type checking and validation are working correctly.\n5.  Ensure that the frontend components that use the `SummaryNoteData` interface are functioning correctly with the new `diagram` field.",
        "status": "done",
        "dependencies": [
          7,
          8
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Refactor Frontend Diagram Saving Logic",
        "description": "Modify the frontend diagram saving logic to ensure diagram data is transmitted in the correct structure via the saveDiagramAsImage function, while maintaining compatibility with existing code.",
        "details": "1.  Update the `saveDiagramAsImage` function to correctly format the `diagramData` before sending it to the backend.\n2.  Ensure that the diagram data structure matches the backend schema defined in Task 8 and used in Task 9.\n3.  Implement a transformation or mapping function to convert the current diagram data structure to the required format.\n4.  Add versioning or conditional logic to maintain compatibility with older versions of the frontend that may not have the new diagram structure.\n5.  Thoroughly test the updated `saveDiagramAsImage` function with different diagram configurations to ensure correct data transmission.\n6.  Consider adding logging or debugging statements to help identify any issues during data transformation or transmission.\n7.  Review and update any related documentation to reflect the changes in the diagram data structure and saving logic.",
        "testStrategy": "1.  Create various diagrams with different nodes, edges, and relationships.\n2.  Use the `saveDiagramAsImage` function to save each diagram.\n3.  Verify that the data sent to the backend is in the correct format by inspecting the network requests.\n4.  Check that the saved diagrams can be correctly loaded and displayed in the 단권화 노트.\n5.  Test the saving logic with older versions of the frontend to ensure compatibility is maintained.\n6.  Monitor the logs for any errors or warnings during the saving process.\n7.  Implement automated tests to verify the data transformation and transmission logic.",
        "status": "done",
        "dependencies": [
          7,
          10
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Modify Frontend Diagram Loading Logic",
        "description": "Modify the frontend diagram loading logic to correctly restore saved diagramData upon page load, ensuring compatibility with existing data structures.",
        "details": "1.  Update the diagram loading logic to retrieve diagramData from the appropriate storage (e.g., local storage or backend).\n2.  Implement a transformation function to convert the stored diagramData into the format expected by the diagram canvas component.\n3.  Handle cases where diagramData is missing or invalid, providing a default diagram or displaying an error message.\n4.  Ensure that the loading logic is compatible with different versions of diagramData, potentially using versioning or conditional logic.\n5.  Integrate the loading logic into the page load sequence, ensuring that the diagram is loaded as soon as possible after the page is ready.\n6.  Optimize the loading process to minimize performance impact, especially for large diagrams.",
        "testStrategy": "1.  Create diagrams with different nodes, edges, and relationships, and save them using the updated saving logic (Task 11).\n2.  Reload the page and verify that the saved diagrams are correctly restored on the canvas.\n3.  Test with different browsers and devices to ensure cross-browser compatibility.\n4.  Simulate scenarios where diagramData is missing or invalid and verify that the loading logic handles these cases gracefully.\n5.  Measure the loading time for different diagram sizes and optimize the loading process as needed.\n6.  Verify that the restored diagrams are fully interactive and that all features (e.g., node dragging, edge creation) work as expected.",
        "status": "done",
        "dependencies": [
          7,
          11
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Integration Testing and Validation - Diagram Save/Load Functionality",
        "description": "Perform integration testing and validation to ensure the diagram saving/loading functionality works correctly and is compatible with existing features.",
        "status": "done",
        "dependencies": [
          7,
          11,
          12
        ],
        "priority": "medium",
        "details": "1. Create comprehensive test cases covering various scenarios, including different diagram sizes, complexities, and data types.\n2. Verify that diagrams can be saved correctly using the updated saving logic (Task 11).\n3. Verify that saved diagrams can be loaded correctly using the modified loading logic (Task 12).\n4. Check for data integrity during the save and load processes, ensuring no data loss or corruption.\n5. Test compatibility with existing features, such as memo cards and markdown editor, to ensure no conflicts arise.\n6. Perform cross-browser testing to ensure consistent behavior across different browsers.\n7. Conduct performance testing to ensure that the saving and loading operations do not introduce significant delays or performance bottlenecks.\n8. Implement error handling to gracefully handle cases where saving or loading fails, providing informative error messages to the user.\n\nBased on the recent backend and frontend updates, the following validations are now included:\n- Backend schema validation for SummaryNote with diagram field, DiagramNode, and DiagramConnection subschemas.\n- Backend controller validation for updateSummaryNote function with diagram field processing and data validation using validateDiagramData function.\n- Frontend type definition validation for SummaryNoteData interface with diagram field and related types.\n- Frontend saving logic validation with improved saveDiagramAsImage function and data validation.\n- Frontend loading logic validation with improved fetchSummaryNoteDetails function and data filtering.",
        "testStrategy": "1. Create a suite of integration tests that cover the save and load functionality.\n2. Use a testing framework (e.g., Jest, Mocha) to automate the tests.\n3. Assert that the saved diagram data matches the original diagram data after loading.\n4. Verify that the diagram is rendered correctly on the canvas after loading.\n5. Test with different browsers and devices to ensure cross-browser compatibility.\n6. Monitor performance metrics, such as save and load times, to identify potential performance issues.\n7. Simulate error conditions, such as network failures or invalid data, to verify error handling.\n8. Verify the correct handling of the new diagram field in the SummaryNote schema during save and load operations.\n9. Ensure the updated saveDiagramAsImage function correctly formats and transmits diagram data.\n10. Validate the fetchSummaryNoteDetails function correctly loads and processes diagram data, maintaining compatibility with existing data.\n11. Confirm that the backend controller's updateSummaryNote function correctly processes the diagram field and validates diagram data.",
        "subtasks": [
          {
            "id": 1,
            "title": "Backend Schema Validation",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "- SummaryNote schema updated with diagram field\n- DiagramNode, DiagramConnection subschemas defined\n- RelationshipType enum defined\n- Indexes configured",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Backend Controller Validation",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "- updateSummaryNote function updated to handle diagram field\n- validateDiagramData function implemented for data validation\n- Error handling and logging added",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Frontend Type Definition Validation",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "- SummaryNoteData interface updated with diagram field\n- DiagramNode, DiagramConnection, DiagramData types defined\n- Type safety ensured",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Frontend Save Logic Validation",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "- saveDiagramAsImage function improved\n- Data validation and error handling enhanced\n- Data transmitted in a structure matching the backend schema",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Frontend Load Logic Validation",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "- Diagram data loading logic improved in fetchSummaryNoteDetails function\n- Data validation and filtering added\n- Compatibility with existing data ensured",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Execute and validate actual tests",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 14,
        "title": "Create Detailed Specification for Markdown Editor Implementation",
        "description": "Analyze the provided screenshot of an advanced Markdown editor and create a detailed specification for a pure document editor implementation in Habitus33, focusing on core editing features.",
        "details": "1.  Analyze the screenshot to identify key features of the Markdown editor, including:\n    *   Complete block-based system (headings, paragraphs, lists)\n    *   Rich inline formatting (bold, italic, underline, strikethrough)\n    *   Alignment options (left, center, right)\n    *   Undo/redo functionality\n    *   Intuitive toolbar UI\n    *   Placeholder text\n    *   Dark theme support\n2.  Define the scope of the document editor, explicitly excluding AI features and focusing on core document editing capabilities.\n3.  Create a detailed specification document outlining the functional and non-functional requirements for each feature.\n4.  Specify the data structures and algorithms required to implement the block-based system and inline formatting.\n5.  Design the toolbar UI, including the layout, icons, and interactions for each feature.\n6.  Define the implementation approach for undo/redo functionality, considering memory usage and performance.\n7.  Outline the steps required to implement dark theme support, including color palettes and UI adjustments.\n8.  Document any limitations or constraints of the implementation, such as browser compatibility or performance considerations.",
        "testStrategy": "1.  Verify that all specified features are implemented according to the specification document.\n2.  Create a suite of test cases covering various scenarios, including:\n    *   Creating and editing documents with different block types and inline formatting.\n    *   Testing alignment options and undo/redo functionality.\n    *   Verifying the correct behavior of the toolbar UI.\n    *   Testing placeholder text and dark theme support.\n3.  Perform cross-browser testing to ensure compatibility with different browsers and devices.\n4.  Conduct performance testing to ensure that the editor is responsive and efficient, even with large documents.\n5.  Perform usability testing to gather feedback on the intuitiveness and ease of use of the editor.",
        "status": "pending",
        "dependencies": [
          7
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze Screenshot and Existing BlockNote Component",
            "description": "Thoroughly analyze the provided Markdown editor screenshot and the existing BlockNote component in Habitus33 to identify key features, functionalities, and potential areas for extension and integration. Focus on block-based system, inline formatting, toolbar UI, and dark theme support.",
            "dependencies": [],
            "details": "1. Deconstruct the screenshot into individual UI elements and functional components. 2. Evaluate the current BlockNote component's architecture and capabilities. 3. Identify gaps between the desired Markdown editor features and the existing BlockNote component. 4. Plan for component extension or modification.\n<info added on 2025-08-03T05:45:43.990Z>\n기존 BlockNote 컴포넌트 분석 완료:\n\n**현재 구조:**\n- BlockNoteEditor.tsx: 메인 에디터 컴포넌트 (203줄)\n- DynamicBlockNoteEditor.tsx: 동적 로딩 래퍼 (26줄)\n- BlockNoteViewer.tsx: 읽기 전용 뷰어 (47줄)\n- BlockNoteEditor.css: 스타일링 (245줄)\n\n**현재 API:**\n- Props: initialContent, onChange, editable, className\n- useCreateBlockNote({ defaultStyles: true })\n- JSON 기반 콘텐츠 저장\n- 다크 테마 기본 지원\n\n**확장 가능성:**\n- BlockNote는 고급 기능들을 지원하므로 설정만 추가하면 됨\n- 툴바 UI는 별도 컴포넌트로 구현 가능\n- 기존 구조를 최대한 유지하면서 기능 확장 가능\n</info added on 2025-08-03T05:45:43.990Z>",
            "status": "pending",
            "testStrategy": "Verify the accuracy of the feature identification and the feasibility of extending the BlockNote component."
          },
          {
            "id": 2,
            "title": "Design New Toolbar UI Component",
            "description": "Design a new, intuitive toolbar UI component tailored for the Markdown editor. This includes defining the layout, selecting appropriate icons, and specifying the interactions for each feature (e.g., bold, italic, headings, alignment).",
            "dependencies": [],
            "details": "1. Create wireframes and mockups of the toolbar UI. 2. Select appropriate icons for each feature. 3. Define the event handlers and interactions for each toolbar button. 4. Consider responsiveness and accessibility.\n<info added on 2025-08-03T05:47:49.850Z>\n**고급 툴바 UI 컴포넌트 설계 완료:**\n\n**구현된 기능:**\n1. **고급 툴바**: 실행 취소/다시 실행, 블록 타입 선택, 인라인 서식 (굵게, 기울임, 밑줄, 취소선), 목록, 정렬, 서식 지우기\n2. **커스텀 스타일링**: 스크린샷과 유사한 다크 테마 툴바\n3. **반응형 디자인**: 모바일에서도 적절히 작동\n4. **Heroicons 사용**: 일관된 아이콘 시스템\n\n**파일 생성:**\n- AdvancedBlockNoteEditor.tsx: 메인 고급 편집기 컴포넌트\n- AdvancedBlockNoteEditor.css: 고급 스타일링\n- DynamicAdvancedBlockNoteEditor.tsx: 동적 로딩 래퍼\n\n**다음 단계:** BlockNote API 호환성 문제 해결 및 실제 기능 테스트\n</info added on 2025-08-03T05:47:49.850Z>",
            "status": "pending",
            "testStrategy": "Validate the usability and accessibility of the toolbar UI through user testing and accessibility audits."
          },
          {
            "id": 3,
            "title": "Implement Advanced Formatting Features",
            "description": "Implement the core Markdown formatting features, including bold, italic, underline, strikethrough, headings, lists, and alignment options. This involves defining the data structures and algorithms required to represent and manipulate the formatted text.",
            "dependencies": [],
            "details": "1. Define the data structures for representing inline formatting. 2. Implement the algorithms for applying and removing formatting. 3. Integrate the formatting features with the toolbar UI. 4. Implement alignment options (left, center, right).\n<info added on 2025-08-03T05:50:15.869Z>\nBlockNote API 호환성 문제 발견:\n\n**문제점:**\n1. `onUpdate` 메서드가 존재하지 않음\n2. `strikethrough` 스타일이 지원되지 않음\n3. `level` 및 `textAlignment` 속성 접근 오류\n4. `removeStyles()` 메서드 인수 문제\n\n**해결 방안:**\n1. 기본 BlockNote 기능만 사용하여 안정성 확보\n2. 복잡한 API 호출 대신 기본 기능 중심으로 구현\n3. 에러 핸들링 강화\n4. 실제 테스트를 통한 기능 검증 필요\n\n**다음 단계:** 기본 기능만으로 작동하는 버전으로 단순화\n</info added on 2025-08-03T05:50:15.869Z>",
            "status": "pending",
            "testStrategy": "Verify that all formatting features are implemented correctly and that the formatted text is displayed as expected."
          },
          {
            "id": 4,
            "title": "Apply Styling and Theme",
            "description": "Implement the styling and theming for the Markdown editor, including the default light theme and the dark theme. This involves defining color palettes, UI adjustments, and ensuring consistency across all components.",
            "dependencies": [],
            "details": "1. Define the color palettes for the light and dark themes. 2. Apply the styling to all UI components. 3. Implement a mechanism for switching between themes. 4. Ensure that the styling is consistent across all browsers and devices.",
            "status": "pending",
            "testStrategy": "Verify that the styling is applied correctly and that the themes are visually appealing and consistent."
          },
          {
            "id": 5,
            "title": "Implement Undo/Redo Functionality and Placeholder Text",
            "description": "Implement undo/redo functionality for all editing operations, considering memory usage and performance. Also, implement placeholder text to guide users when the editor is empty.",
            "dependencies": [],
            "details": "1. Design the undo/redo stack data structure. 2. Implement the undo and redo operations for each editing action. 3. Optimize the memory usage of the undo/redo stack. 4. Implement placeholder text that appears when the editor is empty.",
            "status": "pending",
            "testStrategy": "Verify that the undo/redo functionality works correctly for all editing operations and that the placeholder text is displayed as expected."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-27T03:22:40.035Z",
      "updated": "2025-08-03T05:45:20.230Z",
      "description": "메모카드 시간대별 보기모드 개발 작업"
    }
  },
  "advanced-editor": {
    "tasks": [
      {
        "id": 1,
        "title": "Analyze Existing BlockNote API and Methods",
        "description": "Analyze existing BlockNote API and methods to understand its capabilities and identify the best approach for implementing the required features, considering current limitations and desired enhancements.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "1.  **Review BlockNote Documentation:** Thoroughly examine the BlockNote v0.33.0 documentation to understand its architecture, available components, and API methods, with a focus on advanced features like `formattingToolbar`, `slashMenu`, `history`, `alignment`, and `customBlocks`.\n2.  **Explore Existing Codebase:** Analyze the current Habitus33 codebase where BlockNote is used to identify existing patterns and best practices, noting the current configurations such as `useCreateBlockNote({ defaultStyles: true })` and supported block types (heading, paragraph, bulletListItem, numberedListItem).\n3.  **Identify Key Methods:** Focus on methods related to block manipulation, text formatting (including inline styles), event handling, and those enabling features like undo/redo and text alignment.\n4.  **Evaluate Customizability:** Assess the extent to which BlockNote can be customized to meet the specific requirements of the advanced markdown editor, particularly in addressing missing features like inline formatting (bold, italic, underline, strikethrough), alignment options, advanced block types (code blocks, quotes, checklists), and custom toolbar configurations.\n5.  **Research BlockNote Plugins:** Investigate available BlockNote plugins or extensions that could simplify the implementation of certain features or provide additional functionality.\n6.  **Document Findings:** Create a document summarizing the findings, including a list of key methods, their usage, potential challenges, and a gap analysis of missing features compared to BlockNote's capabilities.",
        "testStrategy": "Verify that the analysis document covers all relevant aspects of the BlockNote API, identifies potential implementation challenges, and includes a detailed gap analysis of missing features and how they can be addressed using BlockNote's advanced functionalities.",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Design New Editor Component",
        "description": "Design the new editor component using React and TypeScript, leveraging BlockNote for block-based editing and Tailwind CSS for styling. The component includes a toolbar with undo/redo buttons, block type dropdown, inline formatting buttons, list formatting buttons, alignment buttons, and a clear formatting button.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "1. **Create React Component:** Create a new React component named `AdvancedMarkdownEditor` using TypeScript with a toolbar layout matching the provided screenshots.\n2. **Integrate BlockNote:** Integrate BlockNote v0.33.0 into the component to handle block-based editing, utilizing its advanced features.\n3. **Define Block Types:** Define the supported block types (Normal, Heading, Bullet List, Numbered List) using BlockNote's API.\n4. **Implement Styling:** Use Tailwind CSS to style the editor component and ensure it matches the design specifications, including dark theme support, responsive design, and smooth animations.\n5. **Implement Dark Theme Support:** Use Tailwind CSS's dark mode feature to provide a dark theme for the editor.\n6. **Implement Placeholder Text:** Add placeholder text to the editor to guide users when the editor is empty.\n7. **Implement Toolbar Functionality:** Implement undo/redo buttons, block type dropdown, inline formatting buttons (bold, italic, underline, strikethrough), list formatting buttons (bulleted, numbered), alignment buttons (left, center, right), and a clear formatting button.\n8. **Utilize Heroicons:** Use Heroicons for intuitive icons in the toolbar.\n\n```typescript\n// Example of defining a custom block type\nimport { BlockNoteEditor } from \"@blocknote/core\";\n\nconst editor = BlockNoteEditor.create({\n    blockTypes: [\n        {\n            name: \"Heading\",\n            // ...\n        }\n    ]\n});\n```",
        "testStrategy": "Verify that the editor component is created successfully, BlockNote is integrated correctly, and the styling matches the design specifications. Test dark theme functionality, responsive design, and toolbar functionality, including undo/redo, block type selection, inline formatting, list formatting, alignment, and clear formatting. Ensure icons are displayed correctly and animations are smooth.",
        "subtasks": [
          {
            "id": 1,
            "title": "",
            "description": "Create AdvancedMarkdownEditor.tsx with the specified toolbar layout.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "",
            "description": "Create AdvancedMarkdownEditor.css with dark theme support, responsive design, and smooth animations.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "",
            "description": "Replace the existing editor with the new advanced markdown editor component.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement Editor Toolbar UI",
        "description": "Implement the editor toolbar with undo/redo buttons, block type dropdown, inline formatting buttons, list formatting buttons, alignment buttons, and a clear formatting button.",
        "details": "1.  **Create Toolbar Component:** Create a separate React component for the editor toolbar.\n2.  **Add Undo/Redo Buttons:** Implement undo/redo functionality using BlockNote's built-in history management.\n3.  **Implement Block Type Dropdown:** Create a dropdown menu to allow users to select the block type.\n4.  **Implement Inline Formatting Buttons:** Add buttons for bold, italic, underline, and strikethrough formatting using BlockNote's text formatting API.\n5.  **Implement List Formatting Buttons:** Add buttons for bulleted and numbered lists using BlockNote's list API.\n6.  **Implement Alignment Buttons:** Add buttons for left, center, and right alignment using Tailwind CSS classes.\n7.  **Implement Clear Formatting Button:** Add a button to remove all formatting from the selected text.\n8.  **Use Heroicons:** Use Heroicons for the toolbar icons.\n\n```typescript\n// Example of implementing bold formatting\nconst handleBoldClick = () => {\n    editor.commands.toggleBold();\n};\n```",
        "testStrategy": "Verify that all toolbar buttons are functional and that the corresponding formatting is applied correctly. Test undo/redo functionality and icon display.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Add Advanced Formatting Features",
        "description": "Add advanced formatting features such as bold, italic, underline, strikethrough, and alignment to the editor.",
        "details": "1.  **Implement Bold Formatting:** Use BlockNote's `toggleBold` command to toggle bold formatting.\n2.  **Implement Italic Formatting:** Use BlockNote's `toggleItalic` command to toggle italic formatting.\n3.  **Implement Underline Formatting:** Use BlockNote's `toggleUnderline` command to toggle underline formatting.\n4.  **Implement Strikethrough Formatting:** Use BlockNote's `toggleStrikethrough` command to toggle strikethrough formatting.\n5.  **Implement Alignment:** Use Tailwind CSS classes to apply left, center, and right alignment to the selected block.\n\n```typescript\n// Example of implementing underline formatting\nconst handleUnderlineClick = () => {\n    editor.commands.toggleUnderline();\n};\n```",
        "testStrategy": "Verify that all advanced formatting features are working correctly and that the formatting is applied to the selected text.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Replace Existing Editor",
        "description": "Replace the existing editor with the new advanced markdown editor component in the Habitus33 summary note page.",
        "details": "1.  **Identify Existing Editor:** Locate the existing editor component in the Habitus33 codebase.\n2.  **Remove Existing Editor:** Remove the existing editor component from the summary note page.\n3.  **Integrate New Editor:** Integrate the new `AdvancedMarkdownEditor` component into the summary note page.\n4.  **Test Integration:** Test the integration to ensure that the new editor is working correctly and that there are no conflicts with other components.",
        "testStrategy": "Verify that the new editor is integrated correctly and that it is working as expected in the Habitus33 summary note page. Ensure that there are no conflicts with other components.",
        "priority": "high",
        "dependencies": [
          2,
          4
        ],
        "status": "in-progress",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Undo/Redo Functionality",
        "description": "Implement undo/redo functionality using BlockNote's built-in history management.",
        "details": "1.  **Use BlockNote's History API:** Use BlockNote's `history` API to implement undo/redo functionality.\n2.  **Add Keyboard Shortcuts:** Add keyboard shortcuts for undo (Ctrl+Z) and redo (Ctrl+Shift+Z).\n\n```typescript\n// Example of implementing undo functionality\nconst handleUndoClick = () => {\n    editor.history.undo();\n};\n```",
        "testStrategy": "Verify that undo/redo functionality is working correctly and that the keyboard shortcuts are working as expected.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement UI/UX Enhancements",
        "description": "Ensure that the new editor supports dark theme and that the UI is responsive and intuitive.",
        "details": "1.  **Test Dark Theme:** Verify that the editor supports dark theme and that the colors are consistent with the overall design.\n2.  **Test Responsiveness:** Verify that the editor is responsive and that it works correctly on different screen sizes.\n3.  **Test UI/UX:** Verify that the UI is intuitive and that users can easily perform common tasks.\n4.  **Add Animations:** Add subtle animations to improve the user experience.",
        "testStrategy": "Verify that the editor supports dark theme, is responsive, and has an intuitive UI. Ensure that the animations are smooth and do not negatively impact performance.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Test and Optimize",
        "description": "Test the new editor thoroughly and optimize its performance to ensure that it meets the success criteria.",
        "details": "1.  **Functional Testing:** Test all features of the editor to ensure that they are working correctly.\n2.  **Performance Testing:** Test the editor's performance to ensure that it is not causing any performance issues.\n3.  **Compatibility Testing:** Test the editor on different browsers and devices to ensure that it is compatible.\n4.  **Data Compatibility Testing:** Test that existing data is compatible with the new editor.\n5.  **Optimize Performance:** Optimize the editor's performance by reducing the number of DOM updates and using efficient algorithms.",
        "testStrategy": "Verify that the editor meets the success criteria by performing functional, performance, and compatibility testing. Ensure that existing data is compatible with the new editor and that there are no performance issues.",
        "priority": "high",
        "dependencies": [
          5,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Advanced WYSIWYG Markdown Editor",
        "description": "Implement an advanced, fully WYSIWYG markdown editor, replacing the existing block-based editor while maintaining API compatibility. This includes advanced inline formatting, alignment features, undo/redo functionality, and placeholder text support.",
        "details": "1.  **Replace Existing Editor Component:** Remove the current markdown editor component and integrate the new WYSIWYG editor.\n2.  **Implement Advanced Inline Formatting:** Integrate features for bold, italic, underline, strikethrough, and other advanced formatting options.\n3.  **Implement Alignment Functionality:** Add support for text alignment (left, center, right, justify) using appropriate styling or editor commands.\n4.  **Integrate Undo/Redo Functionality:** Utilize the editor's built-in history management or implement a custom solution for undo/redo operations.\n5.  **Add Placeholder Text Support:** Implement placeholder text that appears when the editor is empty, providing guidance to the user.\n6.  **Maintain API Compatibility:** Ensure that the new editor's API is compatible with the existing API to minimize disruption to other components.\n7.  **Implement Data Conversion:** Implement a mechanism to convert existing markdown data to the format expected by the new editor.\n8.  **Address dark theme and responsiveness:** Ensure the new editor is compatible with the existing dark theme and is responsive on different screen sizes.",
        "testStrategy": "1.  **Verify Core Formatting Features:** Test bold, italic, underline, strikethrough, and other formatting options to ensure they function correctly.\n2.  **Verify Alignment Functionality:** Test text alignment options (left, center, right, justify) to ensure they are applied correctly.\n3.  **Test Undo/Redo Functionality:** Verify that undo/redo operations work as expected for all editing actions.\n4.  **Verify Placeholder Text:** Ensure that placeholder text is displayed correctly when the editor is empty and disappears when text is entered.\n5.  **Verify API Compatibility:** Test the new editor's API to ensure that it is compatible with the existing API and that no functionality is broken.\n6.  **Verify Data Conversion:** Test that existing markdown data is converted correctly to the new editor's format.\n7.  **Verify Dark Theme and Responsiveness:** Ensure the new editor is compatible with the existing dark theme and is responsive on different screen sizes.\n8.  **Test for performance regressions:** Ensure that the new editor does not introduce any performance regressions.",
        "status": "pending",
        "dependencies": [
          4,
          5,
          6,
          7
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Evaluate and Select WYSIWYG Editor Framework",
            "description": "Research and evaluate different WYSIWYG editor frameworks (e.g., Draft.js, Quill, ProseMirror, TipTap) based on features, API compatibility with BlockNote, customizability, and community support. Select the most suitable framework for integration.",
            "dependencies": [],
            "details": "1. Identify key requirements for the editor framework, including markdown support, extensibility, and API compatibility. 2. Create a comparison matrix of potential frameworks. 3. Conduct proof-of-concept implementations with top contenders. 4. Document the selection process and rationale.",
            "status": "pending",
            "testStrategy": "Verify that the selected framework meets all the specified requirements and integrates smoothly with the existing BlockNote environment."
          },
          {
            "id": 2,
            "title": "Implement Core Editor Integration and Data Conversion",
            "description": "Integrate the selected WYSIWYG editor framework into the existing application, replacing the current block-based editor. Implement data conversion mechanisms to handle existing markdown data and ensure seamless transition.",
            "dependencies": [],
            "details": "1. Remove the existing markdown editor component. 2. Integrate the new WYSIWYG editor component. 3. Implement a data conversion function to transform existing markdown data into the format expected by the new editor. 4. Ensure that the editor's API is compatible with the existing API to minimize disruption to other components.",
            "status": "pending",
            "testStrategy": "Verify that the new editor is successfully integrated and that existing markdown data is correctly converted and displayed. Ensure API compatibility with other components."
          },
          {
            "id": 3,
            "title": "Implement Advanced Formatting and Alignment Features",
            "description": "Implement advanced inline formatting options (bold, italic, underline, strikethrough, etc.) and text alignment functionality (left, center, right, justify) within the WYSIWYG editor.",
            "dependencies": [],
            "details": "1. Utilize the editor framework's API to implement inline formatting options. 2. Add UI elements (toolbar buttons, context menus) for formatting options. 3. Implement text alignment functionality using appropriate styling or editor commands. 4. Ensure that formatting and alignment options are applied correctly and consistently.",
            "status": "pending",
            "testStrategy": "Verify that all formatting and alignment options are functional and that the corresponding styles are applied correctly. Test with various text inputs and scenarios."
          },
          {
            "id": 4,
            "title": "Integrate Undo/Redo Functionality and Placeholder Text Support",
            "description": "Integrate undo/redo functionality using the editor's built-in history management or a custom solution. Implement placeholder text that appears when the editor is empty, providing guidance to the user.",
            "dependencies": [],
            "details": "1. Utilize the editor's built-in history management or implement a custom solution for undo/redo operations. 2. Add keyboard shortcuts for undo (Ctrl+Z) and redo (Ctrl+Shift+Z). 3. Implement placeholder text that appears when the editor is empty. 4. Ensure that undo/redo functionality works correctly and that the placeholder text is displayed appropriately.",
            "status": "pending",
            "testStrategy": "Verify that undo/redo functionality is working correctly and that the keyboard shortcuts are working as expected. Verify that the placeholder text is displayed correctly when the editor is empty."
          },
          {
            "id": 5,
            "title": "Address Dark Theme and Responsiveness",
            "description": "Ensure that the new editor is compatible with the existing dark theme and is responsive on different screen sizes.",
            "dependencies": [],
            "details": "1. Test the editor in dark theme to ensure that the colors are consistent with the overall design. 2. Verify that the editor is responsive and that it works correctly on different screen sizes. 3. Adjust the editor's styling and layout as needed to ensure compatibility with dark theme and responsiveness.",
            "status": "pending",
            "testStrategy": "Verify that the editor supports dark theme and is responsive on different screen sizes. Test with various screen resolutions and devices."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-03T05:51:19.974Z",
      "updated": "2025-08-03T06:04:47.429Z",
      "description": "Tasks for advanced-editor context"
    }
  },
  "rich-text-editor": {
    "tasks": [
      {
        "id": 31,
        "title": "Initialize Node.js Backend with Express",
        "description": "Initialize the Node.js backend project with Express.js and necessary dependencies.",
        "details": "Use `npm init -y` to create a `package.json` file. Install Express.js (`npm install express`), MongoDB driver (`npm install mongodb`), dotenv (`npm install dotenv`), and any other middleware (e.g., cors). Create a basic `app.js` or `index.js` file to set up the Express server.",
        "testStrategy": "Run the server and check if it starts without errors. Create a simple endpoint to verify basic functionality.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize npm project",
            "description": "Run `npm init -y` to create a `package.json` file.",
            "dependencies": [],
            "details": "Navigate to the project directory in the terminal and execute the command `npm init -y`. This will create a `package.json` file with default settings.",
            "status": "done",
            "testStrategy": "Verify that a `package.json` file is created in the project directory."
          },
          {
            "id": 2,
            "title": "Install Express.js",
            "description": "Install Express.js as a project dependency using npm.",
            "dependencies": [],
            "details": "Run `npm install express` to install the Express.js framework. This will add Express.js to the project's `node_modules` directory and update the `package.json` file with the dependency.",
            "status": "done",
            "testStrategy": "Check that Express.js is listed as a dependency in the `package.json` file."
          },
          {
            "id": 3,
            "title": "Install MongoDB driver and dotenv",
            "description": "Install the MongoDB driver and dotenv package using npm.",
            "dependencies": [],
            "details": "Run `npm install mongodb dotenv` to install the MongoDB driver and dotenv package. These packages are required for connecting to the MongoDB database and managing environment variables.",
            "status": "done",
            "testStrategy": "Verify that both mongodb and dotenv are listed as dependencies in the `package.json` file."
          },
          {
            "id": 4,
            "title": "Install CORS middleware",
            "description": "Install the CORS middleware to handle Cross-Origin Resource Sharing.",
            "dependencies": [],
            "details": "Run `npm install cors` to install the CORS middleware. This middleware is necessary to allow requests from different origins (e.g., a frontend running on a different port).",
            "status": "done",
            "testStrategy": "Check that CORS is listed as a dependency in the `package.json` file."
          },
          {
            "id": 5,
            "title": "Create and configure app.js",
            "description": "Create an `app.js` file and set up a basic Express server.",
            "dependencies": [],
            "details": "Create a file named `app.js` (or `index.js`). Import Express, initialize the app, define a basic route (e.g., `/`), and start the server listening on a specific port (e.g., 3000).",
            "status": "done",
            "testStrategy": "Run the server using `node app.js` and check if it starts without errors. Access the defined route in a browser or using a tool like curl and verify that it returns the expected response."
          }
        ]
      },
      {
        "id": 32,
        "title": "Configure MongoDB Atlas Connection",
        "description": "Configure MongoDB Atlas connection and set up the database connection.",
        "details": "Install the MongoDB Node.js driver (`npm install mongodb`). Use environment variables (using `dotenv`) to store the MongoDB Atlas connection string. Create a module to handle the database connection and export it for use in other parts of the application. Consider using Mongoose (install via `npm install mongoose`) for schema management if the data structure is complex.",
        "testStrategy": "Write a script to connect to the MongoDB Atlas database and verify the connection. Perform a simple query to ensure data can be retrieved.",
        "priority": "high",
        "dependencies": [
          31
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install MongoDB Driver and Mongoose",
            "description": "Install the MongoDB Node.js driver and Mongoose using npm.",
            "dependencies": [],
            "details": "Run `npm install mongodb mongoose` to install the necessary packages.",
            "status": "done",
            "testStrategy": "Verify that the packages are installed correctly by checking the `node_modules` directory and package.json."
          },
          {
            "id": 2,
            "title": "Set up Environment Variables for MongoDB Atlas Connection String",
            "description": "Configure environment variables to store the MongoDB Atlas connection string using the `dotenv` package.",
            "dependencies": [],
            "details": "Install `dotenv` (`npm install dotenv`). Create a `.env` file and store the connection string as `MONGODB_URI=your_mongodb_atlas_connection_string`. Load the environment variables in the application.",
            "status": "done",
            "testStrategy": "Create a test script to read the MONGODB_URI environment variable and verify its value."
          },
          {
            "id": 3,
            "title": "Create Database Connection Module",
            "description": "Create a module to handle the database connection and export it for use in other parts of the application.",
            "dependencies": [],
            "details": "Create a file (e.g., `db.js`) to establish the MongoDB connection using the connection string from the environment variables. Export the connection object.",
            "status": "done",
            "testStrategy": "Attempt to connect to the database using the module and verify that the connection is successful."
          },
          {
            "id": 4,
            "title": "Define Mongoose Schema (If Applicable)",
            "description": "Define Mongoose schema for data models if the data structure is complex.",
            "dependencies": [],
            "details": "Create Mongoose schemas for the data models, defining the structure and data types of the documents in the MongoDB collections.",
            "status": "done",
            "testStrategy": "Create a test script to define a sample schema and verify that it is correctly defined."
          },
          {
            "id": 5,
            "title": "Test MongoDB Atlas Connection",
            "description": "Write a script to connect to the MongoDB Atlas database and verify the connection. Perform a simple query to ensure data can be retrieved.",
            "dependencies": [],
            "details": "Use the database connection module to connect to the MongoDB Atlas database. Execute a simple query (e.g., `db.collection('collection_name').findOne({})`) to retrieve data.",
            "status": "done",
            "testStrategy": "Verify that the connection is established successfully and that data can be retrieved from the database."
          }
        ]
      },
      {
        "id": 33,
        "title": "Implement JWT Authentication",
        "description": "Implement JWT authentication middleware for securing API endpoints.",
        "details": "Install `jsonwebtoken` (`npm install jsonwebtoken`) and `bcrypt` (`npm install bcrypt`) for JWT and password hashing. Create middleware functions for user registration, login, and JWT verification. Store the JWT secret key in an environment variable. Ensure proper error handling and response codes.",
        "testStrategy": "Create test users and attempt to register and log in. Verify that JWT tokens are correctly generated and that protected endpoints require a valid token.",
        "priority": "high",
        "dependencies": [
          32
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "User Registration Middleware",
            "description": "Create middleware for user registration, including password hashing using bcrypt.",
            "dependencies": [],
            "details": "Implement a registration endpoint that receives user credentials, hashes the password using bcrypt, and stores the user in the database. Handle potential errors like duplicate usernames.",
            "status": "done",
            "testStrategy": "Create test users and attempt to register them. Verify that the user is created in the database with a hashed password."
          },
          {
            "id": 2,
            "title": "User Login Middleware",
            "description": "Create middleware for user login, including password verification and JWT generation.",
            "dependencies": [],
            "details": "Implement a login endpoint that receives user credentials, verifies the password against the hashed password in the database, and generates a JWT upon successful authentication.",
            "status": "done",
            "testStrategy": "Create test users and attempt to log in with valid and invalid credentials. Verify that a JWT is generated upon successful login and that login fails with invalid credentials."
          },
          {
            "id": 3,
            "title": "JWT Verification Middleware",
            "description": "Create middleware to verify JWT tokens and protect API endpoints.",
            "dependencies": [],
            "details": "Implement middleware that extracts the JWT from the request header, verifies its signature, and attaches the user information to the request object if the token is valid. Return appropriate error codes if the token is invalid or missing.",
            "status": "done",
            "testStrategy": "Attempt to access protected endpoints with and without a valid JWT. Verify that access is granted only with a valid JWT and that appropriate error codes are returned otherwise."
          },
          {
            "id": 4,
            "title": "Environment Variable Configuration",
            "description": "Configure the JWT secret key as an environment variable.",
            "dependencies": [],
            "details": "Store the JWT secret key in an environment variable (e.g., JWT_SECRET). Ensure that the application reads the secret key from the environment variable during startup.",
            "status": "done",
            "testStrategy": "Verify that the application can read the JWT secret key from the environment variable and that the JWT tokens are generated using this secret key."
          },
          {
            "id": 5,
            "title": "Error Handling and Response Codes",
            "description": "Implement proper error handling and response codes for all authentication-related operations.",
            "dependencies": [],
            "details": "Implement error handling for all authentication-related operations, including registration, login, and JWT verification. Return appropriate HTTP status codes (e.g., 400, 401, 403, 500) and error messages to the client.",
            "status": "done",
            "testStrategy": "Simulate various error scenarios (e.g., invalid credentials, missing tokens, expired tokens) and verify that the application returns appropriate HTTP status codes and error messages."
          }
        ]
      },
      {
        "id": 34,
        "title": "Configure MongoDB Atlas Vector Search",
        "description": "Set up MongoDB Atlas Vector Search for semantic search capabilities.",
        "details": "Ensure MongoDB Atlas cluster is configured to support Vector Search. Create an Atlas Search index on the relevant collection. Use the MongoDB Node.js driver to interact with the Vector Search index. Refer to MongoDB documentation for specific index configuration and query syntax.",
        "testStrategy": "Insert sample data with embeddings into the MongoDB collection. Perform vector searches using different query vectors and verify that the results are relevant.",
        "priority": "high",
        "dependencies": [
          32
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Verify MongoDB Atlas Cluster Configuration for Vector Search",
            "description": "Confirm that the MongoDB Atlas cluster is configured to support Vector Search. This may involve upgrading the cluster tier or enabling specific features.",
            "dependencies": [],
            "details": "Check the Atlas cluster configuration to ensure it meets the minimum requirements for Vector Search. Consult MongoDB Atlas documentation for compatible cluster tiers and required settings.",
            "status": "pending",
            "testStrategy": "Verify the cluster configuration in the Atlas UI or via the Atlas CLI to confirm Vector Search support."
          },
          {
            "id": 2,
            "title": "Create Atlas Search Index with Vector Search Configuration",
            "description": "Define and create an Atlas Search index on the relevant MongoDB collection, specifically configuring it for Vector Search. This includes specifying the field containing the vector embeddings and the similarity metric.",
            "dependencies": [],
            "details": "Use the Atlas UI or the Atlas Search API to create the index. Define the index mapping to include the vector field and specify the appropriate similarity metric (e.g., cosine similarity).",
            "status": "pending",
            "testStrategy": "Inspect the created index in the Atlas UI to verify that the vector search configuration is correctly applied."
          },
          {
            "id": 3,
            "title": "Install and Configure MongoDB Node.js Driver",
            "description": "Install the MongoDB Node.js driver and configure it to connect to the MongoDB Atlas cluster. This involves using the connection string and any necessary authentication credentials.",
            "dependencies": [],
            "details": "Use `npm install mongodb` to install the driver. Use the connection string stored in environment variables (configured in Task 32) to establish a connection to the Atlas cluster.",
            "status": "pending",
            "testStrategy": "Write a simple script to connect to the Atlas cluster using the Node.js driver and verify the connection."
          },
          {
            "id": 4,
            "title": "Implement Vector Search Query using MongoDB Node.js Driver",
            "description": "Write code using the MongoDB Node.js driver to perform vector searches against the created Atlas Search index. This involves constructing the appropriate query syntax and handling the search results.",
            "dependencies": [
              "34.3"
            ],
            "details": "Use the `$vectorSearch` aggregation pipeline stage in the MongoDB query to perform the vector search. Construct the query with the query vector and the index name. Handle the returned results and extract the relevant documents.",
            "status": "pending",
            "testStrategy": "Insert sample data with embeddings into the MongoDB collection. Perform vector searches using different query vectors and verify that the results are relevant."
          },
          {
            "id": 5,
            "title": "Test and Optimize Vector Search Performance",
            "description": "Test the performance of the vector search queries and optimize the index configuration or query syntax as needed to improve search speed and accuracy.",
            "dependencies": [
              "34.4"
            ],
            "details": "Measure the query execution time and analyze the search results. Adjust the index configuration (e.g., number of dimensions, similarity metric) or the query syntax to optimize performance.",
            "status": "pending",
            "testStrategy": "Run benchmark tests with different query vectors and measure the query execution time. Evaluate the relevance of the search results and adjust the index or query as needed."
          }
        ]
      },
      {
        "id": 35,
        "title": "Integrate OpenAI Embeddings API",
        "description": "Integrate OpenAI Embeddings API for generating vector embeddings of the memo card data.",
        "details": "Install the OpenAI Node.js library (`npm install openai`). Use the OpenAI Embeddings API to generate embeddings for the memo card text. Store the embeddings in the MongoDB collection along with the memo card data. Handle API key securely using environment variables. Consider using `node-rate-limiter` to avoid rate limits.",
        "testStrategy": "Create a script to generate embeddings for sample memo card data using the OpenAI API. Verify that the embeddings are generated correctly and stored in the MongoDB collection.",
        "priority": "high",
        "dependencies": [
          33,
          34
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Securely Configure OpenAI API Key",
            "description": "Set up environment variables to securely store and access the OpenAI API key.",
            "dependencies": [],
            "details": "Create a `.env` file or use a configuration management tool to store the OpenAI API key. Ensure the API key is not hardcoded in the application.",
            "status": "pending",
            "testStrategy": "Verify that the API key is accessible from the application using `process.env` and that it is not exposed in the codebase."
          },
          {
            "id": 2,
            "title": "Implement OpenAI Embeddings Generation",
            "description": "Write a function to generate embeddings for memo card text using the OpenAI Embeddings API.",
            "dependencies": [],
            "details": "Use the OpenAI Node.js library to call the Embeddings API. Handle potential errors and rate limits. Implement retry logic if necessary.",
            "status": "pending",
            "testStrategy": "Create a script to generate embeddings for sample memo card data. Verify that the embeddings are generated correctly and that the API calls are successful."
          },
          {
            "id": 3,
            "title": "Implement Rate Limiting",
            "description": "Integrate `node-rate-limiter` to prevent exceeding OpenAI API rate limits.",
            "dependencies": [],
            "details": "Install `node-rate-limiter`. Configure the rate limiter to match the OpenAI API rate limits. Implement error handling for rate limit exceeded errors.",
            "status": "pending",
            "testStrategy": "Simulate multiple requests to the OpenAI API and verify that the rate limiter is working correctly and that the application handles rate limit exceeded errors gracefully."
          },
          {
            "id": 4,
            "title": "Store Embeddings in MongoDB",
            "description": "Modify the memo card data storage logic to include the generated embeddings in the MongoDB collection.",
            "dependencies": [],
            "details": "Update the MongoDB schema to include a field for storing the embeddings. Modify the data insertion logic to include the generated embeddings when saving memo card data.",
            "status": "pending",
            "testStrategy": "Insert sample memo card data with embeddings into the MongoDB collection. Verify that the embeddings are stored correctly and that the data can be retrieved successfully."
          },
          {
            "id": 5,
            "title": "Integrate Embedding Generation into Memo Card Creation",
            "description": "Automate the embedding generation process when a new memo card is created.",
            "dependencies": [
              "35.1",
              "35.2",
              "35.3",
              "35.4"
            ],
            "details": "Modify the memo card creation workflow to automatically generate embeddings for the memo card text and store them in the database.",
            "status": "pending",
            "testStrategy": "Create a new memo card and verify that the embeddings are generated automatically and stored in the MongoDB collection along with the memo card data."
          }
        ]
      },
      {
        "id": 36,
        "title": "Implement Hybrid Search",
        "description": "Implement a hybrid search functionality combining keyword and vector search.",
        "details": "Use the MongoDB Atlas Search `$search` aggregation pipeline to combine keyword and vector search queries. Implement logic to adjust the weights of keyword and vector search results based on the query and data characteristics. Optimize the search query for performance.",
        "testStrategy": "Perform hybrid searches using different combinations of keywords and vectors. Verify that the results are relevant and that the weights are adjusted correctly.",
        "priority": "high",
        "dependencies": [
          34,
          35
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Basic Keyword Search with MongoDB Atlas",
            "description": "Implement a basic keyword search using the MongoDB Atlas Search `$search` aggregation pipeline. Configure the index and query to perform keyword searches on relevant fields.",
            "dependencies": [],
            "details": "Configure a MongoDB Atlas Search index for keyword search. Use the `$search` aggregation pipeline to perform keyword queries. Test with sample data to ensure basic keyword search functionality.",
            "status": "pending",
            "testStrategy": "Search for known keywords and verify that the expected documents are returned."
          },
          {
            "id": 2,
            "title": "Implement Basic Vector Search with MongoDB Atlas",
            "description": "Implement a basic vector search using the MongoDB Atlas Search `$search` aggregation pipeline. Configure the index and query to perform vector searches on the embedding fields.",
            "dependencies": [],
            "details": "Configure a MongoDB Atlas Search index for vector search. Use the `$search` aggregation pipeline to perform vector queries. Test with sample data to ensure basic vector search functionality.",
            "status": "pending",
            "testStrategy": "Search using sample vectors and verify that the expected documents are returned based on vector similarity."
          },
          {
            "id": 3,
            "title": "Combine Keyword and Vector Search Queries",
            "description": "Combine the keyword and vector search queries using the `$search` aggregation pipeline. Implement the initial combination of the two search types.",
            "dependencies": [
              "36.1",
              "36.2"
            ],
            "details": "Use the `$search` aggregation pipeline to combine the keyword and vector search queries. Experiment with different combination methods (e.g., compound queries).",
            "status": "pending",
            "testStrategy": "Perform hybrid searches with various combinations of keywords and vectors. Verify that results from both search types are returned."
          },
          {
            "id": 4,
            "title": "Implement Weight Adjustment Logic",
            "description": "Implement logic to adjust the weights of keyword and vector search results based on query and data characteristics.",
            "dependencies": [
              "36.3"
            ],
            "details": "Implement logic to dynamically adjust the weights of keyword and vector search results. Consider factors such as query type, data characteristics, and user preferences. Use configurable parameters for weight adjustment.",
            "status": "pending",
            "testStrategy": "Test different weight combinations and verify that the results are ranked according to the adjusted weights. Analyze the impact of weight adjustments on search relevance."
          },
          {
            "id": 5,
            "title": "Optimize Hybrid Search Query Performance",
            "description": "Optimize the hybrid search query for performance. Analyze query execution plans and identify potential bottlenecks.",
            "dependencies": [
              "36.4"
            ],
            "details": "Analyze the query execution plan using MongoDB Atlas tools. Optimize the query for performance by using appropriate indexes and query operators. Consider caching strategies to improve response times.",
            "status": "pending",
            "testStrategy": "Measure the response time of hybrid search queries with different data volumes and query complexities. Identify and address any performance bottlenecks."
          }
        ]
      },
      {
        "id": 37,
        "title": "Develop Search API Endpoints",
        "description": "Develop API endpoints for handling search queries and returning results.",
        "details": "Create Express.js routes for handling search requests. Implement input validation and sanitization to prevent security vulnerabilities. Return search results in a JSON format. Implement pagination for handling large result sets.",
        "testStrategy": "Send search requests to the API endpoints and verify that the results are returned correctly. Test different query parameters and pagination options.",
        "priority": "high",
        "dependencies": [
          36
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define API Routes and Request Handling",
            "description": "Define the Express.js routes for handling search requests, including specifying the HTTP methods (e.g., GET, POST) and URL paths.",
            "dependencies": [],
            "details": "Create route handlers for different search functionalities. Implement middleware for request logging and error handling.",
            "status": "pending",
            "testStrategy": "Send requests to the defined API routes and verify that the requests are handled correctly and that the appropriate responses are returned."
          },
          {
            "id": 2,
            "title": "Implement Input Validation and Sanitization",
            "description": "Implement robust input validation and sanitization to prevent common security vulnerabilities such as SQL injection and cross-site scripting (XSS).",
            "dependencies": [],
            "details": "Use a validation library (e.g., express-validator) to validate request parameters and body. Sanitize user input to remove potentially harmful characters or code.",
            "status": "pending",
            "testStrategy": "Send malicious or invalid input to the API endpoints and verify that the input is properly validated and sanitized, and that appropriate error messages are returned."
          },
          {
            "id": 3,
            "title": "Implement Search Logic and Data Retrieval",
            "description": "Implement the core search logic to query the database (MongoDB Atlas) based on the search parameters. Integrate with the hybrid search functionality.",
            "dependencies": [],
            "details": "Use the MongoDB Node.js driver to connect to the database and execute search queries. Construct the search query based on the validated input parameters. Integrate with the hybrid search implementation from Task 36.",
            "status": "pending",
            "testStrategy": "Send different search queries to the API endpoints and verify that the correct results are returned from the database. Test different combinations of keywords and vectors."
          },
          {
            "id": 4,
            "title": "Format Search Results as JSON",
            "description": "Format the search results into a JSON format that is easy to consume by client applications.",
            "dependencies": [
              "37.3"
            ],
            "details": "Transform the data retrieved from the database into a JSON structure. Include relevant metadata such as the total number of results and the current page number.",
            "status": "pending",
            "testStrategy": "Send search requests to the API endpoints and verify that the results are returned in the correct JSON format. Verify that the JSON structure is consistent and well-formed."
          },
          {
            "id": 5,
            "title": "Implement Pagination",
            "description": "Implement pagination to handle large result sets and improve performance.",
            "dependencies": [
              "37.3"
            ],
            "details": "Add parameters to the API endpoints for specifying the page number and page size. Implement logic to retrieve only the results for the requested page. Return pagination metadata in the JSON response.",
            "status": "pending",
            "testStrategy": "Send search requests with different page numbers and page sizes and verify that the correct results are returned for each page. Verify that the pagination metadata is accurate."
          }
        ]
      },
      {
        "id": 38,
        "title": "Implement AI Learning Diagnostics",
        "description": "Implement AI-powered learning diagnostics based on memo card data.",
        "details": "Fetch memo card data and embeddings. Use clustering algorithms (e.g., k-means from `ml-kmeans` - install via `npm install ml-kmeans`) to identify learning patterns. Analyze the clusters to identify strengths and weaknesses. Consider using anomaly detection techniques to identify unusual learning patterns.",
        "testStrategy": "Run the learning diagnostics on sample memo card data. Verify that the learning patterns are identified correctly and that the strengths and weaknesses are accurately assessed.",
        "priority": "medium",
        "dependencies": [
          35
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Fetch Memo Card Data and Embeddings",
            "description": "Retrieve memo card data and their corresponding embeddings from the database.",
            "dependencies": [],
            "details": "Implement a function to query the database and retrieve memo card data along with their pre-calculated embeddings. Ensure efficient data retrieval.",
            "status": "pending",
            "testStrategy": "Verify that the function retrieves the correct memo card data and embeddings for a sample set of memo cards."
          },
          {
            "id": 2,
            "title": "Implement Clustering Algorithm",
            "description": "Implement the k-means clustering algorithm using the `ml-kmeans` library.",
            "dependencies": [],
            "details": "Install `ml-kmeans` using `npm install ml-kmeans`. Implement a function that takes memo card embeddings as input and performs k-means clustering to identify learning patterns. Determine the optimal number of clusters (k) using techniques like the elbow method or silhouette analysis.",
            "status": "pending",
            "testStrategy": "Run the clustering algorithm on a sample dataset of memo card embeddings and verify that the clusters are formed correctly. Evaluate the quality of the clusters using metrics like silhouette score."
          },
          {
            "id": 3,
            "title": "Analyze Clusters for Strengths and Weaknesses",
            "description": "Analyze the clusters to identify strengths and weaknesses in learning.",
            "dependencies": [
              "38.2"
            ],
            "details": "For each cluster, analyze the memo card content and identify common themes or topics. Determine the overall performance of users within each cluster to identify strengths and weaknesses. Generate a report summarizing the findings.",
            "status": "pending",
            "testStrategy": "Manually review the clusters and the identified strengths and weaknesses to ensure they are accurate and meaningful."
          },
          {
            "id": 4,
            "title": "Implement Anomaly Detection (Optional)",
            "description": "Implement anomaly detection techniques to identify unusual learning patterns.",
            "dependencies": [
              "38.1"
            ],
            "details": "Explore anomaly detection algorithms (e.g., Isolation Forest, One-Class SVM) to identify memo cards or users with unusual learning patterns. Integrate the anomaly detection algorithm into the learning diagnostics pipeline.",
            "status": "pending",
            "testStrategy": "Run the anomaly detection algorithm on a sample dataset and verify that it correctly identifies unusual learning patterns. Evaluate the performance of the algorithm using metrics like precision and recall."
          },
          {
            "id": 5,
            "title": "Integrate Diagnostics into Learning Platform",
            "description": "Integrate the AI learning diagnostics into the learning platform.",
            "dependencies": [
              "38.3",
              "38.4"
            ],
            "details": "Create an API endpoint to expose the learning diagnostics functionality. Integrate the API endpoint into the learning platform's user interface. Display the learning diagnostics results to users in a clear and understandable format.",
            "status": "pending",
            "testStrategy": "Test the integration by running the learning diagnostics on sample user data and verifying that the results are displayed correctly in the learning platform."
          }
        ]
      },
      {
        "id": 39,
        "title": "Create Predictive Learning Plans",
        "description": "Create predictive learning plans based on the AI diagnostics.",
        "details": "Based on the identified learning patterns, generate personalized learning plans. Prioritize topics based on weaknesses and upcoming exams. Suggest specific memo cards for review. Consider using a rule-based system or a simple Markov model to generate the learning plans.",
        "testStrategy": "Generate learning plans for different users and verify that the plans are personalized and relevant to their learning needs.",
        "priority": "medium",
        "dependencies": [
          38
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Rule-Based Learning Plan Generation",
            "description": "Develop a rule-based system to generate personalized learning plans based on identified weaknesses and upcoming exams.",
            "dependencies": [],
            "details": "Define rules for prioritizing topics, suggesting memo cards, and scheduling review sessions based on user performance data and exam dates.",
            "status": "pending",
            "testStrategy": "Test the rule-based system by generating learning plans for various user profiles and verifying that the plans address their specific weaknesses and exam schedules."
          },
          {
            "id": 2,
            "title": "Implement Markov Model Learning Plan Generation",
            "description": "Develop a Markov model to generate personalized learning plans based on identified learning patterns.",
            "dependencies": [],
            "details": "Train a Markov model on user learning data to predict optimal learning paths and suggest relevant memo cards for review. Consider transition probabilities between topics and user performance.",
            "status": "pending",
            "testStrategy": "Test the Markov model by generating learning plans for different users and comparing the plans to their actual learning progress. Evaluate the model's ability to predict effective learning paths."
          },
          {
            "id": 3,
            "title": "Prioritize Topics Based on Weaknesses and Exams",
            "description": "Develop a mechanism to prioritize learning topics based on user weaknesses identified by AI diagnostics and upcoming exam schedules.",
            "dependencies": [],
            "details": "Implement an algorithm that assigns weights to topics based on their relevance to user weaknesses and exam content. Consider the time remaining before the exam.",
            "status": "pending",
            "testStrategy": "Test the prioritization mechanism by generating topic lists for different users and verifying that the lists prioritize topics that are both weak and relevant to upcoming exams."
          },
          {
            "id": 4,
            "title": "Suggest Specific Memo Cards for Review",
            "description": "Implement a system to suggest specific memo cards for review based on the prioritized topics and user performance.",
            "dependencies": [],
            "details": "Develop a method to link prioritized topics to relevant memo cards. Consider user performance on previous memo card reviews and suggest cards that need reinforcement.",
            "status": "pending",
            "testStrategy": "Test the memo card suggestion system by generating lists of suggested memo cards for different users and verifying that the cards are relevant to their prioritized topics and weaknesses."
          },
          {
            "id": 5,
            "title": "Integrate Rule-Based and Markov Model Systems",
            "description": "Integrate the rule-based and Markov model systems to create a hybrid approach for generating learning plans.",
            "dependencies": [
              "39.1",
              "39.2",
              "39.3",
              "39.4"
            ],
            "details": "Combine the strengths of both systems to generate more robust and personalized learning plans. Use the rule-based system for initial prioritization and the Markov model for optimizing the learning path.",
            "status": "pending",
            "testStrategy": "Test the integrated system by generating learning plans for different users and comparing the plans to those generated by the individual systems. Evaluate the overall effectiveness of the integrated approach."
          }
        ]
      },
      {
        "id": 40,
        "title": "Optimize Knowledge Connections",
        "description": "Optimize knowledge connections based on the memo card data.",
        "details": "Analyze the relationships between different memo cards. Identify gaps in knowledge and suggest additional memo cards to fill those gaps. Use graph algorithms (e.g., from `graphlib` - install via `npm install graphlib`) to analyze the knowledge graph.",
        "testStrategy": "Analyze the knowledge connections for different users and verify that the gaps in knowledge are identified correctly and that the suggested memo cards are relevant.",
        "priority": "medium",
        "dependencies": [
          39
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Configure Graphlib",
            "description": "Install the `graphlib` library using npm and set up the environment for its usage in the project.",
            "dependencies": [],
            "details": "Install `graphlib` using `npm install graphlib`. Verify the installation by importing the library in a test file and running it.",
            "status": "pending",
            "testStrategy": "Create a simple graph using `graphlib` and verify that the graph can be created and manipulated correctly."
          },
          {
            "id": 2,
            "title": "Analyze Memo Card Relationships",
            "description": "Analyze the existing memo card data to identify relationships between different cards. Determine the types of relationships (e.g., prerequisite, related topic).",
            "dependencies": [],
            "details": "Examine the memo card data structure and identify fields that indicate relationships between cards. Develop a method to extract these relationships programmatically.",
            "status": "pending",
            "testStrategy": "Manually verify the identified relationships against a sample of memo cards to ensure accuracy."
          },
          {
            "id": 3,
            "title": "Build Knowledge Graph",
            "description": "Construct a knowledge graph using the identified memo card relationships. Represent memo cards as nodes and relationships as edges in the graph.",
            "dependencies": [
              "40.2",
              "40.1"
            ],
            "details": "Use the `graphlib` library to create a graph data structure. Populate the graph with memo card data and relationships extracted in the previous step.",
            "status": "pending",
            "testStrategy": "Visualize the generated knowledge graph to ensure that the nodes and edges are correctly represented."
          },
          {
            "id": 4,
            "title": "Identify Knowledge Gaps",
            "description": "Apply graph algorithms to identify gaps in the knowledge graph. Look for nodes with few connections or missing prerequisite relationships.",
            "dependencies": [
              "40.3"
            ],
            "details": "Use graph algorithms (e.g., shortest path, centrality measures) to identify nodes that are poorly connected or have missing dependencies. Define criteria for identifying a 'knowledge gap'.",
            "status": "pending",
            "testStrategy": "Manually review the identified knowledge gaps and verify that they are indeed gaps in the knowledge domain."
          },
          {
            "id": 5,
            "title": "Suggest Additional Memo Cards",
            "description": "Based on the identified knowledge gaps, suggest additional memo cards to fill those gaps. Suggest cards that bridge the gaps and strengthen the knowledge graph.",
            "dependencies": [
              "40.4"
            ],
            "details": "Develop a method to suggest relevant memo cards based on the identified gaps. Consider using keyword analysis or semantic similarity to find appropriate cards.",
            "status": "pending",
            "testStrategy": "Evaluate the relevance of the suggested memo cards to the identified knowledge gaps. Ensure that the suggested cards effectively address the gaps."
          }
        ]
      },
      {
        "id": 41,
        "title": "Implement Real-time Learning Optimization",
        "description": "Implement real-time learning optimization based on user activity.",
        "details": "Track user activity (e.g., memo card views, search queries). Adjust the learning plan in real-time based on user activity. Suggest alternative memo cards or topics based on user struggles.",
        "testStrategy": "Simulate user activity and verify that the learning plan is adjusted in real-time based on the activity.",
        "priority": "medium",
        "dependencies": [
          40
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Track User Activity",
            "description": "Implement mechanisms to track user activity, including memo card views, search queries, and other relevant interactions within the learning platform.",
            "dependencies": [],
            "details": "Implement event listeners and data logging for user actions. Store activity data in a suitable database or data store. Consider using a message queue for asynchronous processing of activity data.",
            "status": "pending",
            "testStrategy": "Simulate user actions and verify that the activity data is correctly logged and stored."
          },
          {
            "id": 2,
            "title": "Analyze User Activity Data",
            "description": "Develop algorithms and processes to analyze the collected user activity data to identify patterns, struggles, and areas for improvement.",
            "dependencies": [
              "41.1"
            ],
            "details": "Implement statistical analysis and machine learning techniques to identify correlations between user activity and learning outcomes. Calculate metrics such as memo card completion rates, search query success rates, and time spent on specific topics.",
            "status": "pending",
            "testStrategy": "Use sample user activity data to verify that the analysis algorithms correctly identify patterns and areas for improvement."
          },
          {
            "id": 3,
            "title": "Adjust Learning Plan in Real-time",
            "description": "Implement logic to dynamically adjust the user's learning plan based on the analysis of their activity data.",
            "dependencies": [
              "41.2"
            ],
            "details": "Develop algorithms to prioritize memo cards and topics based on user performance and identified weaknesses. Implement mechanisms to update the learning plan in real-time based on user progress and struggles.",
            "status": "pending",
            "testStrategy": "Simulate user activity and verify that the learning plan is adjusted dynamically based on the activity."
          },
          {
            "id": 4,
            "title": "Suggest Alternative Memo Cards or Topics",
            "description": "Implement a recommendation system to suggest alternative memo cards or topics to users based on their struggles and learning preferences.",
            "dependencies": [
              "41.2"
            ],
            "details": "Develop algorithms to identify relevant alternative memo cards or topics based on user activity and learning goals. Implement a user interface to display the recommendations to the user.",
            "status": "pending",
            "testStrategy": "Simulate user struggles and verify that the recommendation system suggests relevant alternative memo cards or topics."
          },
          {
            "id": 5,
            "title": "Integrate with User Interface",
            "description": "Integrate the real-time learning optimization features into the user interface, providing users with feedback and recommendations.",
            "dependencies": [
              "41.3",
              "41.4"
            ],
            "details": "Update the user interface to display the adjusted learning plan and recommendations. Provide users with feedback on their progress and areas for improvement. Ensure that the user interface is responsive and user-friendly.",
            "status": "pending",
            "testStrategy": "Conduct user testing to verify that the real-time learning optimization features are integrated seamlessly into the user interface and that users find them helpful."
          }
        ]
      },
      {
        "id": 42,
        "title": "Implement Automatic Vulnerability Diagnostics",
        "description": "Implement automatic vulnerability diagnostics to identify weak areas in the user's knowledge.",
        "details": "Analyze memo card data and identify areas where the user is struggling. Use statistical analysis to identify topics with low recall rates. Generate reports highlighting the weak areas.",
        "testStrategy": "Run the vulnerability diagnostics on sample memo card data and verify that the weak areas are identified correctly.",
        "priority": "medium",
        "dependencies": [
          38
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze Memo Card Data for Recall Rates",
            "description": "Parse and analyze memo card data to determine recall rates for each topic. Identify topics with significantly lower recall rates than average.",
            "dependencies": [],
            "details": "Implement a function to read memo card data, calculate recall rates for each topic, and identify topics below a defined threshold. Consider using statistical measures like standard deviation to identify significant deviations.",
            "status": "pending",
            "testStrategy": "Test the function with sample memo card data containing varying recall rates. Verify that the function correctly identifies topics with low recall rates."
          },
          {
            "id": 2,
            "title": "Implement Statistical Analysis of Recall Rates",
            "description": "Apply statistical analysis techniques to the calculated recall rates to identify statistically significant weak areas.",
            "dependencies": [
              "42.1"
            ],
            "details": "Use statistical methods (e.g., t-tests, z-tests) to determine if the low recall rates are statistically significant. Adjust for multiple comparisons if necessary. Consider Bayesian approaches for more robust analysis.",
            "status": "pending",
            "testStrategy": "Test the statistical analysis with simulated recall rate data. Verify that the analysis correctly identifies statistically significant weak areas."
          },
          {
            "id": 3,
            "title": "Generate Vulnerability Reports",
            "description": "Create a report generation module to highlight the identified weak areas in a user-friendly format.",
            "dependencies": [
              "42.2"
            ],
            "details": "Design a report format that clearly presents the weak areas, their recall rates, and the statistical significance. Include visualizations (e.g., bar charts, heatmaps) to improve readability. Allow users to customize the report content and format.",
            "status": "pending",
            "testStrategy": "Generate reports with sample data and verify that the reports accurately reflect the identified weak areas and are easy to understand."
          },
          {
            "id": 4,
            "title": "Integrate Analysis with Memo Card System",
            "description": "Integrate the vulnerability diagnostics module with the existing memo card system to automatically analyze user data.",
            "dependencies": [
              "42.1",
              "42.2",
              "42.3"
            ],
            "details": "Modify the memo card system to trigger the vulnerability diagnostics module periodically or on-demand. Store the generated reports in a database or file system. Provide a user interface for accessing the reports.",
            "status": "pending",
            "testStrategy": "Run the integrated system with real user data and verify that the vulnerability diagnostics module is triggered correctly and that the reports are generated and stored properly."
          },
          {
            "id": 5,
            "title": "Implement User Interface for Report Access",
            "description": "Develop a user interface within the memo card system for users to access and view their vulnerability reports.",
            "dependencies": [
              "42.4"
            ],
            "details": "Create a user-friendly interface for browsing and viewing the generated reports. Allow users to filter reports by date, topic, or other criteria. Provide options for downloading or printing the reports.",
            "status": "pending",
            "testStrategy": "Test the user interface with different user roles and permissions. Verify that users can access their reports and that the interface is easy to use and navigate."
          }
        ]
      },
      {
        "id": 43,
        "title": "Analyze Time Slot Characteristics",
        "description": "Analyze memo card characteristics across 5 different time slots.",
        "details": "Group memo card data by time slot. Analyze the characteristics of the memo cards in each time slot (e.g., topic, difficulty). Identify patterns in the user's learning behavior across different time slots.",
        "testStrategy": "Analyze memo card data for different users and verify that the time slot analysis is performed correctly.",
        "priority": "low",
        "dependencies": [
          38
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Data Extraction and Grouping by Time Slot",
            "description": "Extract memo card data from the database and group it into five distinct time slots as defined by the application.",
            "dependencies": [],
            "details": "Identify the relevant data fields (topic, difficulty, user ID, timestamps) and create a data structure that organizes memo cards by time slot.",
            "status": "pending",
            "testStrategy": "Verify that the memo card data is correctly extracted and grouped into the appropriate time slots. Check for data integrity and completeness."
          },
          {
            "id": 2,
            "title": "Analyze Topic Distribution per Time Slot",
            "description": "Analyze the distribution of topics covered in memo cards for each of the five time slots.",
            "dependencies": [
              "43.1"
            ],
            "details": "Calculate the frequency of each topic within each time slot. Identify the most and least frequent topics for each slot.",
            "status": "pending",
            "testStrategy": "Verify that the topic distribution is calculated correctly for each time slot. Compare the distributions across different time slots to identify any significant differences."
          },
          {
            "id": 3,
            "title": "Analyze Difficulty Level Distribution per Time Slot",
            "description": "Analyze the distribution of difficulty levels assigned to memo cards for each of the five time slots.",
            "dependencies": [
              "43.1"
            ],
            "details": "Calculate the frequency of each difficulty level (e.g., easy, medium, hard) within each time slot. Identify the average difficulty level for each slot.",
            "status": "pending",
            "testStrategy": "Verify that the difficulty level distribution is calculated correctly for each time slot. Compare the distributions across different time slots to identify any significant differences."
          },
          {
            "id": 4,
            "title": "Identify User Learning Behavior Patterns",
            "description": "Identify patterns in user learning behavior across different time slots based on topic and difficulty.",
            "dependencies": [
              "43.2",
              "43.3"
            ],
            "details": "Analyze how the topics and difficulty levels of memo cards change across the five time slots. Look for patterns such as users focusing on specific topics or difficulty levels during certain times.",
            "status": "pending",
            "testStrategy": "Analyze user data to identify common learning patterns across different time slots. Verify that the identified patterns are consistent with the user's learning goals and preferences."
          },
          {
            "id": 5,
            "title": "Document Findings and Insights",
            "description": "Document the findings of the time slot analysis, including the topic and difficulty distributions, and the identified user learning behavior patterns.",
            "dependencies": [
              "43.4"
            ],
            "details": "Create a report summarizing the key findings of the analysis. Include visualizations (e.g., charts, graphs) to illustrate the data and patterns. Provide recommendations for improving the user's learning experience based on the findings.",
            "status": "pending",
            "testStrategy": "Review the documentation to ensure that it accurately reflects the results of the analysis and provides clear and actionable insights."
          }
        ]
      },
      {
        "id": 44,
        "title": "Analyze Time Slot Efficiency",
        "description": "Analyze learning efficiency for each time slot.",
        "details": "Measure the user's learning efficiency in each time slot (e.g., recall rate, completion time). Identify the most and least efficient time slots for the user.",
        "testStrategy": "Measure the learning efficiency for different users and verify that the time slot efficiency analysis is performed correctly.",
        "priority": "low",
        "dependencies": [
          43
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Time Slots",
            "description": "Define the specific time slots to be analyzed (e.g., morning, afternoon, evening, night).",
            "dependencies": [],
            "details": "Establish clear boundaries for each time slot to ensure consistent data aggregation.",
            "status": "pending",
            "testStrategy": "Verify that the defined time slots cover the entire day and are mutually exclusive."
          },
          {
            "id": 2,
            "title": "Collect Learning Data per Time Slot",
            "description": "Gather user learning data (recall rate, completion time, etc.) for each defined time slot.",
            "dependencies": [],
            "details": "Extract relevant data points from user learning sessions, categorizing them by time slot.",
            "status": "pending",
            "testStrategy": "Ensure that all learning data is correctly assigned to the appropriate time slot."
          },
          {
            "id": 3,
            "title": "Calculate Efficiency Metrics",
            "description": "Calculate learning efficiency metrics (e.g., average recall rate, average completion time) for each time slot.",
            "dependencies": [
              "44.2"
            ],
            "details": "Compute the average recall rate and completion time for each time slot based on the collected data.",
            "status": "pending",
            "testStrategy": "Verify the accuracy of the calculated efficiency metrics for each time slot."
          },
          {
            "id": 4,
            "title": "Identify Most and Least Efficient Time Slots",
            "description": "Determine the time slots with the highest and lowest learning efficiency based on the calculated metrics.",
            "dependencies": [
              "44.3"
            ],
            "details": "Compare the efficiency metrics across all time slots to identify the most and least efficient periods.",
            "status": "pending",
            "testStrategy": "Confirm that the identified time slots align with the calculated efficiency metrics."
          },
          {
            "id": 5,
            "title": "Document Findings and Recommendations",
            "description": "Document the analysis results, including the most and least efficient time slots, and provide recommendations for optimizing learning schedules.",
            "dependencies": [
              "44.4"
            ],
            "details": "Prepare a report summarizing the analysis findings and suggesting adjustments to learning schedules based on time slot efficiency.",
            "status": "pending",
            "testStrategy": "Review the documentation to ensure clarity, accuracy, and actionable recommendations."
          }
        ]
      },
      {
        "id": 45,
        "title": "Optimize Learning Types for Time Slots",
        "description": "Optimize learning types for each time slot.",
        "details": "Suggest different learning types for each time slot based on the user's learning style and the characteristics of the memo cards. For example, suggest visual learning for time slots where the user is more receptive to visual information.",
        "testStrategy": "Suggest learning types for different users and verify that the suggestions are relevant to their learning style and the time slot characteristics.",
        "priority": "low",
        "dependencies": [
          44
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Research Learning Styles and Time-Based Receptivity",
            "description": "Research different learning styles (visual, auditory, kinesthetic, etc.) and how user receptivity to each style varies across different time slots (morning, afternoon, evening).",
            "dependencies": [],
            "details": "Gather information on the effectiveness of different learning styles at different times of the day. Consider factors like circadian rhythms and typical daily activities.",
            "status": "pending",
            "testStrategy": "Review existing literature and studies on learning styles and time-based learning effectiveness."
          },
          {
            "id": 2,
            "title": "Analyze Memo Card Characteristics for Learning Style Alignment",
            "description": "Analyze the characteristics of memo cards (e.g., text-heavy, image-based, audio-based) and determine which learning styles they best align with.",
            "dependencies": [],
            "details": "Categorize memo cards based on their content and format. Determine which learning styles are most suitable for each category. For example, a memo card with a diagram would be suitable for visual learners.",
            "status": "pending",
            "testStrategy": "Create a matrix mapping memo card characteristics to learning styles and validate it with user feedback."
          },
          {
            "id": 3,
            "title": "Develop Algorithm for Learning Type Suggestion",
            "description": "Develop an algorithm that suggests the most appropriate learning type for a given time slot based on the user's learning style and the characteristics of the memo card.",
            "dependencies": [
              "45.1",
              "45.2"
            ],
            "details": "The algorithm should take into account the user's preferred learning style, the time of day, and the content of the memo card. It should output a suggested learning type (e.g., visual, auditory, kinesthetic).",
            "status": "pending",
            "testStrategy": "Test the algorithm with a variety of users and memo cards to ensure that the suggestions are relevant and effective."
          },
          {
            "id": 4,
            "title": "Implement Learning Type Suggestion Feature",
            "description": "Implement the learning type suggestion feature in the application, integrating the developed algorithm.",
            "dependencies": [
              "45.3"
            ],
            "details": "Integrate the algorithm into the application's learning plan generation module. Display the suggested learning type to the user for each time slot.",
            "status": "pending",
            "testStrategy": "Verify that the learning type suggestion feature is working correctly and that the suggestions are displayed to the user in a clear and concise manner."
          },
          {
            "id": 5,
            "title": "Gather User Feedback and Iterate on Algorithm",
            "description": "Gather user feedback on the learning type suggestions and iterate on the algorithm to improve its accuracy and effectiveness.",
            "dependencies": [
              "45.4"
            ],
            "details": "Collect user feedback through surveys, interviews, and usage data. Analyze the feedback to identify areas where the algorithm can be improved. Update the algorithm based on the feedback.",
            "status": "pending",
            "testStrategy": "Track user engagement with the suggested learning types and measure their learning outcomes. Use this data to refine the algorithm."
          }
        ]
      },
      {
        "id": 46,
        "title": "Track Learning Progress for Time Slots",
        "description": "Track learning progress for each time slot.",
        "details": "Monitor the user's progress in each time slot. Identify areas where the user is falling behind. Adjust the learning plan to address the areas where the user is struggling.",
        "testStrategy": "Track the learning progress for different users and verify that the progress is tracked correctly and that the learning plan is adjusted accordingly.",
        "priority": "low",
        "dependencies": [
          44
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Progress Tracking per Time Slot",
            "description": "Implement a system to track the user's progress on memo cards within each defined time slot.",
            "dependencies": [],
            "details": "Develop a mechanism to record the number of memo cards reviewed, the time spent, and the performance (e.g., accuracy, recall rate) for each time slot. Store this data in a structured format.",
            "status": "pending",
            "testStrategy": "Simulate user activity across different time slots and verify that the system accurately records progress metrics for each slot."
          },
          {
            "id": 2,
            "title": "Identify Areas of Weakness per Time Slot",
            "description": "Analyze the tracked data to identify specific areas where the user is struggling within each time slot.",
            "dependencies": [
              "46.1"
            ],
            "details": "Analyze the performance data (accuracy, recall rate) for each memo card category within each time slot. Flag categories where the user's performance falls below a predefined threshold.",
            "status": "pending",
            "testStrategy": "Introduce simulated weaknesses in specific memo card categories during certain time slots and verify that the system correctly identifies these areas of weakness."
          },
          {
            "id": 3,
            "title": "Develop Time Slot Performance Dashboard",
            "description": "Create a dashboard to visualize the user's learning progress and identify areas of weakness for each time slot.",
            "dependencies": [
              "46.1",
              "46.2"
            ],
            "details": "Design and implement a dashboard that displays the user's progress metrics (e.g., cards reviewed, time spent, accuracy) for each time slot. Highlight areas of weakness based on the analysis from subtask 46.2.",
            "status": "pending",
            "testStrategy": "Populate the dashboard with simulated user data and verify that the information is displayed accurately and that areas of weakness are clearly highlighted."
          },
          {
            "id": 4,
            "title": "Adjust Learning Plan Based on Time Slot Performance",
            "description": "Implement a mechanism to automatically adjust the learning plan based on the identified areas of weakness in each time slot.",
            "dependencies": [
              "46.2"
            ],
            "details": "Develop an algorithm that prioritizes memo cards from categories where the user is struggling in specific time slots. Increase the frequency of review for these cards during those time slots.",
            "status": "pending",
            "testStrategy": "Simulate user weaknesses in specific categories during certain time slots and verify that the learning plan is adjusted to prioritize those categories during those time slots."
          },
          {
            "id": 5,
            "title": "Evaluate the Effectiveness of Learning Plan Adjustments",
            "description": "Monitor the user's progress after the learning plan adjustments to evaluate their effectiveness.",
            "dependencies": [
              "46.4"
            ],
            "details": "Track the user's performance in the areas where the learning plan was adjusted. Measure the improvement in accuracy and recall rate over time. Refine the adjustment algorithm based on the evaluation results.",
            "status": "pending",
            "testStrategy": "Simulate user weaknesses, adjust the learning plan, and then simulate continued learning. Verify that the user's performance improves in the previously weak areas and that the improvement is statistically significant."
          }
        ]
      },
      {
        "id": 47,
        "title": "Predict Exam Success",
        "description": "Predict exam success based on AI analysis.",
        "details": "Use machine learning models (e.g., logistic regression from `ml-logistic-regression` - install via `npm install ml-logistic-regression`) to predict exam success based on memo card data and learning patterns. Train the model on historical exam data. Provide a confidence score for the prediction.",
        "testStrategy": "Train the exam success prediction model on historical exam data. Evaluate the model's performance on a test dataset. Verify that the predictions are accurate and that the confidence scores are reliable.",
        "priority": "medium",
        "dependencies": [
          38
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Data Preparation and Preprocessing",
            "description": "Prepare and preprocess historical exam data, memo card data, and learning patterns for model training. This includes cleaning, transforming, and feature engineering relevant data.",
            "dependencies": [],
            "details": "Gather historical exam results, memo card usage data (e.g., time spent, recall rate), and learning patterns (e.g., time slot efficiency). Clean the data by handling missing values and outliers. Transform categorical variables into numerical representations. Engineer features such as average recall rate per memo card, time spent on difficult topics, and time slot efficiency scores.",
            "status": "pending",
            "testStrategy": "Verify that the data is cleaned, transformed, and feature engineered correctly. Ensure that the data is in the correct format for model training."
          },
          {
            "id": 2,
            "title": "Model Training and Selection",
            "description": "Train a logistic regression model (using `ml-logistic-regression`) on the prepared data to predict exam success. Evaluate different model configurations and select the best performing model.",
            "dependencies": [
              "47.1"
            ],
            "details": "Install the `ml-logistic-regression` library. Split the data into training and testing sets. Train the logistic regression model on the training data. Evaluate the model's performance on the testing data using metrics such as accuracy, precision, recall, and F1-score. Tune the model's hyperparameters to optimize performance. Consider other machine learning models for comparison.",
            "status": "pending",
            "testStrategy": "Evaluate the model's performance on a held-out test dataset. Verify that the model achieves a satisfactory level of accuracy, precision, recall, and F1-score."
          },
          {
            "id": 3,
            "title": "Confidence Score Calibration",
            "description": "Calibrate the confidence scores generated by the logistic regression model to ensure they accurately reflect the probability of exam success.",
            "dependencies": [
              "47.2"
            ],
            "details": "Implement a calibration technique such as Platt scaling or isotonic regression to adjust the confidence scores. Evaluate the calibration performance using metrics such as Brier score or calibration curves.",
            "status": "pending",
            "testStrategy": "Verify that the confidence scores are well-calibrated by comparing the predicted probabilities with the actual exam outcomes. Ensure that the Brier score is minimized and the calibration curves are close to the diagonal."
          },
          {
            "id": 4,
            "title": "Prediction and Integration",
            "description": "Implement the prediction functionality to predict exam success for new users based on their memo card data and learning patterns. Integrate the prediction model into the existing system.",
            "dependencies": [
              "47.3"
            ],
            "details": "Develop an API endpoint that accepts user data as input and returns the predicted exam success probability and confidence score. Integrate the API endpoint into the user interface. Ensure that the prediction functionality is robust and scalable.",
            "status": "pending",
            "testStrategy": "Test the prediction functionality with different user data and verify that the predictions are accurate and the confidence scores are reliable. Ensure that the integration with the existing system is seamless."
          },
          {
            "id": 5,
            "title": "Evaluation and Refinement",
            "description": "Continuously evaluate the performance of the exam success prediction model and refine it based on new data and feedback.",
            "dependencies": [
              "47.4"
            ],
            "details": "Monitor the model's performance over time and identify areas for improvement. Retrain the model with new data to improve its accuracy and generalization ability. Gather feedback from users and incorporate it into the model development process.",
            "status": "pending",
            "testStrategy": "Track the model's performance metrics over time and identify any degradation in performance. Regularly retrain the model with new data and evaluate its performance on a held-out test dataset."
          }
        ]
      },
      {
        "id": 48,
        "title": "Create Personalized Learning Strategies",
        "description": "Create personalized learning strategies based on the exam success prediction.",
        "details": "Based on the exam success prediction, generate personalized learning strategies. Suggest specific memo cards to review. Recommend additional resources. Provide guidance on time management and test-taking strategies.",
        "testStrategy": "Generate learning strategies for different users and verify that the strategies are personalized and relevant to their learning needs and exam success prediction.",
        "priority": "medium",
        "dependencies": [
          47
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze Exam Success Prediction",
            "description": "Analyze the exam success prediction data to identify areas of strength and weakness for each user.",
            "dependencies": [],
            "details": "Examine the output of the exam success prediction model, focusing on identifying specific topics or concepts where the user is predicted to struggle. Quantify the level of risk associated with each area.",
            "status": "pending",
            "testStrategy": "Verify that the analysis accurately reflects the exam success prediction data for a diverse set of users."
          },
          {
            "id": 2,
            "title": "Curate Relevant Memo Cards",
            "description": "Select specific memo cards relevant to the identified areas of weakness.",
            "dependencies": [
              "48.1"
            ],
            "details": "Based on the analysis of exam success prediction, identify memo cards that directly address the user's weaknesses. Prioritize memo cards that cover fundamental concepts and frequently tested topics.",
            "status": "pending",
            "testStrategy": "Ensure that the selected memo cards are directly relevant to the user's identified weaknesses and cover the necessary material."
          },
          {
            "id": 3,
            "title": "Recommend Additional Resources",
            "description": "Recommend additional learning resources to supplement memo card review.",
            "dependencies": [
              "48.1"
            ],
            "details": "Identify relevant textbooks, online tutorials, practice questions, or other learning materials that can help the user strengthen their understanding of the weak areas. Consider resources that offer different learning styles (e.g., visual, auditory, kinesthetic).",
            "status": "pending",
            "testStrategy": "Verify that the recommended resources are appropriate for the user's learning level and address the identified weaknesses."
          },
          {
            "id": 4,
            "title": "Develop Time Management Guidance",
            "description": "Provide guidance on effective time management strategies for exam preparation.",
            "dependencies": [],
            "details": "Create a personalized study schedule that allocates sufficient time to each topic, focusing on areas of weakness. Suggest techniques for prioritizing tasks and avoiding procrastination. Incorporate regular breaks and review sessions.",
            "status": "pending",
            "testStrategy": "Evaluate the effectiveness of the time management guidance by tracking user adherence to the schedule and measuring improvements in study habits."
          },
          {
            "id": 5,
            "title": "Outline Test-Taking Strategies",
            "description": "Provide guidance on effective test-taking strategies to maximize performance.",
            "dependencies": [],
            "details": "Offer advice on how to approach different types of exam questions, manage time during the exam, and avoid common mistakes. Suggest strategies for dealing with test anxiety and maintaining focus.",
            "status": "pending",
            "testStrategy": "Assess the impact of the test-taking strategies on user performance by comparing scores on practice exams before and after implementing the strategies."
          }
        ]
      },
      {
        "id": 49,
        "title": "Implement Metacognitive Learning Coach",
        "description": "Implement a metacognitive learning coach to guide the user's learning process.",
        "details": "Provide feedback on the user's learning strategies. Encourage the user to reflect on their learning process. Help the user identify and overcome learning obstacles. Use techniques from cognitive behavioral therapy (CBT) to promote effective learning habits.",
        "testStrategy": "Provide feedback to different users and verify that the feedback is helpful and relevant to their learning needs.",
        "priority": "low",
        "dependencies": [
          48
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Feedback Mechanism for Learning Strategies",
            "description": "Design the system for providing feedback on the user's learning strategies, including the structure and content of the feedback.",
            "dependencies": [],
            "details": "Define the types of learning strategies to be assessed (e.g., time management, resource utilization, active recall). Design a feedback template that includes positive reinforcement, areas for improvement, and specific suggestions. Consider different feedback delivery methods (e.g., text, visual aids).",
            "status": "pending",
            "testStrategy": "Create sample learning scenarios and generate feedback using the designed mechanism. Evaluate the clarity, relevance, and helpfulness of the feedback."
          },
          {
            "id": 2,
            "title": "Implement Reflection Prompts and Tracking",
            "description": "Implement a system to prompt users to reflect on their learning process and track their reflections.",
            "dependencies": [],
            "details": "Develop a set of reflection prompts covering various aspects of the learning process (e.g., goals, progress, challenges, insights). Implement a mechanism to display these prompts at appropriate intervals. Design a data structure to store user reflections and track their frequency and content.",
            "status": "pending",
            "testStrategy": "Test the reflection prompt display and data storage functionality. Verify that the prompts are displayed correctly and that user reflections are stored accurately."
          },
          {
            "id": 3,
            "title": "Develop Obstacle Identification and Resolution Module",
            "description": "Create a module to help users identify and overcome learning obstacles.",
            "dependencies": [],
            "details": "Develop a questionnaire or interview process to help users identify common learning obstacles (e.g., procrastination, lack of motivation, difficulty understanding concepts). Create a database of potential solutions and resources for each obstacle. Implement a system to match users with relevant solutions based on their identified obstacles.",
            "status": "pending",
            "testStrategy": "Test the obstacle identification and resolution module with sample users. Verify that the module accurately identifies obstacles and provides relevant solutions."
          },
          {
            "id": 4,
            "title": "Integrate CBT Techniques for Effective Learning Habits",
            "description": "Integrate techniques from cognitive behavioral therapy (CBT) to promote effective learning habits.",
            "dependencies": [],
            "details": "Research and select relevant CBT techniques (e.g., goal setting, cognitive restructuring, behavioral activation). Develop modules or exercises that incorporate these techniques into the learning process. Provide guidance and support to users as they implement these techniques.",
            "status": "pending",
            "testStrategy": "Evaluate the effectiveness of the CBT-based modules in promoting positive learning habits. Measure changes in user behavior and attitudes towards learning."
          },
          {
            "id": 5,
            "title": "Implement Metacognitive Coach Integration and Testing",
            "description": "Integrate all the developed modules into a cohesive metacognitive learning coach and perform comprehensive testing.",
            "dependencies": [
              "49.1",
              "49.2",
              "49.3",
              "49.4"
            ],
            "details": "Integrate the feedback mechanism, reflection prompts, obstacle resolution module, and CBT techniques into a unified system. Design a user interface that is intuitive and easy to use. Implement logging and monitoring to track user interactions and identify areas for improvement.",
            "status": "pending",
            "testStrategy": "Conduct user testing with a diverse group of learners. Gather feedback on the usability, effectiveness, and overall satisfaction with the metacognitive learning coach. Iterate on the design based on user feedback."
          }
        ]
      },
      {
        "id": 50,
        "title": "Implement Adaptive Learning Paths",
        "description": "Implement adaptive learning paths based on the user's progress and performance.",
        "details": "Adjust the learning path in real-time based on the user's progress and performance. Provide more challenging material to users who are excelling. Provide additional support to users who are struggling. Use reinforcement learning techniques to optimize the learning path.",
        "testStrategy": "Simulate user progress and performance and verify that the learning path is adapted correctly based on the user's needs.",
        "priority": "medium",
        "dependencies": [
          48
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design the Adaptive Learning Path Algorithm",
            "description": "Design the core algorithm for adapting the learning path based on user performance and progress. Define the metrics for measuring performance (e.g., accuracy, completion time) and the rules for adjusting the difficulty level.",
            "dependencies": [],
            "details": "Research and select appropriate reinforcement learning techniques (e.g., Q-learning, SARSA). Define the state space, action space, and reward function for the reinforcement learning agent. Consider using a hybrid approach combining rule-based and reinforcement learning methods.",
            "status": "pending",
            "testStrategy": "Simulate different user performance scenarios and verify that the algorithm adjusts the learning path accordingly. Evaluate the algorithm's convergence and stability."
          },
          {
            "id": 2,
            "title": "Implement User Performance Tracking",
            "description": "Implement a system for tracking user performance and progress. This includes collecting data on user interactions, such as quiz scores, time spent on each module, and completion rates.",
            "dependencies": [],
            "details": "Design a database schema to store user performance data. Implement API endpoints for recording user activity. Ensure data privacy and security.",
            "status": "pending",
            "testStrategy": "Test the data collection system by simulating user activity and verifying that the data is stored correctly. Verify the accuracy and completeness of the data."
          },
          {
            "id": 3,
            "title": "Integrate Reinforcement Learning Framework",
            "description": "Integrate a reinforcement learning framework into the learning platform. This involves setting up the environment, defining the reward function, and training the agent.",
            "dependencies": [
              "50.1",
              "50.2"
            ],
            "details": "Choose a suitable reinforcement learning library (e.g., TensorFlow, PyTorch). Implement the environment interface for the learning platform. Train the reinforcement learning agent using simulated user data.",
            "status": "pending",
            "testStrategy": "Evaluate the performance of the reinforcement learning agent on a validation set of user data. Verify that the agent is learning to optimize the learning path."
          },
          {
            "id": 4,
            "title": "Develop Content Difficulty Adjustment Mechanism",
            "description": "Develop a mechanism for adjusting the difficulty level of the learning content based on the user's performance and the recommendations of the reinforcement learning agent.",
            "dependencies": [
              "50.1",
              "50.3"
            ],
            "details": "Implement a system for categorizing learning content by difficulty level. Develop algorithms for selecting appropriate content based on user performance and agent recommendations. Consider using content tagging and metadata to facilitate content selection.",
            "status": "pending",
            "testStrategy": "Test the content difficulty adjustment mechanism by simulating different user performance scenarios and verifying that the appropriate content is selected. Evaluate the effectiveness of the content selection algorithm."
          },
          {
            "id": 5,
            "title": "Implement A/B Testing for Learning Paths",
            "description": "Implement A/B testing to compare different learning paths and optimize the adaptive learning system. This involves creating different versions of the learning path and randomly assigning users to each version.",
            "dependencies": [
              "50.1",
              "50.2",
              "50.3",
              "50.4"
            ],
            "details": "Design the A/B testing framework. Implement a system for randomly assigning users to different learning path versions. Collect data on user performance for each version. Analyze the data to identify the best-performing learning path.",
            "status": "pending",
            "testStrategy": "Run A/B tests with different learning path configurations. Analyze the results to identify the optimal learning path. Continuously monitor and optimize the learning path based on A/B testing results."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-03T06:06:27.263Z",
      "updated": "2025-08-04T13:08:53.049Z",
      "description": "Tasks for rich-text-editor context"
    }
  },
  "ai-learning-diagnostician": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement MongoDB Atlas Vector Search with OpenAI Embeddings",
        "description": "Configure MongoDB Atlas Vector Search to enable semantic search capabilities using OpenAI Embeddings API.",
        "details": "1. **Set up MongoDB Atlas Cluster:** Ensure an Atlas cluster is provisioned. Choose a suitable tier based on anticipated data volume and query load. Enable Atlas Search during cluster creation.\n2. **Create a Vector Search Index:** Define a new Atlas Search index with the `vectorType` set to 'denseVector'. Configure the `fields` array to include the field containing the OpenAI embeddings. Specify the `dimensions` to match the embedding vector size (e.g., 1536 for `text-embedding-ada-002`).\n3. **Generate OpenAI Embeddings:** Use the OpenAI Embeddings API (`text-embedding-ada-002` model is recommended for cost-effectiveness and performance) to generate vector embeddings for the text data to be indexed.  Handle API rate limits gracefully using exponential backoff.\n4. **Store Embeddings in MongoDB:** Store the generated embeddings in the designated MongoDB collection. Ensure the embedding vectors are stored as arrays of floating-point numbers.\n5. **Implement Semantic Search Query:** Construct an aggregation pipeline that uses the `$vectorSearch` operator to perform semantic similarity search.  Specify the `index` name, `path` to the embedding field, `queryVector` (embedding of the search query generated using OpenAI), `numCandidates` (number of documents to consider), and `limit` (number of results to return).\n6. **Optimize for Performance:** Monitor query performance and adjust the `numCandidates` parameter to balance recall and latency. Consider using pre-filtering techniques to reduce the search space.\n7. **Error Handling and Logging:** Implement robust error handling to catch potential issues with the OpenAI API, Atlas Search, and data processing. Log relevant information for debugging and monitoring.\n8. **Security Considerations:** Secure the OpenAI API key and MongoDB Atlas credentials using environment variables or a secrets management system. Implement appropriate access control measures to protect sensitive data.",
        "testStrategy": "1. **Index Creation Verification:** Verify that the Atlas Search index is created successfully with the correct configuration (vector type, dimensions, fields).\n2. **Embedding Generation and Storage:** Confirm that OpenAI embeddings are generated correctly and stored in MongoDB as arrays of floating-point numbers.\n3. **Semantic Search Accuracy:** Test the semantic search functionality with a variety of queries. Evaluate the relevance of the search results based on semantic similarity, not just keyword matching. Use a ground truth dataset to measure precision and recall.\n4. **Performance Testing:** Measure the query latency for different query types and data volumes. Ensure that the performance meets the required SLAs.  Test with concurrent users to assess scalability.\n5. **Error Handling Validation:** Simulate error conditions (e.g., OpenAI API errors, invalid data) and verify that the application handles them gracefully and logs appropriate error messages.\n6. **Security Audit:** Review the code and configuration to ensure that API keys and database credentials are not exposed and that access control is properly implemented.",
        "status": "done",
        "dependencies": [
          6,
          7
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Provision MongoDB Atlas Cluster and Enable Atlas Search",
            "description": "Set up a MongoDB Atlas cluster with an appropriate tier and enable Atlas Search during the cluster creation process.",
            "dependencies": [],
            "details": "Choose a suitable Atlas cluster tier based on anticipated data volume and query load. Ensure Atlas Search is enabled during cluster creation.",
            "status": "done",
            "testStrategy": "Verify that the Atlas cluster is successfully provisioned and Atlas Search is enabled."
          },
          {
            "id": 2,
            "title": "Create Vector Search Index in Atlas",
            "description": "Define a new Atlas Search index with the correct vector type, fields, and dimensions to store OpenAI embeddings.",
            "dependencies": [],
            "details": "Create an Atlas Search index with `vectorType` set to 'denseVector'. Configure the `fields` array to include the field containing the OpenAI embeddings. Specify the `dimensions` to match the embedding vector size (e.g., 1536).",
            "status": "done",
            "testStrategy": "Verify that the Atlas Search index is created successfully with the correct configuration (vector type, dimensions, fields)."
          },
          {
            "id": 3,
            "title": "Generate and Store OpenAI Embeddings",
            "description": "Use the OpenAI Embeddings API to generate vector embeddings for the text data and store them in MongoDB.",
            "dependencies": [],
            "details": "Use the OpenAI Embeddings API (`text-embedding-ada-002` model recommended) to generate vector embeddings. Handle API rate limits gracefully. Store the embeddings in the designated MongoDB collection as arrays of floating-point numbers.",
            "status": "done",
            "testStrategy": "Confirm that OpenAI embeddings are generated correctly and stored in MongoDB as arrays of floating-point numbers. Verify rate limit handling."
          },
          {
            "id": 4,
            "title": "Implement Semantic Search Query with $vectorSearch",
            "description": "Construct an aggregation pipeline that uses the `$vectorSearch` operator to perform semantic similarity search.",
            "dependencies": [],
            "details": "Construct an aggregation pipeline using `$vectorSearch`. Specify the `index` name, `path` to the embedding field, `queryVector` (embedding of the search query), `numCandidates`, and `limit`.",
            "status": "done",
            "testStrategy": "Verify that the semantic search query returns relevant results based on the similarity between the query vector and the stored embeddings."
          },
          {
            "id": 5,
            "title": "Implement Error Handling, Logging, and Security",
            "description": "Implement robust error handling, logging, and security measures for the application.",
            "dependencies": [],
            "details": "Implement error handling for OpenAI API, Atlas Search, and data processing. Log relevant information. Secure the OpenAI API key and MongoDB Atlas credentials using environment variables or a secrets management system. Implement access control.",
            "status": "done",
            "testStrategy": "Test error handling by simulating API failures and data processing errors. Verify that errors are logged correctly. Confirm that API keys and credentials are secure."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Hybrid Search: Keyword + Vector",
        "description": "Implement hybrid search by combining keyword and vector search to improve search result accuracy and relevance.",
        "details": "1.  **Design Hybrid Search Strategy:** Determine the optimal weighting and combination method for keyword and vector search results. Consider using a weighted ranking system or a reciprocal rank fusion approach.\n2.  **Implement Keyword Search:** Integrate existing keyword search functionality (e.g., using MongoDB Atlas Search with text indexing) into the hybrid search pipeline. Ensure keyword search queries are properly constructed and executed.\n3.  **Implement Vector Search:** Utilize the MongoDB Atlas Vector Search functionality (as implemented in Task 1) to perform semantic similarity searches based on user query embeddings.\n4.  **Combine Search Results:** Develop a mechanism to merge and rank the results from keyword and vector searches. This may involve normalizing scores, applying weights, and deduplicating results.\n5.  **Optimize Performance:** Evaluate and optimize the performance of the hybrid search implementation. Consider caching strategies, query optimization techniques, and indexing strategies to minimize latency and maximize throughput.\n6.  **Error Handling:** Implement robust error handling to gracefully handle failures in either the keyword or vector search components. Ensure that errors are logged and reported appropriately.",
        "testStrategy": "1.  **Relevance Testing:** Evaluate the relevance of hybrid search results compared to keyword-only and vector-only search results. Use a set of test queries with known relevant documents to assess the accuracy and ranking of results.\n2.  **Performance Testing:** Measure the query latency and throughput of the hybrid search implementation under various load conditions. Ensure that performance meets acceptable levels.\n3.  **Weighting Adjustment:** Experiment with different weighting schemes for keyword and vector search results to optimize relevance and ranking. Use A/B testing or other evaluation methods to determine the best weighting configuration.\n4.  **Edge Case Testing:** Test the hybrid search implementation with edge cases, such as queries with ambiguous keywords, queries with no matching keywords, and queries with multiple intents.\n5.  **Integration Testing:** Verify that the hybrid search implementation integrates seamlessly with other components of the search system, such as the user interface and the data indexing pipeline.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Document Hybrid Search Strategy",
            "description": "Define the weighting and combination method for keyword and vector search results. Document the chosen strategy, including the rationale behind the selection (e.g., weighted ranking, reciprocal rank fusion).",
            "dependencies": [],
            "details": "Research and compare different hybrid search strategies (weighted ranking, reciprocal rank fusion, etc.). Determine the optimal weights for keyword and vector search based on the specific dataset and search requirements. Document the chosen strategy, including the rationale and any parameters.",
            "status": "done",
            "testStrategy": "Evaluate the performance of the chosen strategy using a set of test queries and compare it to other strategies. Measure the precision and recall of the hybrid search results."
          },
          {
            "id": 2,
            "title": "Implement Keyword Search Integration",
            "description": "Integrate the existing keyword search functionality (MongoDB Atlas Search) into the hybrid search pipeline. Ensure proper query construction and execution.",
            "dependencies": [],
            "details": "Configure MongoDB Atlas Search with appropriate text indexing. Develop code to construct and execute keyword search queries based on user input. Handle potential errors during query execution.",
            "status": "done",
            "testStrategy": "Verify that keyword search queries are executed correctly and return relevant results. Measure the query latency and throughput of the keyword search component."
          },
          {
            "id": 3,
            "title": "Implement Vector Search Integration",
            "description": "Integrate MongoDB Atlas Vector Search (from Task 1) into the hybrid search pipeline to perform semantic similarity searches.",
            "dependencies": [],
            "details": "Utilize the MongoDB Atlas Vector Search functionality to perform semantic similarity searches based on user query embeddings. Ensure that the query embeddings are generated correctly and used to query the vector index.",
            "status": "done",
            "testStrategy": "Verify that vector search queries are executed correctly and return relevant results based on semantic similarity. Measure the query latency and throughput of the vector search component."
          },
          {
            "id": 4,
            "title": "Develop Result Combination and Ranking Mechanism",
            "description": "Develop a mechanism to merge and rank the results from keyword and vector searches, including normalization, weighting, and deduplication.",
            "dependencies": [
              "2.1",
              "2.2",
              "2.3"
            ],
            "details": "Implement a function to combine the results from keyword and vector searches. Normalize the scores from each search component. Apply the weights defined in the hybrid search strategy. Deduplicate any overlapping results. Rank the combined results based on the weighted scores.",
            "status": "done",
            "testStrategy": "Evaluate the ranking of the combined results using a set of test queries. Verify that the relevant documents are ranked higher than irrelevant documents. Measure the impact of different weighting schemes on the ranking of results."
          },
          {
            "id": 5,
            "title": "Optimize and Test Hybrid Search Performance and Error Handling",
            "description": "Evaluate and optimize the performance of the hybrid search implementation. Implement robust error handling and logging.",
            "dependencies": [
              "2.4"
            ],
            "details": "Implement caching strategies to reduce query latency. Optimize query execution plans. Implement error handling to gracefully handle failures in either the keyword or vector search components. Log errors and performance metrics for monitoring and debugging.\n<info added on 2025-08-04T13:38:01.163Z>\n하이브리드 검색 구현 상태 분석:\n\n**현재 구현된 부분:**\n1. HybridSearchService - 완전히 구현됨 (키워드 + 벡터 검색 결합)\n2. ResultCombinerService - 완전히 구현됨 (가중치 기반, RRF, 하이브리드 전략)\n3. 하이브리드 검색 전략 문서 - 완성됨\n4. 캐싱 및 에러 처리 - 구현됨\n\n**누락된 부분:**\n1. MemoSearchController에서 하이브리드 검색 사용하지 않음\n2. API 라우트에서 하이브리드 검색 엔드포인트 없음\n3. 프론트엔드에서 하이브리드 검색 호출하는 부분 없음\n\n**다음 단계:**\n1. MemoSearchController에 하이브리드 검색 통합\n2. API 라우트 업데이트\n3. 프론트엔드에서 하이브리드 검색 사용하도록 수정\n</info added on 2025-08-04T13:38:01.163Z>\n<info added on 2025-08-04T13:39:17.454Z>\n하이브리드 검색 구현 완료 상태:\n\n**완료된 작업:**\n1. ✅ HybridSearchService - 완전히 구현됨\n2. ✅ ResultCombinerService - 완전히 구현됨  \n3. ✅ MemoSearchController - 하이브리드 검색으로 업데이트됨\n4. ✅ API 라우트 - 기존 라우트가 업데이트된 컨트롤러 사용\n5. ✅ 하이브리드 검색 전략 문서 - 완성됨\n\n**현재 상태:**\n- 백엔드에서 하이브리드 검색이 완전히 구현되어 있음\n- 프론트엔드에서는 아직 하이브리드 검색 API를 직접 호출하는 부분이 없음 (대부분 클라이언트 사이드 필터링 사용)\n- 하이브리드 검색은 API 엔드포인트를 통해 사용 가능한 상태\n\n**다음 단계:**\n1. 하이브리드 검색 API 테스트\n2. 성능 최적화 및 에러 처리 검증\n3. 필요시 프론트엔드에서 하이브리드 검색 사용하도록 수정\n</info added on 2025-08-04T13:39:17.454Z>",
            "status": "done",
            "testStrategy": "Measure the query latency and throughput of the hybrid search implementation. Test the error handling mechanisms by simulating failures in the keyword and vector search components. Monitor the logs for errors and performance issues."
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement AI Chat Feature for Hybrid Search",
        "description": "Implement an AI chat feature for the hybrid search system, enabling AI-driven conversations using search results as context. This includes multi-LLM support, a recommendation query system, and chat storage and management.",
        "details": "1.  **Design AI Chat Interface:** Develop a user-friendly interface for interacting with the AI chat feature. This should include input fields for user queries, display areas for AI responses, and options for selecting different LLMs.\n2.  **Implement Contextualization of Search Results:** Modify the search result processing to provide relevant context to the AI chat system. This may involve extracting key information from search results and formatting it for the LLM.\n3.  **Integrate Multiple LLMs:** Implement support for multiple LLMs, allowing users to select the desired LLM for their chat sessions. This will require an abstraction layer to handle different LLM APIs and response formats.\n4.  **Develop Recommendation Query System:** Implement a system that suggests relevant queries to the user based on the current search context and chat history. This can be achieved using techniques like query expansion or collaborative filtering.\n5.  **Implement Chat Storage and Management:** Design a database schema to store chat logs, including user queries, AI responses, timestamps, and LLM selections. Implement functionality for retrieving, searching, and managing chat history.\n6.  **Secure API Integration:** Ensure secure integration with LLM APIs, handling authentication, authorization, and rate limiting appropriately.\n7.  **Error Handling and Logging:** Implement robust error handling and logging mechanisms to track issues and ensure system stability.",
        "testStrategy": "1.  **Functional Testing:** Verify that the AI chat feature correctly integrates with the hybrid search system and provides relevant responses based on search results.\n2.  **LLM Performance Testing:** Evaluate the performance of different LLMs in terms of response quality, speed, and accuracy. Compare the responses of different LLMs for the same queries and contexts.\n3.  **Recommendation Query Testing:** Test the accuracy and relevance of the recommendation query system. Ensure that suggested queries are related to the current search context and user intent.\n4.  **Chat Storage and Management Testing:** Verify that chat logs are stored correctly and can be retrieved, searched, and managed efficiently.\n5.  **Security Testing:** Conduct security testing to identify and address potential vulnerabilities in the API integration and data storage.\n6.  **Performance Testing:** Measure the response time of the AI chat feature under different load conditions. Optimize the system for scalability and performance.",
        "status": "pending",
        "dependencies": [
          1,
          2
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement AI Chat Interface",
            "description": "Develop a user-friendly interface for interacting with the AI chat feature, including input fields, display areas, and LLM selection options.",
            "dependencies": [],
            "details": "Design the UI/UX for the chat interface. Implement input field for user queries. Implement display area for AI responses. Add options for selecting different LLMs. Ensure responsiveness and accessibility.\n<info added on 2025-08-04T14:07:42.163Z>\n**Core Design Principles (2024 Latest Trends):**\n\n1. **Clarity and Transparency**: Clearly indicate to users that they are interacting with AI.\n2. **Context Awareness**: Maintain context throughout the conversation (previous queries, user preferences, search results).\n3. **Control and Customization**: Provide users with options to control AI behavior.\n4. **Error Handling and Fallback Mechanisms**: Provide clear error messages and alternatives.\n5. **Accessibility**: Adhere to WCAG guidelines.\n\n**Design Patterns:**\n\n1. **Conversational Search Box**: Input field for natural language questions.\n2. **Search Result Summarization and Contextualization**: AI summarizes search results and provides context.\n3. **Follow-up Question Generation**: AI suggests helpful follow-up questions.\n4. **Citation and Source Display**: Clearly display the source of information.\n5. **Multi-Turn Conversation Management**: Manage session-based conversation history.\n6. **Recommended Query System**: Suggest related queries based on the current conversation and search results.\n\n**Leveraging Hybrid Search:**\n- Perform initial search with keyword search.\n- Refine results through semantic understanding with vector search.\n- Contextualize and summarize with LLM.\n\n**Multi-LLM Support:**\n- Enable LLM switching with an abstraction layer.\n- Monitor and optimize performance.\n- Provide user selection options.\n\n**Implementation Considerations:**\n- Optimize MongoDB Atlas vector search index.\n- Use data modeling for efficient storage and retrieval.\n- Consider scalability and security.\n</info added on 2025-08-04T14:07:42.163Z>\n<info added on 2025-08-04T14:18:26.516Z>\nAI 채팅 인터페이스 설계 및 구현 완료:\n\n**구현된 기능:**\n\n1. **AIChatInterface 컴포넌트** - 완전한 AI 채팅 인터페이스\n   - 다중 LLM 지원 (ChatGPT, Claude, Gemini)\n   - 사용자 API 키 입력 및 관리\n   - 실시간 메시지 전송 및 응답\n   - 추천 쿼리 시스템 (Perplexity 스타일)\n   - 채팅 복사 및 저장 기능\n\n2. **HybridSearchModal 통합** - 기존 검색 모달에 AI 채팅 통합\n   - 검색 결과 아래 \"AI와 대화하기\" 버튼 추가\n   - 검색 모드와 AI 채팅 모드 간 전환\n   - 검색 결과를 AI 컨텍스트로 자동 전달\n\n3. **사용자 경험 개선**\n   - 직관적인 UI/UX 디자인\n   - 키보드 네비게이션 지원 (Enter 키로 메시지 전송)\n   - 자동 스크롤 및 로딩 상태 표시\n   - 접근성 고려 (ARIA 라벨, 시맨틱 HTML)\n\n4. **기술적 구현**\n   - TypeScript 타입 안전성\n   - React Hooks 기반 상태 관리\n   - 에러 처리 및 폴백 메커니즘\n   - 반응형 디자인\n\n**다음 단계:** 백엔드 API 엔드포인트 구현이 필요합니다.\n</info added on 2025-08-04T14:18:26.516Z>",
            "status": "done",
            "testStrategy": "Verify the interface is user-friendly and intuitive. Test input fields, display areas, and LLM selection options. Ensure the interface is responsive across different devices and browsers."
          },
          {
            "id": 2,
            "title": "Contextualize Search Results for AI Chat",
            "description": "Modify search result processing to provide relevant context to the AI chat system by extracting and formatting key information for the LLM.",
            "dependencies": [],
            "details": "Implement logic to extract key information from search results. Format the extracted information into a suitable format for the LLM (e.g., JSON, text). Implement a mechanism to pass the formatted context to the AI chat system.",
            "status": "done",
            "testStrategy": "Verify that key information is extracted accurately from search results. Test different formatting options to determine the optimal format for the LLM. Ensure the context is passed correctly to the AI chat system."
          },
          {
            "id": 3,
            "title": "Integrate and Manage Multiple LLMs",
            "description": "Implement support for multiple LLMs, including an abstraction layer to handle different LLM APIs and response formats.",
            "dependencies": [],
            "details": "Implement an abstraction layer to handle different LLM APIs. Implement logic to select the desired LLM for chat sessions. Handle different LLM response formats. Implement error handling for LLM API calls.",
            "status": "done",
            "testStrategy": "Test integration with multiple LLMs. Verify that the abstraction layer handles different LLM APIs correctly. Test LLM selection functionality. Ensure error handling is robust."
          },
          {
            "id": 4,
            "title": "Develop Recommendation Query System",
            "description": "Implement a system that suggests relevant queries to the user based on the current search context and chat history.",
            "dependencies": [],
            "details": "Implement logic to analyze the current search context and chat history. Use techniques like query expansion or collaborative filtering to generate query suggestions. Display the query suggestions to the user.\n<info added on 2025-08-04T14:08:03.366Z>\n**Recommendation Query System Design Patterns (2024 Latest Trends):**\n\n1. **Personalized Query Expansion**: Expand queries based on user's past behavior, preferences, and context information.\n2. **Semantic Similarity Matching**: Match based on semantic understanding even without exact keyword matching.\n3. **Context-Based Bandit**: Dynamically adjust recommendations based on user feedback and context information.\n4. **Multi-Armed Bandit**: Balance between new recommendations and known good recommendations.\n5. **Explainable Recommendations**: Provide explanations for why a specific item was recommended.\n\n**Best Practices for Perplexity, Claude, and ChatGPT Interfaces:**\n\n**Perplexity Style:**\n- Provide concise and informative answers.\n- Utilize explanation generation for recommendations.\n- Example: \"Since you asked about calculus formulas, 'applications of differential formulas' or 'integration techniques' may also be helpful.\"\n\n**Claude Style:**\n- Leverage strong reasoning and conversational abilities.\n- Refine preferences through dialogue with the user.\n- Example: \"I see you're interested in calculus. What part is the most difficult for you? Is it basic concepts or application problems?\"\n\n**ChatGPT Style:**\n- Generate creative and engaging content.\n- Create personalized explanations, reviews, and stories.\n- Example: \"Think of calculus as climbing a mountain. 'Differentiation' is measuring the slope, and 'integration' is calculating the total distance.\"\n\n**Implementation Considerations:**\n\n1. **Embedding Generation**: Use the text-embedding-ada-002 model, normalized unit length embeddings.\n2. **Index Optimization**: hnsw index type, parameter tuning (m, efConstruction).\n3. **Query Optimization**: Use the $vectorSearch operator, reduce latency with caching.\n4. **Scalability**: Distribute data with sharding, load balancing.\n\n**MongoDB Atlas Vector Search Integration:**\n- Generate embeddings for both user queries and item descriptions.\n- Use cosine similarity or other distance metrics.\n- Reflect changes with regular embedding updates.\n\n**Potential Issues and Mitigation Strategies:**\n- Cold Start Problem: Provide initial recommendations with content-based filtering.\n- Data Sparsity: Utilize collaborative filtering techniques.\n- Bias: Mitigate bias with data analysis and re-weighting techniques.\n- Scalability Issues: Utilize distributed computing frameworks.\n</info added on 2025-08-04T14:08:03.366Z>",
            "status": "done",
            "testStrategy": "Test the accuracy and relevance of query suggestions. Evaluate different query expansion and collaborative filtering techniques. Ensure the query suggestions are displayed in a user-friendly manner."
          },
          {
            "id": 5,
            "title": "Implement Chat Storage and Management",
            "description": "Design a database schema to store chat logs and implement functionality for retrieving, searching, and managing chat history.",
            "dependencies": [],
            "details": "Design a database schema to store chat logs (user queries, AI responses, timestamps, LLM selections). Implement functionality for retrieving chat history. Implement search functionality for chat history. Implement management functionality (e.g., deleting chat logs).\n<info added on 2025-08-04T14:08:30.948Z>\n**Update chat storage and management system design strategy based on the latest information collected through web search:**\n\n**Optimize MongoDB Schema Design (2024 Latest Trends):**\n\n**Recommended Schema: Separate \"conversations\" and \"messages\" collections**\n\n**conversations Collection:**\n```json\n{\n  \"_id\": ObjectId(),\n  \"participants\": [ObjectId], // Array of user IDs\n  \"createdAt\": ISODate(),\n  \"updatedAt\": ISODate(),\n  \"metadata\": {\n    \"name\": String,          // Conversation name\n    \"type\": String,          // Conversation type (private, group)\n    \"searchContext\": {       // Search context\n      \"query\": String,\n      \"results\": [ObjectId], // IDs of searched memos\n      \"filters\": Object\n    }\n  }\n}\n```\n\n**messages Collection:**\n```json\n{\n  \"_id\": ObjectId(),\n  \"conversationId\": ObjectId(), // Reference to conversations collection\n  \"senderId\": ObjectId(),\n  \"timestamp\": ISODate(),\n  \"content\": String,\n  \"contentType\": String, // text, image, video\n  \"embedding\": [Number], // OpenAI embedding (for vector search)\n  \"keywords\": [String],   // Keywords (for keyword search)\n  \"metadata\": {\n    \"location\": {\n      \"type\": \"Point\",\n      \"coordinates\": [Number, Number]\n    },\n    \"mentions\": [ObjectId], // IDs of mentioned users\n    \"llmModel\": String,     // LLM model used\n    \"searchScore\": Number   // Search relevance score\n  }\n}\n```\n\n**Indexing Strategy:**\n\n**messages Collection:**\n- `{ conversationId: 1, timestamp: -1 }`: Retrieve conversation history in chronological order\n- `{ senderId: 1, timestamp: -1 }`: Retrieve messages from a specific user\n- `{ embedding: \"vector\" }`: Atlas Search index for vector search\n- `{ keywords: \"text\" }`: Atlas Search index for keyword search\n- `{ \"metadata.location\": \"2dsphere\" }`: For geospatial queries\n\n**conversations Collection:**\n- `{ participants: 1 }`: Retrieve conversations for a user\n- `{ updatedAt: -1 }`: Display recent conversations\n\n**Hybrid Search Integration:**\n- Store Embeddings: Store OpenAI embeddings in the embedding field\n- Store Keywords: Store keywords extracted from message content in the keywords field\n- Hybrid Search Query: Combine keyword search and vector search\n\n**Additional Best Practices:**\n- Data Validation: Utilize MongoDB schema validation\n- Data Archiving: Archive old messages to a separate collection\n- Security: Implement encryption, RBAC, and access control\n- Monitoring: Utilize MongoDB Atlas monitoring tools\n- TTL Index: Consider TTL index for automatic message deletion\n\n**Project Task Relevance:**\n- Task 1: Create Atlas Search vector index and store embeddings\n- Task 2: Combine keyword and vector search for hybrid search\n- Task 3: Design schema for chat storage and management\n</info added on 2025-08-04T14:08:30.948Z>",
            "status": "done",
            "testStrategy": "Verify that chat logs are stored correctly in the database. Test retrieving, searching, and managing chat history. Ensure data security and privacy."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-04T13:09:44.245Z",
      "updated": "2025-08-04T14:32:21.177Z",
      "description": "AI 학습 진단사 - 수험생 특화 메모카드 검색 시스템 개발"
    }
  }
}