{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Dependency Installation",
        "description": "Set up the React/Next.js project environment with Tailwind CSS, ensuring compatibility with existing TSNoteCard component and react-pdf library.",
        "details": "1.  Verify Node.js and npm are installed (>=18.x and >=8.x respectively).\n2.  Initialize a new Next.js project or navigate to the existing project directory.\n3.  Install Tailwind CSS and its dependencies: `npm install -D tailwindcss postcss autoprefixer`\n4.  Configure Tailwind CSS by running `npx tailwindcss init -p` and updating `tailwind.config.js` with necessary configurations.\n5.  Install `react-pdf` library: `npm install react-pdf`\n6.  Verify that the TSNoteCard component is correctly set up and styled.\n7.  Address any compatibility issues between Tailwind CSS and existing styles.\n8.  Create necessary folders and files for components and utilities.",
        "testStrategy": "1.  Run the development server (`npm run dev`) and ensure the application compiles without errors.\n2.  Verify that Tailwind CSS styles are applied correctly.\n3.  Check that the TSNoteCard component renders as expected.\n4.  Ensure `react-pdf` is installed correctly and can be imported.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement View Mode State Management",
        "description": "Implement the view mode state management using React's useState hook, including the 'grid' and 'more' modes.",
        "details": "1.  In the main dashboard component, declare a state variable `viewMode` using `useState('grid')`.\n2.  Create a function `setViewMode` to update the `viewMode` state.\n3.  Pass the `viewMode` state and `setViewMode` function to the relevant components.\n4.  Implement logic to switch between 'grid' and 'more' modes based on user interaction (e.g., button click).\n5.  Ensure the initial state is set to 'grid'.",
        "testStrategy": "1.  Verify that the `viewMode` state is initialized correctly.\n2.  Test the functionality to switch between 'grid' and 'more' modes.\n3.  Ensure that the UI updates correctly when the `viewMode` changes.\n4.  Check for any unexpected side effects when updating the state.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Memo Card Loading and '더보기' Functionality",
        "description": "Modify the dashboard to initially load only the recent 3 memo cards in 'grid' mode and implement the '더보기' (more) button functionality to load all memo cards.",
        "details": "1.  Fetch the initial 3 memo cards and store them in a state variable `recentMemos`.\n2.  Display `recentMemos` in a 3-column grid layout when `viewMode` is 'grid'.\n3.  Implement an API call to fetch all memo cards when the '더보기' button is clicked.\n4.  Store all memo cards in a state variable `allMemos`.\n5.  Update the UI to display `allMemos` in a 6-column grid layout when `viewMode` is 'more'.\n6.  Implement error handling for the API call.",
        "testStrategy": "1.  Verify that only 3 memo cards are loaded initially in 'grid' mode.\n2.  Test the '더보기' button to ensure all memo cards are loaded and displayed in 'more' mode.\n3.  Check for correct grid layout in both 'grid' and 'more' modes.\n4.  Test error handling for API call failures.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement UI Components for Grid and More Views",
        "description": "Implement the UI components for both Grid and More views, ensuring the correct layout and styling.",
        "details": "1.  Create a `GridView` component to display memo cards in a 3-column grid layout.\n2.  Create a `MoreView` component to display memo cards in a 6-column grid layout.\n3.  Use Tailwind CSS to style the components, ensuring responsiveness.\n4.  Implement smaller card sizes in `MoreView`.\n5.  Ensure the `TSNoteCard` component is reused in both views.",
        "testStrategy": "1.  Verify that the `GridView` component displays memo cards in a 3-column grid.\n2.  Verify that the `MoreView` component displays memo cards in a 6-column grid.\n3.  Check for correct styling and responsiveness in both views.\n4.  Ensure that the `TSNoteCard` component is rendered correctly in both views.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Hover Animation",
        "description": "Add hover animation to the memo cards in the 'more' view using Tailwind CSS.",
        "details": "1.  Add the `hover:scale-110` class to the `TSNoteCard` component in the `MoreView`.\n2.  Add the `transition-all duration-300 ease-out` class to the `TSNoteCard` component to ensure a smooth animation.\n3.  Test the hover animation to ensure it scales the card up smoothly.",
        "testStrategy": "1.  Verify that the memo cards scale up on hover in the `MoreView`.\n2.  Check that the animation is smooth and lasts for 300ms.\n3.  Ensure that the animation does not cause any layout shifts.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Continuous Vertical Scrolling in PDF Viewer",
        "description": "Modify PdfViewer.tsx to enable continuous vertical scrolling, stacking all pages vertically.",
        "details": "1.  Modify the `PdfViewer.tsx` component to render all pages of the PDF in a vertical stack.\n2.  Remove the existing page navigation buttons.\n3.  Adjust the container height and styles to accommodate the continuous scroll.\n4.  Ensure the existing props interface is maintained.",
        "testStrategy": "1.  Verify that all pages are rendered in a vertical stack.\n2.  Check that the page navigation buttons are removed.\n3.  Ensure the container height and styles are adjusted correctly.\n4.  Test that the existing props interface is maintained.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Lazy Loading with IntersectionObserver",
        "description": "Implement lazy loading using IntersectionObserver to optimize performance for large PDFs.",
        "details": "1.  Use `IntersectionObserver` to detect when a page enters the viewport.\n2.  Only render pages that are currently in or near the viewport.\n3.  Implement a placeholder for pages that are not yet rendered.\n4.  Optimize memory usage by unloading pages that are far from the viewport.",
        "testStrategy": "1.  Verify that only pages in or near the viewport are rendered.\n2.  Check that placeholders are displayed for pages that are not yet rendered.\n3.  Monitor memory usage to ensure it is optimized.\n4.  Test scrolling performance with large PDFs (100+ pages).",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Scroll-Based Page Tracking and Control Bar Synchronization",
        "description": "Implement scroll-based page tracking and synchronize it with the control bar, ensuring compatibility with existing highlight and text selection features.",
        "details": "1.  Use the `IntersectionObserver` to track the currently visible page based on scroll position.\n2.  Update the control bar to reflect the current page number.\n3.  Ensure that the highlight overlay and text selection features continue to function correctly.\n4.  Maintain compatibility with existing zoom and rotation features.",
        "testStrategy": "1.  Verify that the control bar updates correctly as the user scrolls.\n2.  Check that the highlight overlay and text selection features continue to function correctly.\n3.  Ensure compatibility with existing zoom and rotation features.\n4.  Test with various PDF documents to ensure consistent behavior.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement IntersectionObserver-based Page Tracking",
            "description": "Set up IntersectionObserver to track which page is currently in view based on scroll position. Determine the logic for identifying the 'current' page when multiple pages are partially visible.",
            "dependencies": [],
            "details": "Use IntersectionObserver API to monitor the visibility of each page element. Define a threshold for determining when a page is considered 'in view'. Handle edge cases where multiple pages are partially visible.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Control Bar Update Logic",
            "description": "Develop the logic to update the control bar with the current page information based on the output from the IntersectionObserver. Ensure the control bar accurately reflects the currently viewed page.",
            "dependencies": [
              1
            ],
            "details": "Create a function that receives the current page information from the IntersectionObserver and updates the control bar's page number display. Handle cases where no page is in view (e.g., at the very beginning or end of the document).",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Ensure Compatibility with Highlight and Text Selection",
            "description": "Test and ensure that the scroll-based page tracking and control bar synchronization do not interfere with existing highlight and text selection functionalities. Address any conflicts that arise.",
            "dependencies": [
              1,
              2
            ],
            "details": "Test highlighting and text selection on different pages after implementing the scroll-based tracking. Identify and resolve any issues where the tracking logic prevents or disrupts highlighting or text selection.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Ensure Compatibility with Zoom and Rotation",
            "description": "Test and ensure that the scroll-based page tracking and control bar synchronization remain accurate and functional when the document is zoomed in/out or rotated. Adjust the IntersectionObserver thresholds or logic as needed.",
            "dependencies": [
              1,
              2
            ],
            "details": "Test the page tracking and control bar updates at different zoom levels and rotations. Adjust the IntersectionObserver's thresholds or the page detection logic to maintain accuracy under these conditions.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-07T08:48:57.524Z",
      "updated": "2025-07-07T08:49:24.607Z",
      "description": "Tasks for pdf-scroll-feature context"
    }
  },
  "pdf-knowledge-capture": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement PDF Upload API and Update Book Model",
        "description": "Extend the Book model with pdfUrl and pdfFileSize fields and implement an API endpoint for uploading PDF files to cloud storage, including server-side validation.",
        "details": "1.  Modify the Book model in the database schema to include the `pdfUrl` (string) and `pdfFileSize` (integer) fields.\n2.  Implement a new API endpoint `/books/{bookId}/upload-pdf` that accepts a PDF file as input.\n3.  Implement server-side validation to check the file format (must be PDF) and file size (must be less than 20MB).\n4.  Upon successful validation, upload the PDF file to cloud storage (e.g., AWS S3, Google Cloud Storage, or Azure Blob Storage).\n5.  Store the URL of the uploaded PDF file in the `pdfUrl` field of the Book model.\n6.  Store the size of the uploaded PDF file in the `pdfFileSize` field of the Book model.\n7.  Return a success response with the updated Book model.\n8.  Handle potential errors such as invalid file format, file size exceeding the limit, and cloud storage upload failures, returning appropriate error responses.",
        "testStrategy": "1.  Create a test PDF file.\n2.  Send a POST request to the `/books/{bookId}/upload-pdf` endpoint with the test PDF file.\n3.  Verify that the API returns a success response with the updated Book model, including the `pdfUrl` and `pdfFileSize` fields.\n4.  Verify that the PDF file is successfully uploaded to cloud storage.\n5.  Verify that the `pdfUrl` field in the Book model contains the correct URL of the uploaded PDF file.\n6.  Verify that the `pdfFileSize` field in the Book model contains the correct size of the uploaded PDF file.\n7.  Test with a file larger than 20MB and verify that the API returns an error response.\n8.  Test with a non-PDF file and verify that the API returns an error response.\n9.  Test error handling for cloud storage upload failures.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "현재 백엔드 구조 분석",
            "description": "backend/ 폴더의 기존 코드를 분석하여 Prisma 스키마와 Book 모델 구조를 파악한다",
            "details": "- backend/prisma/schema.prisma 파일 확인\n- Book 모델의 현재 필드 구조 파악\n- 기존 Book 관련 API 엔드포인트 확인\n- 파일 업로드 관련 기존 구현 확인\n<info added on 2025-07-07T03:14:11.703Z>\n**현재 상황:**\n- 프로젝트는 MongoDB + Mongoose 사용\n- Book 모델은 `backend/src/models/Book.ts`에 정의\n- Book API는 `backend/src/routes/books.ts`에 구현\n- 이미 multer를 사용한 이미지 업로드 기능 존재 (5MB 제한)\n- 업로드 디렉토리: `uploads/` (프로젝트 루트)\n\n**Book 모델 현재 필드:**\n- userId, title, author, bookType, totalPages, currentPage\n- isbn, coverImage, category, status, completionPercentage\n- estimatedRemainingMinutes, avgPpm, readingPurpose, purchaseLink\n- createdAt, updatedAt (timestamps)\n\n**다음 단계:**\n1. Book 모델에 pdfUrl, pdfFileSize 필드 추가\n2. PDF 파일 업로드를 위한 multer 설정 추가\n3. PDF 업로드 API 엔드포인트 구현\n4. PDF 파일 검증 로직 구현\n</info added on 2025-07-07T03:14:11.703Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 1
          },
          {
            "id": 2,
            "title": "Book 모델에 PDF 필드 추가",
            "description": "Book 모델의 인터페이스와 스키마에 pdfUrl과 pdfFileSize 필드를 추가한다",
            "details": "- IBook 인터페이스에 pdfUrl?: string, pdfFileSize?: number 필드 추가\n- BookSchema에 해당 필드들의 Mongoose 스키마 정의 추가\n- 기존 Book 타입과의 호환성 유지\n<info added on 2025-07-07T03:15:28.807Z>\n- pdfUrl은 String 타입, trim 적용, 기본값 null\n- pdfFileSize는 Number 타입, 최소값 0, 기본값 null\n- backend/src/models/Book.ts 파일 수정\n- 기존 필드들에는 영향 없음\n- 새로운 필드들은 옵셔널이므로 기존 데이터와 호환\n</info added on 2025-07-07T03:15:28.807Z>",
            "status": "done",
            "dependencies": [
              1
            ],
            "parentTaskId": 1
          },
          {
            "id": 3,
            "title": "PDF 업로드를 위한 multer 설정 구성",
            "description": "PDF 파일 업로드를 위한 별도의 multer 인스턴스를 생성하고 PDF 파일 검증 로직을 구현한다",
            "details": "- PDF 파일만 허용하는 fileFilter 함수 구현\n- 20MB 파일 크기 제한 설정\n- PDF 전용 업로드 디렉토리 설정 (uploads/pdfs/)\n- MIME 타입 검증 (application/pdf)\n- 파일 확장자 검증 (.pdf)\n<info added on 2025-07-07T03:16:36.856Z>\nPDF 업로드 multer 설정 완료:\n\n**완료된 작업:**\n- PDF 전용 업로드 디렉토리 생성 (uploads/pdfs/)\n- PDF 파일 전용 multer 인스턴스 (uploadPdf) 구성\n- PDF 파일 검증 로직 구현:\n  - MIME 타입 검증: application/pdf만 허용\n  - 파일 확장자 검증: .pdf 확장자만 허용\n  - 파일 크기 제한: 20MB\n- 상세한 로깅 추가로 디버깅 용이성 확보\n- 기존 이미지 업로드 기능과 분리하여 독립적 운영\n\n**변경 사항:**\n- backend/src/routes/books.ts 파일에 PDF 업로드 설정 추가\n- pdfStorage, pdfFileFilter, uploadPdf 인스턴스 생성\n- 에러 메시지 한국어로 사용자 친화적 구성\n</info added on 2025-07-07T03:16:36.856Z>",
            "status": "done",
            "dependencies": [
              2
            ],
            "parentTaskId": 1
          },
          {
            "id": 4,
            "title": "PDF 업로드 API 엔드포인트 구현",
            "description": "책에 PDF 파일을 업로드하는 API 엔드포인트를 구현하고 Book 모델을 업데이트한다",
            "details": "- POST /books/:bookId/upload-pdf 엔드포인트 생성\n- bookController에 uploadPdf 함수 구현\n- 업로드된 PDF 파일 정보를 Book 모델에 저장\n- 파일 URL과 크기 정보 업데이트\n- 에러 핸들링 및 검증 로직 추가\n- 응답 형식 정의\n<info added on 2025-07-07T03:19:34.472Z>\n**완료된 작업:**\n- POST /books/:bookId/upload-pdf 엔드포인트 생성\n- bookController에 uploadPdf 함수 구현\n- 업로드된 PDF 파일 정보를 Book 모델에 저장 (pdfUrl, pdfFileSize)\n- 상세한 에러 핸들링 및 검증 로직:\n  - 사용자 인증 확인\n  - 파일 존재 여부 확인\n  - 책 소유권 확인\n  - 기존 PDF 파일 삭제 (교체 시)\n  - 업로드 실패 시 파일 정리\n- 응답 형식 정의 (성공 메시지, 업데이트된 책 정보, PDF 정보)\n- multer 인스턴스 이름 충돌 해결 (pdfUpload로 변경)\n\n**API 사용법:**\n- POST /books/:bookId/upload-pdf\n- Content-Type: multipart/form-data\n- Field name: pdfFile\n- 최대 파일 크기: 20MB\n- 지원 형식: PDF (.pdf, application/pdf)\n\n**응답 형식:**\n```json\n{\n  \"message\": \"PDF 파일이 성공적으로 업로드되었습니다.\",\n  \"book\": { /* 업데이트된 책 정보 */ },\n  \"pdfInfo\": {\n    \"originalName\": \"document.pdf\",\n    \"url\": \"/uploads/pdfs/pdfFile-1234567890-123456789.pdf\",\n    \"size\": 1234567\n  }\n}\n```\n</info added on 2025-07-07T03:19:34.472Z>",
            "status": "done",
            "dependencies": [
              3
            ],
            "parentTaskId": 1
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement PDF Upload Book Registration UI",
        "description": "Implement the UI for registering books via PDF upload, adding a 'Register via PDF' tab to the existing book registration page. This includes file upload, drag-and-drop functionality, and automatic metadata extraction using pdf.js.",
        "details": "1.  Modify the existing book registration page to include a new tab labeled 'Register via PDF'.\n2.  Implement a file upload component within the 'Register via PDF' tab, allowing users to select PDF files from their local system.\n3.  Implement drag-and-drop functionality for PDF files onto the upload component.\n4.  Integrate pdf.js to extract metadata from the uploaded PDF file, including title, author, and other relevant information.\n5.  Automatically populate the corresponding form fields on the book registration page with the extracted metadata.\n6.  Handle cases where metadata extraction fails or is incomplete, providing users with the option to manually enter the missing information.\n7.  Ensure the UI is responsive and handles large PDF files efficiently, providing appropriate loading indicators.\n8.  Implement client-side validation to ensure that only PDF files are accepted.\n9.  Consider accessibility requirements when designing the UI, ensuring it is usable by people with disabilities.",
        "testStrategy": "1.  Upload a variety of PDF files with different metadata structures.\n2.  Verify that the metadata is correctly extracted and populated into the corresponding form fields.\n3.  Test the drag-and-drop functionality with different PDF files.\n4.  Test the UI with large PDF files to ensure it remains responsive.\n5.  Verify that the client-side validation prevents non-PDF files from being uploaded.\n6.  Manually enter data into the form fields and submit the form to ensure that the data is correctly saved.\n7.  Test the UI on different browsers and devices to ensure compatibility.\n8.  Verify that the UI is accessible to users with disabilities, using assistive technologies such as screen readers.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "PDF.js 라이브러리 설치 및 설정",
            "description": "PDF 메타데이터 추출을 위한 PDF.js 라이브러리를 프론트엔드에 설치하고 설정합니다.",
            "details": "- npm install pdfjs-dist 실행\n- PDF.js worker 설정\n- TypeScript 타입 정의 추가\n- 기본 PDF 파싱 함수 구현\n<info added on 2025-07-07T03:26:31.637Z>\n**구현 내용:**\n1. ✅ pdfjs-dist 라이브러리 설치 완료\n2. ✅ @types/pdfjs-dist TypeScript 타입 정의 설치 완료\n3. ✅ frontend/lib/pdfUtils.ts 파일 생성\n4. ✅ PDF.js worker 설정 구현\n5. ✅ PDF 메타데이터 추출 함수 구현\n6. ✅ PDF 파일 유효성 검사 함수 구현\n7. ✅ 파일 크기 포맷팅 유틸리티 함수 구현\n\n**주요 기능:**\n- extractPdfMetadata(): PDF에서 제목, 저자, 페이지 수 추출\n- validatePdfFile(): PDF 파일 유효성 검사 (타입, 크기, 확장자)\n- formatFileSize(): 파일 크기를 읽기 쉬운 형태로 변환\n- 20MB 파일 크기 제한\n- 에러 핸들링 및 폴백 로직 포함\n\n**TypeScript 타입:**\n- PdfMetadata 인터페이스\n- PdfExtractionResult 인터페이스\n- 완전한 타입 안전성 보장\n</info added on 2025-07-07T03:26:31.637Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 2,
            "title": "PDF 업로드 UI 컴포넌트 생성",
            "description": "드래그앤드롭 기능이 포함된 PDF 업로드 UI 컴포넌트를 생성합니다.",
            "details": "- PdfUploadComponent.tsx 파일 생성\n- 드래그앤드롭 기능 구현\n- PDF 파일 검증 로직\n- 업로드 진행상태 표시\n- 에러 핸들링 UI\n<info added on 2025-07-07T03:28:14.881Z>\n**구현 내용:**\n1. ✅ PdfUploadComponent.tsx 컴포넌트 생성 완료\n2. ✅ 드래그앤드롭 기능 구현\n3. ✅ PDF 파일 검증 로직 구현\n4. ✅ 업로드 진행상태 표시 구현\n5. ✅ 에러 핸들링 UI 구현\n6. ✅ 메타데이터 표시 UI 구현\n\n**주요 기능:**\n- 클릭 또는 드래그앤드롭으로 PDF 파일 업로드\n- 실시간 파일 유효성 검증 (타입, 크기, 확장자)\n- PDF 메타데이터 자동 추출 및 표시\n- 로딩 상태 및 진행률 표시\n- 상세한 에러 메시지 및 경고\n- 업로드된 파일 정보 미리보기\n- 파일 제거 기능\n\n**UI/UX 특징:**\n- Habitus33 사이버펑크 테마 적용\n- 반응형 디자인\n- 접근성 고려 (키보드 네비게이션, 스크린 리더)\n- 직관적인 아이콘 및 상태 표시\n- 부드러운 애니메이션 효과\n\n**기술적 특징:**\n- TypeScript 완전 지원\n- React hooks 활용 (useState, useRef, useCallback)\n- 메모리 누수 방지\n- 에러 경계 처리\n- 컴포넌트 재사용성 고려\n</info added on 2025-07-07T03:28:14.881Z>",
            "status": "done",
            "dependencies": [
              "2.1"
            ],
            "parentTaskId": 2
          },
          {
            "id": 3,
            "title": "PDF 메타데이터 추출 함수 구현",
            "description": "PDF.js를 사용하여 PDF 파일에서 메타데이터(제목, 저자, 페이지 수)를 추출하는 함수를 구현합니다.",
            "details": "- extractPdfMetadata 함수 구현\n- PDF 문서 정보 파싱\n- 제목, 저자, 페이지 수 추출\n- 에러 핸들링 및 폴백 로직\n- TypeScript 타입 정의",
            "status": "done",
            "dependencies": [
              "2.1"
            ],
            "parentTaskId": 2
          },
          {
            "id": 4,
            "title": "기존 책 등록 페이지에 PDF 업로드 기능 통합",
            "description": "기존 /books/new/page.tsx에 PDF 업로드 기능을 통합하고 자동 폼 채우기 기능을 구현합니다.",
            "details": "- 기존 폼에 PDF 업로드 섹션 추가\n- PDF 업로드 시 자동 폼 필드 채우기\n- 수동 입력과 PDF 업로드 방식 병행 지원\n- 반응형 레이아웃 조정\n- 상태 관리 로직 구현\n<info added on 2025-07-07T03:31:31.278Z>\n**구현 내용:**\n1. ✅ 기존 책 등록 페이지에 PDF 업로드 기능 통합 완료\n2. ✅ PDF 업로드 상태 관리 추가 (pdfFile, pdfMetadata, inputMethod)\n3. ✅ PDF 업로드 핸들러 함수 구현 (handlePdfSelected, handlePdfError, clearPdfFile)\n4. ✅ 자동 폼 채우기 기능 구현 (제목, 저자, 페이지 수)\n5. ✅ 수동 입력과 PDF 업로드 방식 병행 지원\n6. ✅ PDF 업로드 UI 섹션 추가 (오른쪽 컬럼)\n7. ✅ 책 등록 후 PDF 업로드 API 연동\n8. ✅ 반응형 레이아웃 조정\n\n**주요 기능:**\n- PDF 파일 업로드 시 메타데이터 자동 추출 및 폼 필드 자동 채우기\n- 수동 입력 모드와 PDF 모드 간 전환 가능\n- PDF 업로드 성공/실패 상태 표시\n- 책 등록 후 자동 PDF 업로드 처리\n- PDF 업로드 실패 시에도 책 등록은 유지 (부분 성공 처리)\n\n**UI/UX 개선:**\n- 직관적인 PDF 업로드 인터페이스\n- 자동 추출된 정보 표시 및 안내\n- 사용자 피드백 메시지 (성공/실패/진행 상태)\n- 기존 디자인과 일관성 유지\n\n**에러 처리:**\n- PDF 업로드 실패 시 적절한 에러 메시지\n- 부분 성공 시나리오 처리 (책 등록 성공, PDF 업로드 실패)\n- 사용자 친화적인 오류 안내\n</info added on 2025-07-07T03:31:31.278Z>",
            "status": "done",
            "dependencies": [
              "2.2",
              "2.3"
            ],
            "parentTaskId": 2
          }
        ]
      },
      {
        "id": 3,
        "title": "Integrate PDF Viewer and Implement Highlighting in TS Reading Session",
        "description": "Integrate a PDF viewer into the TS reading session page using react-pdf and implement a rounded-corner highlighting feature using SVG overlays. This includes text selection, coordinate calculation, and PDF note modal invocation.",
        "details": "1. Integrate the react-pdf library into the TS reading session page.\n2. Implement an SVG overlay to enable rounded-corner highlighting functionality.\n3. Implement text selection functionality within the PDF viewer.\n4. Calculate text coordinates upon selection for highlighting purposes.\n5. Implement a PDF note modal that is invoked upon text selection, allowing users to add notes to highlighted sections.\n6. Ensure the highlighting feature is visually appealing with rounded corners and a subtle color scheme.\n7. Optimize the PDF viewer for performance, ensuring smooth scrolling and rendering even with large PDF documents.\n8. Implement error handling for cases where PDF loading fails or the PDF format is invalid.",
        "testStrategy": "1. Load various PDF documents into the TS reading session page to test the PDF viewer integration.\n2. Select text within the PDF viewer and verify that the rounded-corner highlighting is applied correctly.\n3. Test the text selection functionality with different text sizes and fonts.\n4. Verify that the correct text coordinates are calculated upon selection.\n5. Invoke the PDF note modal and ensure that it displays correctly with the selected text.\n6. Test the performance of the PDF viewer with large PDF documents, ensuring smooth scrolling and rendering.\n7. Simulate PDF loading errors and invalid PDF formats to verify that the error handling is implemented correctly.",
        "status": "done",
        "dependencies": [
          1,
          2
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "react-pdf 라이브러리 설치 및 설정",
            "description": "react-pdf 라이브러리를 설치하고 프로젝트에서 사용할 수 있도록 기본 설정을 구성합니다.",
            "details": "- react-pdf 및 필요한 peer dependencies 설치\\n- PDF 뷰어 기본 컴포넌트 설정\\n- TypeScript 타입 정의 추가\\n- Worker 설정 및 최적화\n<info added on 2025-07-07T03:36:49.893Z>\n**구현 내용:**\n1. ✅ react-pdf 라이브러리 설치 완료\n2. ✅ @types/react-pdf TypeScript 타입 정의 설치 완료\n3. ✅ PdfViewer.tsx 컴포넌트 생성 완료\n4. ✅ PDF.js worker 설정 구현\n5. ✅ 기본 PDF 뷰어 기능 구현\n\n**주요 기능:**\n- 완전한 PDF 문서 렌더링\n- 페이지 네비게이션 (이전/다음 페이지)\n- 줌 인/아웃 기능 (50% ~ 300%)\n- 90도 회전 기능\n- 텍스트 선택 지원 (onTextSelect 콜백)\n- 로딩 상태 및 에러 핸들링\n- 반응형 디자인\n\n**UI/UX 특징:**\n- Habitus33 사이버펑크 테마 적용\n- 직관적인 컨트롤 버튼\n- 실시간 페이지/줌 상태 표시\n- 텍스트 선택 안내 메시지\n- 부드러운 애니메이션 효과\n\n**기술적 특징:**\n- TypeScript 완전 지원\n- React hooks 활용 (useState, useCallback, useRef, useEffect)\n- 텍스트 선택 이벤트 처리\n- 좌표 계산 기능 (하이라이트 준비)\n- 에러 경계 처리\n- 메모리 누수 방지\n</info added on 2025-07-07T03:36:49.893Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          },
          {
            "id": 2,
            "title": "TSReadingPage에 PDF 뷰어 통합",
            "description": "TSReadingPage 컴포넌트에 PDF 뷰어를 통합하여 PDF가 있는 책의 경우 조건부로 렌더링합니다.",
            "details": "- TSReadingPage에서 책의 PDF 파일 존재 여부 확인\\n- PDF가 있는 경우 PdfViewer 컴포넌트 렌더링\\n- PDF 로딩 및 에러 상태 처리\\n- 기존 TS 세션 플로우와의 호환성 유지\n<info added on 2025-07-07T03:39:14.801Z>\n**구현 내용:**\n1. ✅ TSReadingPage에 PDF 뷰어 통합 완료\n2. ✅ SessionData 타입에 PDF 정보 필드 추가 (pdfUrl, pdfFileSize)\n3. ✅ PDF 뷰어 상태 관리 추가 (showPdfViewer, currentPdfPage, pdfError)\n4. ✅ PDF 뷰어 토글 버튼 구현\n5. ✅ 조건부 렌더링 구현 (PDF 있음/없음)\n6. ✅ PDF 텍스트 선택 시 자동 일시정지 기능\n7. ✅ PDF 에러 핸들링 및 사용자 안내\n\n**주요 기능:**\n- PDF가 있는 책: PDF 뷰어 토글 버튼 표시\n- PDF가 없는 책: 기존 호흡 텍스트 유지\n- PDF 뷰어 표시/숨기기 토글 기능\n- 텍스트 선택 시 타이머 자동 일시정지\n- PDF 로딩 에러 시 사용자 친화적 메시지\n\n**UI/UX 특징:**\n- 사이버펑크 테마 일관성 유지\n- 직관적인 PDF 뷰어 토글 버튼\n- 반응형 디자인 (최대 너비 4xl)\n- 부드러운 상태 전환 애니메이션\n\n**기술적 특징:**\n- 기존 TS 세션 플로우와 완전 호환\n- PDF URL 자동 구성 (API URL + 상대 경로)\n- 메모리 효율적인 상태 관리\n- 타입 안전성 보장\n\n**다음 단계 준비:**\n- 텍스트 선택 이벤트 핸들러 준비 완료\n- 메모 모달 연동 준비 (Phase 4)\n- 하이라이트 기능 연동 준비\n</info added on 2025-07-07T03:39:14.801Z>",
            "status": "done",
            "dependencies": [
              "3.1"
            ],
            "parentTaskId": 3
          },
          {
            "id": 3,
            "title": "SVG 오버레이 하이라이트 시스템 구현",
            "description": "PDF 텍스트 위에 SVG 오버레이를 사용하여 둥근 모서리 하이라이트 기능을 구현합니다.",
            "details": "- SVG 오버레이 컴포넌트 생성\\n- 텍스트 좌표를 SVG 좌표로 변환\\n- 둥근 모서리 하이라이트 렌더링\\n- 하이라이트 상태 관리\\n- 여러 하이라이트 지원\n<info added on 2025-07-07T03:44:04.886Z>\n**구현 내용:**\n1. ✅ PDF 하이라이트 타입 정의 완료 (types/pdf.ts)\n2. ✅ 하이라이트 유틸리티 함수 구현 (lib/pdfHighlightUtils.ts)\n3. ✅ SVG 오버레이 하이라이트 컴포넌트 생성 (PdfHighlightOverlay.tsx)\n4. ✅ PdfViewer에 하이라이트 시스템 통합 완료\n5. ✅ 하이라이트 모드 토글 기능 구현\n6. ✅ 둥근 모서리 하이라이트 렌더링 구현\n7. ✅ 다중 하이라이트 지원\n\n**주요 기능:**\n- **하이라이트 생성**: 텍스트 선택 시 자동 하이라이트 생성\n- **둥근 모서리**: SVG rect에 rx/ry 속성으로 세련된 모양\n- **다중 색상 지원**: 6가지 하이라이트 색상 (yellow, green, blue, purple, pink, orange)\n- **인터랙티브**: 클릭, 더블클릭, 우클릭 이벤트 지원\n- **시각적 피드백**: 호버 시 투명도 변경 및 테두리 표시\n- **메모 표시**: 메모가 있는 하이라이트에 작은 원 아이콘\n\n**기술적 특징:**\n- **좌표 변환**: DOM 좌표 → SVG 좌표 정확한 변환\n- **성능 최적화**: MutationObserver로 컨테이너 변경 감지\n- **반응형**: 스케일 변경 시 하이라이트 크기 자동 조정\n- **페이지별 필터링**: 현재 페이지의 하이라이트만 렌더링\n- **메모리 관리**: 컴포넌트 언마운트 시 이벤트 리스너 정리\n\n**UI/UX 특징:**\n- **하이라이트 모드 토글**: 노란색 아이콘으로 직관적 표시\n- **상태별 안내 메시지**: 일반 모드와 하이라이트 모드 구분\n- **부드러운 애니메이션**: 호버 및 상태 전환 효과\n- **접근성**: 키보드 네비게이션 및 툴팁 지원\n\n**다음 단계 준비:**\n- 하이라이트 생성 이벤트 준비 완료\n- 메모 모달 연동 준비 (Phase 4)\n- TSReadingPage 통합 준비\n</info added on 2025-07-07T03:44:04.886Z>",
            "status": "done",
            "dependencies": [
              "3.2"
            ],
            "parentTaskId": 3
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement PDF Note-Taking Modal",
        "description": "Implement a reusable PDF note-taking modal with the same UI/UX as the existing review session memo input form. This modal will be triggered upon highlighting text in the PDF viewer, pausing the timer and pre-filling the modal with the highlighted text.",
        "details": "1.  Create a new, reusable component for the PDF note-taking modal, mirroring the UI/UX of the existing review session memo input form.\n2.  Implement logic to pause the timer when text is highlighted in the PDF viewer.\n3.  Implement logic to invoke the PDF note-taking modal upon text highlighting.\n4.  Automatically populate the modal with the highlighted text.\n5.  Implement functionality to save the note and return to the TS reading session upon saving, resuming the timer.\n6. Ensure the modal is properly integrated with the highlighting functionality implemented in Task 3.",
        "testStrategy": "1.  Highlight text in the PDF viewer and verify that the timer pauses.\n2.  Verify that the PDF note-taking modal is invoked upon text highlighting.\n3.  Ensure that the highlighted text is automatically populated in the modal.\n4.  Save the note and verify that the user is returned to the TS reading session and the timer resumes.\n5.  Test the modal with different lengths of highlighted text.\n6.  Verify that the saved note is correctly associated with the highlighted text.",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "기존 TS 리뷰 메모 UI 분석 및 재사용 컴포넌트 추출",
            "description": "TSReviewPage의 메모 입력 폼을 분석하고 재사용 가능한 컴포넌트로 추출",
            "details": "TSReviewPage.client.tsx의 메모 입력 폼 UI/UX를 분석하여 PDF 메모 작성에 재사용할 수 있도록 별도 컴포넌트로 추출\n<info added on 2025-07-07T03:51:48.988Z>\n✅ 서브태스크 4.1 완료!\n\n**완료 내용:**\n- TSReviewPage의 메모 입력 폼 UI/UX를 분석 완료\n- 동일한 cyberTheme와 스타일을 사용하는 PdfMemoModal 컴포넌트 생성\n- 기존 TS 리뷰 폼과 동일한 필드들 구현:\n  - 메모 성격 선택 (생각/인용/질문)\n  - 메모 텍스트 입력 (하이라이트된 텍스트 자동 입력)\n  - 키워드 입력\n  - 셀프 평가 (별점 1-5)\n- 모달 형태로 구현하여 PDF 뷰어 위에 오버레이\n- 반응형 디자인 및 접근성 고려\n- 에러 핸들링 및 로딩 상태 관리\n- PdfMemoData 타입 정의 및 export 추가\n</info added on 2025-07-07T03:51:48.988Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 2,
            "title": "PDF 메모 모달 컴포넌트 생성",
            "description": "하이라이트된 텍스트를 받아 메모를 작성할 수 있는 모달 컴포넌트 생성",
            "details": "기존 TS 리뷰 메모 UI와 동일한 스타일의 PDF 메모 모달 컴포넌트를 생성하고, 하이라이트된 텍스트를 자동으로 입력하는 기능 구현\n<info added on 2025-07-07T03:52:30.188Z>\nPdfMemoModal 컴포넌트는 서브태스크 4.1에서 이미 완성됨\n- 하이라이트된 텍스트를 자동으로 메모 필드에 입력하는 기능 구현\n- 기존 TS 리뷰 메모와 동일한 UI/UX 스타일 적용\n- 모든 필수 기능 구현:\n  - 메모 성격 선택 (생각/인용/질문)\n  - 메모 텍스트 입력 (하이라이트 텍스트 자동 입력)\n  - 키워드 입력\n  - 중요도 평가 (별점)\n  - 에러 핸들링 및 로딩 상태\n- PdfMemoData 타입 정의 및 export\n- 모달 형태로 구현하여 PDF 뷰어 위에 오버레이\n\n**다음 단계:** TSReadingPage에 모달을 통합하고 하이라이트 이벤트와 연동\n</info added on 2025-07-07T03:52:30.188Z>",
            "status": "done",
            "dependencies": [
              "4.1"
            ],
            "parentTaskId": 4
          },
          {
            "id": 3,
            "title": "TSReadingPage에 PDF 메모 모달 통합",
            "description": "TSReadingPage에 PDF 메모 모달을 통합하고 하이라이트 이벤트와 연동",
            "details": "TSReadingPage에 PDF 메모 모달을 추가하고, 하이라이트 생성 시 타이머 일시정지 및 모달 호출 로직 구현\n<info added on 2025-07-07T03:54:51.529Z>\n- TSReadingPage에 PdfMemoModal 컴포넌트 import 및 통합 완료\n- PDF 메모 모달 상태 관리 추가:\n  - isMemoModalOpen: 모달 열림/닫힘 상태\n  - selectedText: 하이라이트된 텍스트\n  - selectedPageNumber: 현재 페이지 번호\n- 하이라이트 이벤트와 모달 연동 구현:\n  - handlePdfTextSelect에서 타이머 자동 일시정지\n  - 선택된 텍스트와 페이지 정보 저장\n  - 메모 모달 자동 호출\n- 모달 핸들러 구현:\n  - handleMemoModalClose: 모달 닫기 및 타이머 재개\n  - handleMemoSave: 메모 저장 로직 (임시로 localStorage 사용)\n- 메모 저장 후 타이머 자동 재개 구현\n- Phase 5 API 연동을 위한 TODO 주석 추가\n\n**다음 단계:** 타이머 일시정지/재개 로직 최적화\n</info added on 2025-07-07T03:54:51.529Z>",
            "status": "done",
            "dependencies": [
              "4.2"
            ],
            "parentTaskId": 4
          },
          {
            "id": 4,
            "title": "타이머 일시정지/재개 로직 구현",
            "description": "하이라이트 시 타이머 일시정지, 메모 저장 후 타이머 재개 로직 구현",
            "details": "PDF 하이라이트 생성 시 자동으로 타이머를 일시정지하고, 메모 저장 완료 후 타이머를 자동으로 재개하는 로직 구현\n<info added on 2025-07-07T03:55:20.886Z>\n🔍 서브태스크 4.4 분석 시작\n\n**현재 타이머 로직 검토:**\n- 기본 일시정지/재개 기능은 이미 구현됨\n- PDF 하이라이트 시 자동 일시정지 구현됨\n- 메모 저장 후 자동 재개 구현됨\n- 모달 닫기 시 자동 재개 구현됨\n\n**추가 최적화 필요 사항:**\n1. 중복 일시정지 방지 로직\n2. 타이머 상태 표시 개선\n3. 메모 작성 중 타이머 상태 명확화\n4. 에지 케이스 처리 (모달 열림 중 수동 일시정지 등)\n\n**구현 진행:**\n- 현재 로직이 이미 요구사항을 충족하고 있음을 확인\n- 필요한 경우에만 최소한의 개선 적용\n</info added on 2025-07-07T03:55:20.886Z>\n<info added on 2025-07-07T03:56:34.974Z>\n✅ 서브태스크 4.4 완료!\n\n**완료된 타이머 로직 최적화:**\n\n1. **메모 작성 상태 구분**:\n   - `isPausedForMemo` 상태 추가로 메모 작성으로 인한 일시정지와 수동 일시정지 구분\n   - 타이머 상태 텍스트 개선 (몰입하는 중/일시정지됨/메모 작성 중)\n\n2. **중복 방지 로직**:\n   - 메모 모달이 이미 열려있을 때 텍스트 선택 무시\n   - 이미 일시정지된 상태에서 중복 일시정지 방지\n\n3. **수동 컨트롤 제한**:\n   - 메모 작성 중에는 수동 일시정지/재개 버튼 비활성화\n   - 메모 작성 중에는 수동 종료 버튼 비활성화\n   - 버튼 상태에 따른 시각적 피드백 개선\n\n4. **정확한 타이머 재개**:\n   - 메모 저장 완료 시에만 타이머 재개\n   - 모달 닫기 시에도 정확한 타이머 재개\n   - 메모 작성으로 인한 일시정지인 경우에만 자동 재개\n\n**사용자 경험 개선:**\n- 타이머 상태가 명확하게 표시됨\n- 메모 작성 중 실수로 타이머 조작 방지\n- 일관된 타이머 동작 보장\n</info added on 2025-07-07T03:56:34.974Z>",
            "status": "done",
            "dependencies": [
              "4.3"
            ],
            "parentTaskId": 4
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement PDF Memo Saving API",
        "description": "Develop a dedicated API endpoint to save PDF memos generated during TS reading sessions to the database. This API will handle data persistence for PDF notes.",
        "details": "1. Create a new API endpoint `/api/ts-notes` that accepts POST requests.\n2. Implement server-side validation to ensure the request body contains `bookId` (integer), `pageNumber` (integer), `highlightedText` (string), `memoContent` (string), and `memoType` (string).\n3. Create a `Note` model in the database with fields corresponding to the validated request body parameters.\n4. Upon successful validation, create a new record in the `Note` table with the provided data.\n5. Return a success response with the newly created note's ID.\n6. Implement error handling to return appropriate error codes and messages for invalid requests or database errors.\n7. Ensure the API is secured with appropriate authentication and authorization mechanisms.\n8. Optimize database queries for performance, especially when retrieving notes for a specific book and page.",
        "testStrategy": "1. Send a POST request to `/api/ts-notes` with valid data for `bookId`, `pageNumber`, `highlightedText`, `memoContent`, and `memoType`.\n2. Verify that a new record is created in the `Note` table with the provided data.\n3. Verify that the API returns a success response with the newly created note's ID.\n4. Send a POST request with invalid data (e.g., missing fields, incorrect data types) and verify that the API returns an appropriate error response.\n5. Test the API with different combinations of `bookId`, `pageNumber`, `highlightedText`, `memoContent`, and `memoType` to ensure it handles various scenarios correctly.\n6. Test the API's performance by sending multiple concurrent requests and monitoring response times.\n7. Verify that the API is properly secured by attempting to access it without proper authentication and authorization.",
        "status": "done",
        "dependencies": [
          3,
          4
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "기존 Note 모델 및 API 구조 분석",
            "description": "기존 Note 모델의 스키마와 API 엔드포인트를 분석하여 PDF 메모와 호환 가능한 구조 파악",
            "details": "1. Note 모델 스키마 분석 (필드, 타입, 제약조건)\\n2. notes API 엔드포인트 분석 (/notes 라우트)\\n3. PDF 메모를 위한 추가 필드 필요성 검토\\n4. 기존 TS 메모와 PDF 메모 구분 방법 설계\n<info added on 2025-07-07T04:00:32.568Z>\n✅ 기존 Note 모델 및 API 구조 분석 완료\n\n**Note 모델 분석 결과:**\n1. **기존 필드들:**\n   - 필수: userId, bookId, type ('quote'|'thought'|'question'), content\n   - 옵셔널: tags[], originSession, importanceReason, momentContext, relatedKnowledge, mentalImage, relatedLinks[], inlineThreads[]\n   - 시간: createdAt, clientCreatedAt\n\n2. **PDF 메모를 위해 추가 필요한 필드들:**\n   - pageNumber: PDF 페이지 번호 (number)\n   - highlightedText: 하이라이트된 원문 텍스트 (string)\n   - highlightData: 하이라이트 좌표 정보 (object, 옵셔널)\n   - isPdfMemo: PDF 메모 구분 플래그 (boolean, 기본값 false)\n\n3. **기존 API 엔드포인트:**\n   - GET /notes - 전체 노트 목록\n   - POST /notes - 새 노트 생성 (기존 TS 메모용)\n   - GET /notes/book/:bookId - 책별 노트 조회\n   - PUT /notes/:noteId - 노트 수정\n   - DELETE /notes/:noteId - 노트 삭제\n\n4. **PDF 메모 전용 API 설계:**\n   - POST /notes/pdf - PDF 메모 전용 생성 엔드포인트\n   - 기존 createNote와 분리하여 PDF 전용 validation 적용\n   - 기존 API들과 호환성 유지\n\n**다음 단계:** Note 모델에 PDF 관련 필드 추가 준비 완료\n</info added on 2025-07-07T04:00:32.568Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 2,
            "title": "Note 모델에 PDF 관련 필드 추가",
            "description": "PDF 메모를 저장하기 위한 추가 필드를 Note 모델에 추가 (pageNumber, highlightedText, pdfUrl 등)",
            "details": "1. INote 인터페이스에 PDF 관련 필드 추가\\n2. NoteSchema에 새 필드들의 Mongoose 스키마 정의\\n3. 기존 데이터와의 호환성 유지 (옵셔널 필드)\\n4. 인덱스 추가 (성능 최적화)\n<info added on 2025-07-07T04:01:41.967Z>\n✅ Note 모델에 PDF 관련 필드 추가 완료\n\n**추가된 필드들:**\n\n1. **INote 인터페이스 확장:**\n   - `isPdfMemo?: boolean` - PDF 메모 구분 플래그\n   - `pageNumber?: number` - PDF 페이지 번호\n   - `highlightedText?: string` - 하이라이트된 원문 텍스트\n   - `highlightData?: object` - 하이라이트 좌표 정보 (x, y, width, height, pageIndex)\n\n2. **NoteSchema 확장:**\n   - 모든 새 필드를 옵셔널로 설정하여 기존 데이터와 호환성 유지\n   - `isPdfMemo`: Boolean, 기본값 false\n   - `pageNumber`: Number, 최소값 1, 기본값 null\n   - `highlightedText`: String, 최대 2000자 (PDF 텍스트는 더 길 수 있음)\n   - `highlightData`: 중첩 객체로 좌표 정보 저장, 모든 하위 필드 required\n\n3. **성능 최적화 인덱스 추가:**\n   - `{ userId: 1, bookId: 1, isPdfMemo: 1 }` - PDF 메모 필터링용\n   - `{ userId: 1, bookId: 1, pageNumber: 1 }` - 페이지별 메모 조회용\n   - `{ isPdfMemo: 1, pageNumber: 1 }` - PDF 메모 페이지 검색용\n\n**다음 단계:** PDF 메모 저장 API 컨트롤러 함수 구현 준비 완료\n</info added on 2025-07-07T04:01:41.967Z>",
            "status": "done",
            "dependencies": [
              "5.1"
            ],
            "parentTaskId": 5
          },
          {
            "id": 3,
            "title": "PDF 메모 저장 API 엔드포인트 구현",
            "description": "PDF 메모를 저장하는 새로운 API 엔드포인트를 notes 컨트롤러에 구현",
            "details": "1. noteController에 createPdfNote 함수 구현\\n2. 요청 데이터 검증 (bookId, pageNumber, highlightedText, memoData)\\n3. 사용자 인증 및 권한 확인\\n4. PDF 메모 데이터베이스 저장\\n5. 에러 핸들링 및 응답 처리\n<info added on 2025-07-07T04:03:01.065Z>\n✅ PDF 메모 저장 API 엔드포인트 구현 완료\n\n**구현된 createPdfNote 함수 기능:**\n\n1. **인증 및 권한 검증:**\n   - 사용자 인증 상태 확인\n   - 책 소유권 확인 (userId와 bookId 매칭)\n   - PDF 파일 등록 여부 확인 (book.pdfUrl 존재 확인)\n\n2. **요청 데이터 처리:**\n   - bookId, type, content, tags (기본 메모 필드)\n   - pageNumber, highlightedText, highlightData (PDF 전용 필드)\n   - selfRating (별점 평가)\n   - isPdfMemo: true 자동 설정\n\n3. **에러 핸들링:**\n   - MongoDB ValidationError 처리 (필드 유효성 검사 실패)\n   - MongoDB CastError 처리 (잘못된 ObjectId 형식)\n   - 일반적인 서버 에러 처리\n   - 상세한 에러 메시지 제공\n\n4. **개발 환경 로깅:**\n   - PDF 메모 생성 성공 시 상세 정보 로깅\n   - 디버깅 및 모니터링을 위한 메타데이터 포함\n\n5. **Note 모델 업데이트:**\n   - selfRating 필드 추가 (1-5 범위, 옵셔널)\n   - PDF 메모 작성 시 별점 평가 저장 지원\n\n**다음 단계:** notes 라우트에 PDF 메모 엔드포인트 추가 준비 완료\n</info added on 2025-07-07T04:03:01.065Z>",
            "status": "done",
            "dependencies": [
              "5.2"
            ],
            "parentTaskId": 5
          },
          {
            "id": 4,
            "title": "notes 라우트에 PDF 메모 엔드포인트 추가",
            "description": "notes.ts 라우터에 PDF 메모 저장을 위한 새로운 라우트와 validation 추가",
            "details": "1. POST /notes/pdf 라우트 추가\\n2. PDF 메모 전용 validation 미들웨어 구성\\n3. express-validator를 사용한 요청 데이터 검증\\n4. 라우트를 createPdfNote 컨트롤러 함수에 연결\n<info added on 2025-07-07T04:04:06.160Z>\n✅ notes 라우트에 PDF 메모 엔드포인트 추가 완료\n\n**구현된 내용:**\n\n1. **createPdfNote 함수 import 추가:**\n   - noteController에서 createPdfNote 함수를 import\n   - 기존 import 목록에 추가\n\n2. **PDF 메모 전용 validation 미들웨어 구성:**\n   - `createPdfNoteValidation` 배열 생성\n   - 필수 필드 검증: bookId, type, content, pageNumber, highlightedText\n   - 옵셔널 필드 검증: tags, selfRating, highlightData\n   - 상세한 타입 및 범위 검증 (MongoId, 정수, 문자열 길이 등)\n\n3. **POST /notes/pdf 라우트 추가:**\n   - PDF 메모 전용 엔드포인트 생성\n   - validation → validateRequest → createPdfNote 순서로 미들웨어 체인 구성\n   - 기존 POST /notes와 분리하여 PDF 전용 로직 적용\n\n4. **상세한 validation 규칙:**\n   - bookId: MongoDB ObjectId 형식 검증\n   - pageNumber: 1 이상의 정수\n   - highlightedText: 최대 2000자 (PDF 텍스트는 더 길 수 있음)\n   - selfRating: 1-5 범위의 정수\n   - highlightData: 좌표 정보 객체 (x, y, width, height, pageIndex)\n\n**API 엔드포인트 완성:** `POST /api/notes/pdf`로 PDF 메모 저장 가능\n\n**다음 단계:** 프론트엔드 API 연동 구현 준비 완료\n</info added on 2025-07-07T04:04:06.160Z>",
            "status": "done",
            "dependencies": [
              "5.3"
            ],
            "parentTaskId": 5
          },
          {
            "id": 5,
            "title": "프론트엔드 API 연동 구현",
            "description": "PdfMemoModal에서 localStorage 대신 실제 API를 호출하도록 수정하고 에러 핸들링 추가",
            "details": "1. lib/api.ts에 PDF 메모 저장 API 함수 추가\\n2. PdfMemoModal의 handleSave 함수 수정\\n3. API 호출 에러 핸들링 및 사용자 피드백\\n4. 성공/실패 상태 UI 업데이트\\n5. TSReadingPage에서 메모 저장 완료 후 처리 로직\n<info added on 2025-07-07T04:06:58.305Z>\n✅ 프론트엔드 API 연동 구현 완료\n\n**구현된 내용:**\n\n1. **lib/api.ts에 PDF 메모 저장 API 함수 추가:**\n   - `notes.createPdf(pdfNoteData)` 함수 구현\n   - POST /notes/pdf 엔드포인트 호출\n   - 기존 notes API와 일관된 구조 유지\n\n2. **PdfMemoModal 대폭 수정:**\n   - localStorage 제거하고 실제 API 호출로 변경\n   - notes.createPdf API 연동\n   - 상세한 에러 핸들링 (validation 에러, 서버 에러 등)\n   - 로딩 상태 UI 추가 (스피너, 버튼 비활성화)\n   - 사용자 친화적인 에러 메시지 표시\n\n3. **API 요청 데이터 구조:**\n   - bookId, type, content, tags (기본 메모 필드)\n   - pageNumber, highlightedText (PDF 전용 필드)\n   - selfRating (별점 평가)\n   - highlightData (향후 하이라이트 좌표 정보 확장 가능)\n\n4. **에러 핸들링 개선:**\n   - API 응답 에러 메시지 표시\n   - validation 에러 배열 처리\n   - 네트워크 오류 등 일반적인 에러 처리\n   - 사용자에게 명확한 피드백 제공\n\n5. **TSReadingPage 연동 수정:**\n   - handleMemoSave 함수 간소화 (API 호출은 모달에서 처리)\n   - props 인터페이스 변경에 맞게 수정 (selectedText, bookId)\n   - null 체크 추가로 타입 안전성 향상\n\n**API 연동 완료:** PDF 메모가 실제 데이터베이스에 저장되고 백엔드 API와 완전히 연동됨\n\n**Phase 5 완료:** PDF 메모 저장 시스템 전체 구현 완료! 🎉\n</info added on 2025-07-07T04:06:58.305Z>",
            "status": "done",
            "dependencies": [
              "5.4"
            ],
            "parentTaskId": 5
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-07T03:10:48.522Z",
      "updated": "2025-07-07T04:07:15.819Z",
      "description": "PDF 기반 동적 지식 캡처 시스템 구현을 위한 태스크 관리"
    }
  },
  "pdf-scroll-feature": {
    "tasks": [
      {
        "id": 25,
        "title": "Initialize Backend Project",
        "description": "Set up the Node.js and Express backend project with TypeScript, including initial configurations for Prisma and necessary middleware.",
        "details": "1. Initialize a new Node.js project using `npm init -y`.\n2. Install Express, TypeScript, and required typings: `npm install express typescript @types/express @types/node --save-dev`.\n3. Configure TypeScript with `tsc --init` and adjust `tsconfig.json` for desired settings (e.g., `target`: \"es2018\", `module`: \"commonjs\", `outDir`: \"./dist\", `esModuleInterop`: true, `strict`: true).\n4. Install Prisma CLI as a development dependency: `npm install prisma --save-dev`.\n5. Initialize Prisma with `npx prisma init --datasource-provider postgresql`.\n6. Install `cors` for handling Cross-Origin Resource Sharing: `npm install cors`.\n7. Create a basic Express server in `src/index.ts`.\n8. Add scripts to `package.json` for building and running the server (e.g., `\"build\": \"tsc\", \"start\": \"node dist/index.js\", \"dev\": \"nodemon src/index.ts\")`.\n9. Install `nodemon` as a development dependency for automatic server restarts during development: `npm install -D nodemon ts-node` and configure it.",
        "testStrategy": "Verify the server starts without errors and responds to a basic health check endpoint.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Define Database Schema with Prisma",
        "description": "Define the PostgreSQL database schema using Prisma, including the `notes`, `concept_scores`, and `score_calculations` tables.",
        "details": "1.  Modify the `schema.prisma` file to define the `notes`, `concept_scores`, and `score_calculations` tables.\n2.  Include fields like `id`, `concept_score` in the `notes` table. The `concept_scores` table should include fields for `noteId`, `score`, `timestamp`, and individual scores for each of the 6 areas (생각추가, 메모진화, 지식연결, 플래시카드, 태그활용, 사용자평점). The `score_calculations` table should include fields for `version`, `calculation_logic`, and `timestamp`.\n3.  Run `npx prisma migrate dev --name init` to create the initial migration and apply the schema to the PostgreSQL database.\n4.  Use Prisma Client to interact with the database in the application code. Install Prisma Client with `npm install @prisma/client`.",
        "testStrategy": "Inspect the PostgreSQL database to ensure that the tables are created with the correct schema. Verify Prisma Client can connect to the database and perform basic CRUD operations.",
        "priority": "high",
        "dependencies": [
          25
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Implement GET Concept Score API",
        "description": "Implement the GET `/api/notes/:noteId/concept-score` endpoint to retrieve the concept score for a given note.",
        "details": "1.  Create a new route in Express for `/api/notes/:noteId/concept-score`.\n2.  Use Prisma Client to query the `notes` table and retrieve the `concept_score` for the specified `noteId`.\n3.  Return the score as a JSON response.\n4.  Implement error handling to return appropriate HTTP status codes for invalid `noteId` or database errors.",
        "testStrategy": "Use `curl` or Postman to send a GET request to `/api/notes/:noteId/concept-score` with a valid `noteId`. Verify the response contains the correct concept score. Test with an invalid `noteId` and ensure an appropriate error response is returned.",
        "priority": "high",
        "dependencies": [
          26
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Implement POST Update Score API",
        "description": "Implement the POST `/api/notes/:noteId/update-score` endpoint to trigger a score update for a given note.",
        "details": "1.  Create a new route in Express for `/api/notes/:noteId/update-score`.\n2.  This endpoint should receive data necessary for score recalculation (e.g., updates to 생각추가, 메모진화, etc.).\n3.  Call the real-time score calculation engine (implemented in task 29) to update the score.\n4.  Update the `concept_score` field in the `notes` table using Prisma Client.\n5.  Create a new entry in the `concept_scores` table to track the score history.\n6.  Return a success message as a JSON response.",
        "testStrategy": "Use `curl` or Postman to send a POST request to `/api/notes/:noteId/update-score` with relevant data. Verify the `concept_score` in the `notes` table is updated, a new entry is created in the `concept_scores` table, and a success message is returned.",
        "priority": "high",
        "dependencies": [
          26
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Express route for /api/notes/:noteId/update-score",
            "description": "Create a new route in Express for the `/api/notes/:noteId/update-score` endpoint to handle POST requests.",
            "dependencies": [],
            "details": "Define the route handler function to receive the noteId and request body.",
            "status": "done",
            "testStrategy": "Use Postman or curl to send a POST request to the endpoint and verify that the route is accessible."
          },
          {
            "id": 2,
            "title": "Parse and validate request data",
            "description": "Extract and validate the data required for score recalculation from the request body.",
            "dependencies": [],
            "details": "Implement data validation to ensure the required fields (e.g., 생각추가, 메모진화) are present and in the correct format.",
            "status": "done",
            "testStrategy": "Send POST requests with missing or invalid data and verify that appropriate error responses are returned."
          },
          {
            "id": 3,
            "title": "Call real-time score calculation engine",
            "description": "Invoke the real-time score calculation engine (Task 29) with the validated data to update the score.",
            "dependencies": [],
            "details": "Pass the necessary parameters to the score calculation engine and handle any potential errors during the calculation process.",
            "status": "done",
            "testStrategy": "Mock the score calculation engine and verify that it is called with the correct parameters."
          },
          {
            "id": 4,
            "title": "Update notes and concept_scores tables",
            "description": "Update the `concept_score` field in the `notes` table and create a new entry in the `concept_scores` table using Prisma Client.",
            "dependencies": [],
            "details": "Use Prisma Client to perform the database updates. Ensure that the updates are atomic and handle potential database errors.",
            "status": "done",
            "testStrategy": "Verify that the `concept_score` in the `notes` table is updated correctly and a new entry is created in the `concept_scores` table with the correct values."
          },
          {
            "id": 5,
            "title": "Return success message",
            "description": "Return a success message as a JSON response to the client.",
            "dependencies": [],
            "details": "Construct a JSON response indicating the successful update of the concept score.",
            "status": "done",
            "testStrategy": "Verify that the response contains a success message and an appropriate HTTP status code (e.g., 200 OK)."
          }
        ]
      },
      {
        "id": 29,
        "title": "Develop Real-time Score Calculation Engine",
        "description": "Develop the real-time score calculation engine, implementing the scoring algorithms for each of the six areas (생각추가, 메모진화, 지식연결, 플래시카드, 태그활용, 사용자평점).",
        "details": "1.  Create a function that takes relevant data as input (e.g., data related to 생각추가, 메모진화, etc.).\n2.  Implement the scoring logic for each of the six areas based on the provided formulas:\n    *   생각추가: 4단계 완성도 + 텍스트 길이 (max 20)\n    *   메모진화: 4단계 완성 + 진화 속도 (max 20)\n    *   지식연결: 연결 개수 + 다양성 + 품질 (max 20)\n    *   플래시카드: 생성 + 복습 + 난이도 (max 20)\n    *   태그 활용: 개수 + 품질 + 다양성 (max 10)\n    *   사용자 평점: 평점 존재 + 높음 + 업데이트 (max 10)\n3.  Combine the scores from each area to calculate the final concept score.\n4.  Consider using a configuration table (`score_calculations`) to manage different versions of the calculation logic.",
        "testStrategy": "Write unit tests to verify the scoring logic for each of the six areas. Ensure the scores are calculated correctly based on different input values. Test the overall score calculation with various combinations of input data.",
        "priority": "high",
        "dependencies": [
          26
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Data Input Structure",
            "description": "Define the structure and format of the input data required for the score calculation function. This includes specifying the data types and units for each input parameter related to 생각추가, 메모진화, 지식연결, 플래시카드, 태그활용, and 사용자평점.",
            "dependencies": [],
            "details": "Research and document the specific data points needed for each scoring area. For example, for '생각추가', define how '4단계 완성도' and '텍스트 길이' will be represented. Consider using a JSON schema or similar data definition language.",
            "status": "done",
            "testStrategy": "Create sample input data sets that conform to the defined structure. Verify that the data can be parsed and processed correctly by the scoring engine."
          },
          {
            "id": 2,
            "title": "Implement Scoring Logic for Individual Areas",
            "description": "Implement the scoring algorithms for each of the six areas (생각추가, 메모진화, 지식연결, 플래시카드, 태그활용, 사용자평점) based on the provided formulas. Each area should have its own dedicated function or module.",
            "dependencies": [],
            "details": "Translate the formulas into code. For example, for '생각추가', implement the logic to calculate the score based on '4단계 완성도' and '텍스트 길이', ensuring the maximum score is 20. Handle edge cases and invalid input gracefully.",
            "status": "done",
            "testStrategy": "Write unit tests for each scoring area to verify the score is calculated correctly for different input values. Test boundary conditions and edge cases."
          },
          {
            "id": 3,
            "title": "Create Score Combination Function",
            "description": "Develop a function that combines the individual scores from each of the six areas to calculate the final concept score. This function should aggregate the scores and potentially apply weighting factors if needed.",
            "dependencies": [
              "29.2"
            ],
            "details": "Implement the logic to sum the scores from each area. Consider adding the ability to configure weights for each area in the `score_calculations` table. Ensure the final score is within a reasonable range.",
            "status": "done",
            "testStrategy": "Test the score combination function with various combinations of input scores from the individual areas. Verify that the final score is calculated correctly and that the weighting factors are applied as expected."
          },
          {
            "id": 4,
            "title": "Implement Configuration Table Access",
            "description": "Implement the logic to access and utilize the `score_calculations` configuration table. This table should allow for managing different versions of the calculation logic and potentially weighting factors for each area.",
            "dependencies": [],
            "details": "Establish a connection to the database or data source where the `score_calculations` table is stored. Implement functions to retrieve the appropriate configuration based on a version identifier or other criteria. Cache the configuration data for performance.",
            "status": "done",
            "testStrategy": "Create different versions of the `score_calculations` table with varying calculation logic and weighting factors. Verify that the scoring engine uses the correct configuration based on the specified version."
          },
          {
            "id": 5,
            "title": "Integrate and Test Real-time Score Calculation",
            "description": "Integrate all the components of the score calculation engine and test the end-to-end functionality. This includes retrieving data, calculating individual area scores, combining the scores, and utilizing the configuration table.",
            "dependencies": [
              "29.1",
              "29.2",
              "29.3",
              "29.4"
            ],
            "details": "Connect the score calculation engine to the relevant data sources. Implement the API endpoint to trigger the score calculation. Monitor performance and identify any bottlenecks.",
            "status": "done",
            "testStrategy": "Perform end-to-end testing of the score calculation engine with realistic data sets. Verify that the scores are calculated correctly and that the performance is acceptable. Monitor the system for errors and performance issues."
          }
        ]
      },
      {
        "id": 30,
        "title": "Initialize Frontend Project",
        "description": "Set up the React and TypeScript frontend project using Create React App, including Tailwind CSS for styling.",
        "details": "1.  Create a new React project with TypeScript using `npx create-react-app habitus-frontend --template typescript`.\n2.  Install Tailwind CSS and its dependencies: `npm install -D tailwindcss postcss autoprefixer && npx tailwindcss init -p`.\n3.  Configure Tailwind CSS by adding the directives to `./src/index.css` and configuring the `tailwind.config.js` file.\n4.  Install Axios for making HTTP requests: `npm install axios`.",
        "testStrategy": "Verify the React application starts without errors and displays a basic UI. Ensure Tailwind CSS styles are applied correctly.",
        "priority": "high",
        "dependencies": [
          25
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Implement Concept Score Icon",
        "description": "Develop the UI component to display the concept score icon in the upper right corner of the memo card.",
        "details": "1.  Create a new React component for the concept score icon.\n2.  Fetch the concept score from the backend API (`/api/notes/:noteId/concept-score`) using Axios.\n3.  Display the score using one of the specified icons (💡🧠🎯⭐) based on the score range.\n4.  Implement color coding (red -> orange -> green -> blue) based on the score value using Tailwind CSS classes.",
        "testStrategy": "Verify the concept score icon is displayed correctly on the memo card. Ensure the icon and color coding change based on the score value. Test with different `noteId` values.",
        "priority": "high",
        "dependencies": [
          30,
          27
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create React Component for Concept Score Icon",
            "description": "Develop a new React component to display the concept score icon.",
            "dependencies": [],
            "details": "Create a functional React component that will fetch and display the concept score icon. This component will be placed in the upper right corner of the memo card.",
            "status": "done",
            "testStrategy": "Verify the component renders without errors and is positioned correctly on the memo card."
          },
          {
            "id": 2,
            "title": "Fetch Concept Score from API",
            "description": "Implement the logic to fetch the concept score from the backend API.",
            "dependencies": [],
            "details": "Use Axios to make a GET request to `/api/notes/:noteId/concept-score`. Handle potential errors and store the retrieved score in the component's state.",
            "status": "done",
            "testStrategy": "Test with different `noteId` values to ensure the correct score is fetched. Verify error handling for invalid `noteId` values."
          },
          {
            "id": 3,
            "title": "Determine Icon Based on Score Range",
            "description": "Implement the logic to select the appropriate icon based on the concept score range.",
            "dependencies": [],
            "details": "Create a function that takes the concept score as input and returns the corresponding icon (💡🧠🎯⭐) based on predefined score ranges.",
            "status": "done",
            "testStrategy": "Test with various score values to ensure the correct icon is selected for each range."
          },
          {
            "id": 4,
            "title": "Implement Color Coding with Tailwind CSS",
            "description": "Apply color coding to the icon based on the score value using Tailwind CSS classes.",
            "dependencies": [],
            "details": "Create a function that takes the concept score as input and returns the appropriate Tailwind CSS class for the color (red -> orange -> green -> blue). Apply this class to the icon element.",
            "status": "done",
            "testStrategy": "Test with various score values to ensure the correct color is applied to the icon for each range."
          },
          {
            "id": 5,
            "title": "Integrate Component into Memo Card",
            "description": "Integrate the concept score icon component into the memo card UI.",
            "dependencies": [],
            "details": "Import the concept score icon component into the memo card component and render it in the upper right corner. Pass the `noteId` as a prop to the concept score icon component.",
            "status": "done",
            "testStrategy": "Verify the concept score icon is displayed correctly on the memo card with the correct icon and color based on the note's score. Test with different `noteId` values."
          }
        ]
      },
      {
        "id": 32,
        "title": "Implement Detailed Score Popup",
        "description": "Implement the detailed score popup that appears when the concept score icon is clicked, displaying the individual scores for each of the six areas.",
        "details": "1.  Create a new React component for the score popup.\n2.  Fetch the detailed scores for each of the six areas from the backend API or calculate them on the frontend if necessary.\n3.  Display the scores in a clear and organized manner within the popup.\n4.  Use Tailwind CSS to style the popup and ensure it is visually appealing.",
        "testStrategy": "Verify the score popup appears when the concept score icon is clicked. Ensure the individual scores for each area are displayed correctly. Test with different score values and ensure the popup content updates accordingly.",
        "priority": "medium",
        "dependencies": [
          31,
          27,
          29
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create React Component for Score Popup",
            "description": "Develop a new React component to serve as the foundation for the detailed score popup.",
            "dependencies": [],
            "details": "Create a functional or class-based React component. Define the basic structure and styling placeholders. Ensure the component can be rendered and displayed on the screen.",
            "status": "done",
            "testStrategy": "Verify the component renders without errors. Check that the basic structure is in place and that styling placeholders are visible."
          },
          {
            "id": 2,
            "title": "Fetch/Calculate Detailed Scores",
            "description": "Implement the logic to retrieve or calculate the detailed scores for each of the six areas.",
            "dependencies": [],
            "details": "Determine whether to fetch the scores from the backend API (Task 27) or calculate them on the frontend. Implement the necessary API calls or calculation logic. Handle potential errors during data retrieval or calculation.",
            "status": "done",
            "testStrategy": "Check that the correct scores are fetched from the API or calculated accurately. Verify error handling for API failures or invalid data."
          },
          {
            "id": 3,
            "title": "Display Scores in Popup",
            "description": "Organize and display the fetched/calculated scores within the popup component.",
            "dependencies": [],
            "details": "Structure the score data in a clear and understandable format. Use appropriate UI elements (e.g., tables, charts, lists) to display the scores for each area. Ensure the display is responsive and adapts to different screen sizes.",
            "status": "done",
            "testStrategy": "Verify that all six area scores are displayed correctly. Check the formatting and layout for clarity and readability. Test responsiveness on different devices."
          },
          {
            "id": 4,
            "title": "Style Popup with Tailwind CSS",
            "description": "Apply Tailwind CSS classes to style the popup and ensure it is visually appealing and consistent with the application's design.",
            "dependencies": [],
            "details": "Use Tailwind CSS classes to style the popup container, headings, labels, and score values. Ensure the popup has a consistent look and feel with the rest of the UI. Pay attention to typography, spacing, and color palette.",
            "status": "done",
            "testStrategy": "Verify that the popup styling matches the design specifications. Check for consistency with other UI elements. Ensure the popup is visually appealing and easy to read."
          },
          {
            "id": 5,
            "title": "Integrate Popup with Concept Score Icon",
            "description": "Connect the score popup to the concept score icon, so that clicking the icon triggers the popup to appear.",
            "dependencies": [],
            "details": "Implement the event handler for the concept score icon click. Use React state management to control the visibility of the popup. Ensure the popup appears in the correct position relative to the icon.",
            "status": "done",
            "testStrategy": "Verify that the popup appears when the concept score icon is clicked. Check that the popup closes when clicking outside of it or on a close button (if implemented). Ensure the popup position is correct."
          }
        ]
      },
      {
        "id": 33,
        "title": "Implement Quick Action Buttons",
        "description": "Implement the quick action buttons within the score popup, allowing users to take actions related to improving their concept understanding.",
        "details": "1.  Add buttons to the score popup for actions like \"Add Thoughts,\" \"Evolve Memo,\" \"Connect Knowledge,\" \"Create Flashcard,\" \"Add Tag,\" and \"Rate.\"\n2.  Implement the functionality for each button, such as navigating to the appropriate page or triggering an API call.\n3.  Ensure the buttons are styled consistently with the rest of the UI using Tailwind CSS.",
        "testStrategy": "Verify the quick action buttons are displayed correctly in the score popup. Ensure each button performs the correct action when clicked. Test with different user roles and permissions to ensure the buttons are enabled/disabled appropriately.",
        "priority": "medium",
        "dependencies": [
          32,
          28
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Quick Action Buttons to Score Popup UI",
            "description": "Add the specified quick action buttons (Add Thoughts, Evolve Memo, Connect Knowledge, Create Flashcard, Add Tag, Rate) to the score popup React component.",
            "dependencies": [],
            "details": "Modify the React component created in Task 32 to include the quick action buttons. Use Tailwind CSS for styling to ensure consistency with the existing UI.",
            "status": "done",
            "testStrategy": "Verify the quick action buttons are displayed correctly in the score popup and are visually consistent with the rest of the UI."
          },
          {
            "id": 2,
            "title": "Implement 'Add Thoughts' Action",
            "description": "Implement the functionality for the 'Add Thoughts' button. This likely involves navigating the user to a page where they can add thoughts related to the concept.",
            "dependencies": [],
            "details": "Determine the appropriate page or component for adding thoughts. Implement the navigation logic when the 'Add Thoughts' button is clicked.",
            "status": "done",
            "testStrategy": "Click the 'Add Thoughts' button and verify that the user is navigated to the correct page or component for adding thoughts."
          },
          {
            "id": 3,
            "title": "Implement 'Evolve Memo', 'Connect Knowledge', 'Create Flashcard' Actions",
            "description": "Implement the functionality for the 'Evolve Memo', 'Connect Knowledge', and 'Create Flashcard' buttons. These actions may involve navigating to different pages or triggering API calls.",
            "dependencies": [],
            "details": "Determine the appropriate actions for each button. Implement the navigation logic or API calls when the buttons are clicked.",
            "status": "done",
            "testStrategy": "Click each button and verify that the correct action is performed (navigation or API call)."
          },
          {
            "id": 4,
            "title": "Implement 'Add Tag' and 'Rate' Actions",
            "description": "Implement the functionality for the 'Add Tag' and 'Rate' buttons. These actions may involve triggering API calls to update the concept's tags or rating.",
            "dependencies": [],
            "details": "Implement the API calls to update the concept's tags and rating when the buttons are clicked. Handle success and error responses appropriately.",
            "status": "done",
            "testStrategy": "Click each button and verify that the correct API call is made and the concept's tags or rating are updated accordingly."
          },
          {
            "id": 5,
            "title": "Test Quick Action Buttons with Different User Roles",
            "description": "Test the quick action buttons with different user roles and permissions to ensure the buttons are enabled/disabled appropriately.",
            "dependencies": [],
            "details": "Create different user roles with varying permissions. Log in with each role and verify that the quick action buttons are enabled or disabled based on the user's permissions.",
            "status": "done",
            "testStrategy": "Log in with different user roles and verify that the quick action buttons are enabled/disabled as expected based on the user's permissions."
          }
        ]
      },
      {
        "id": 34,
        "title": "Implement Score Calculation Caching",
        "description": "Implement caching for the score calculation to improve performance and reduce the load on the database.",
        "details": "1.  Use a caching library like `node-cache` or Redis to store the calculated concept scores.\n2.  Implement a cache invalidation strategy to ensure the cache is updated when the underlying data changes.\n3.  Consider using a time-to-live (TTL) value for the cache entries to prevent stale data.",
        "testStrategy": "Measure the response time of the GET `/api/notes/:noteId/concept-score` endpoint with and without caching. Verify the response time is significantly faster with caching enabled. Ensure the cache is invalidated correctly when the underlying data changes.",
        "priority": "medium",
        "dependencies": [
          29
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Optimize Real-time Score Updates",
        "description": "Optimize the real-time score updates to minimize the impact on performance and ensure a smooth user experience.",
        "details": "1.  Use techniques like debouncing or throttling to limit the frequency of score updates.\n2.  Consider using a message queue (e.g., RabbitMQ or Kafka) to handle score updates asynchronously.\n3.  Optimize the database queries used in the score calculation engine.",
        "testStrategy": "Simulate a high volume of score updates and measure the impact on performance. Verify the system can handle the load without significant degradation. Ensure the user experience remains smooth and responsive.",
        "priority": "medium",
        "dependencies": [
          28,
          29
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Debouncing/Throttling for Score Updates",
            "description": "Implement debouncing or throttling techniques to limit the frequency of score updates sent to the client, reducing server load and improving UI responsiveness.",
            "dependencies": [],
            "details": "Research and implement either debouncing or throttling. Configure the optimal delay based on testing. Ensure that the final score is always reflected eventually.",
            "status": "done",
            "testStrategy": "Simulate rapid score changes and verify that updates are sent at the configured rate. Measure the impact on server load and UI responsiveness."
          },
          {
            "id": 2,
            "title": "Evaluate and Implement Message Queue for Asynchronous Updates",
            "description": "Evaluate the feasibility of using a message queue (e.g., RabbitMQ or Kafka) to handle score updates asynchronously, decoupling the score calculation engine from the UI and improving scalability.",
            "dependencies": [],
            "details": "Research RabbitMQ and Kafka. Set up a test environment with one of the message queues. Implement a simple producer/consumer to test asynchronous score updates.",
            "status": "done",
            "testStrategy": "Simulate a high volume of score updates and measure the message queue's performance. Verify that all updates are processed correctly and eventually reflected in the UI."
          },
          {
            "id": 3,
            "title": "Optimize Database Queries in Score Calculation Engine",
            "description": "Analyze and optimize the database queries used in the real-time score calculation engine to reduce query execution time and database load.",
            "dependencies": [],
            "details": "Profile the database queries used by the score calculation engine. Identify slow queries and optimize them using techniques like indexing, query rewriting, or caching.",
            "status": "done",
            "testStrategy": "Measure the execution time of the optimized queries and compare them to the original queries. Verify that the optimization reduces database load and improves overall performance."
          },
          {
            "id": 4,
            "title": "Profile and Optimize Score Calculation Logic",
            "description": "Profile the score calculation engine to identify performance bottlenecks within the scoring algorithms themselves and optimize the code for efficiency.",
            "dependencies": [],
            "details": "Use profiling tools to identify the most time-consuming parts of the score calculation logic. Optimize the code by using efficient algorithms, data structures, and coding techniques.",
            "status": "done",
            "testStrategy": "Measure the execution time of the optimized score calculation logic and compare it to the original logic. Verify that the optimization reduces CPU usage and improves overall performance."
          },
          {
            "id": 5,
            "title": "Performance Testing and User Experience Validation",
            "description": "Conduct performance testing to simulate a high volume of score updates and validate that the system can handle the load without significant degradation. Ensure the user experience remains smooth and responsive.",
            "dependencies": [
              "35.1",
              "35.2",
              "35.3",
              "35.4"
            ],
            "details": "Simulate a realistic workload of score updates. Monitor system performance metrics such as CPU usage, memory usage, and response time. Gather user feedback on the smoothness and responsiveness of the UI.",
            "status": "done",
            "testStrategy": "Use load testing tools to simulate a high volume of concurrent users and score updates. Measure the system's throughput, latency, and error rate. Conduct user testing to gather feedback on the user experience."
          }
        ]
      },
      {
        "id": 36,
        "title": "Implement Database Indexing",
        "description": "Implement database indexing to improve the performance of queries related to concept scores.",
        "details": "1.  Identify the columns used in queries related to concept scores (e.g., `noteId` in the `concept_scores` table).\n2.  Create indexes on these columns to speed up query execution.\n3.  Use the `EXPLAIN` command in PostgreSQL to analyze query performance and identify areas for improvement.",
        "testStrategy": "Measure the response time of queries related to concept scores with and without indexing. Verify the response time is significantly faster with indexing enabled. Monitor the database performance to ensure the indexes are being used effectively.",
        "priority": "medium",
        "dependencies": [
          26
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Write Unit Tests for Score Calculation",
        "description": "Write unit tests for the score calculation logic using Jest to ensure the algorithms are accurate and reliable.",
        "details": "1.  Install Jest and its TypeScript typings: `npm install --save-dev jest @types/jest ts-jest`.\n2.  Configure Jest in `jest.config.js`.\n3.  Write unit tests for each of the six scoring areas, covering different input values and edge cases.\n4.  Use Jest's assertion library to verify the scores are calculated correctly.",
        "testStrategy": "Run the Jest unit tests and verify all tests pass. Ensure the tests cover all critical aspects of the score calculation logic.",
        "priority": "high",
        "dependencies": [
          29
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "Write Integration Tests for API Endpoints",
        "description": "Write integration tests for the API endpoints using Jest and Supertest to ensure the endpoints are functioning correctly and interacting with the database as expected.",
        "details": "1.  Install Supertest: `npm install supertest --save-dev`.\n2.  Write integration tests for the GET `/api/notes/:noteId/concept-score` and POST `/api/notes/:noteId/update-score` endpoints.\n3.  Use Supertest to send HTTP requests to the endpoints and verify the responses.\n4.  Ensure the tests cover different scenarios, such as valid and invalid input values, and database errors.",
        "testStrategy": "Run the Jest integration tests and verify all tests pass. Ensure the tests cover all critical aspects of the API endpoints.",
        "priority": "high",
        "dependencies": [
          27,
          28
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "Write E2E Tests for UI Flow",
        "description": "Write end-to-end (E2E) tests for the UI flow using Cypress or Playwright to ensure the user interface is functioning correctly and the user experience is smooth.",
        "details": "1.  Install Cypress or Playwright: `npm install cypress --save-dev` or `npm install playwright --save-dev`.\n2.  Write E2E tests to simulate user interactions with the concept score icon, score popup, and quick action buttons.\n3.  Verify the UI elements are displayed correctly and the user can navigate through the flow without errors.",
        "testStrategy": "Run the Cypress or Playwright E2E tests and verify all tests pass. Ensure the tests cover all critical aspects of the UI flow.",
        "priority": "medium",
        "dependencies": [
          31,
          32,
          33
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-07T08:48:57.524Z",
      "updated": "2025-07-24T21:47:57.985Z",
      "description": "Tasks for pdf-scroll-feature context"
    }
  },
  "seo-optimization": {
    "tasks": [
      {
        "id": 19,
        "title": "Project Setup and Dependency Installation",
        "description": "Initialize the React project with TypeScript, Tailwind CSS, Framer Motion, and Zustand.",
        "details": "Use Create React App with TypeScript template or Vite to scaffold the project. Install necessary dependencies: `npm install react react-dom typescript @types/react @types/react-dom tailwindcss framer-motion zustand`. Configure Tailwind CSS by running `npx tailwindcss init -p` and updating `tailwind.config.js` and `index.css` files. Set up Zustand store for global state management.",
        "testStrategy": "Verify that the project compiles successfully and all dependencies are correctly installed. Run initial tests to ensure basic functionality.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Create TimeBasedMemoView Component and Basic Layout",
        "description": "Create the `TimeBasedMemoView` component and define the basic layout structure.",
        "details": "Create a new component file `TimeBasedMemoView.tsx`. Implement the main container with four sections representing the time zones: Morning, Afternoon, Evening, and Night. Use Tailwind CSS to style the layout. Each section should have a fixed size (300x300px for desktop).",
        "testStrategy": "Check if the layout is rendered correctly with the specified dimensions and time zone labels. Ensure responsiveness for different screen sizes.",
        "priority": "high",
        "dependencies": [
          19
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Implement Quadrant Division Logic",
        "description": "Implement the logic to divide each time zone section into four quadrants for memo point placement.",
        "details": "Within each time zone section, create four `div` elements representing the quadrants. Use CSS Grid or Flexbox to arrange them. Calculate the position of each memo point based on its timestamp and map it to the corresponding quadrant.",
        "testStrategy": "Verify that the quadrants are correctly positioned within each time zone. Test the memo point placement logic with sample data to ensure accurate distribution.",
        "priority": "medium",
        "dependencies": [
          20
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Render Memo Points with Dynamic Styling",
        "description": "Render memo points as circles within the quadrants, with size based on memo length and color based on concept understanding score.",
        "details": "Use `div` elements with rounded corners or SVG circles to represent memo points. Apply inline styles to set the size and color based on the memo's length and understanding score. Use the following color mapping: Red (0-30), Orange (31-60), Yellow (61-80), Green (81-100), Gray (archived).",
        "testStrategy": "Check if the memo points are rendered with the correct size and color based on the data. Verify the color mapping against the specified score ranges.",
        "priority": "high",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement Memo Point Hover Effect",
        "description": "Implement hover effect on memo points to display memo title, creation time, length, and understanding score.",
        "details": "Add an `onMouseEnter` event handler to each memo point. Display a tooltip or a small popup with the memo details. Use Framer Motion for smooth transitions. Consider using a library like Tippy.js for advanced tooltip functionality.",
        "testStrategy": "Test the hover effect on different memo points. Ensure that the correct information is displayed in the tooltip. Verify the tooltip positioning and styling.",
        "priority": "medium",
        "dependencies": [
          22
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Implement Memo Point Click Event and Modal",
        "description": "Implement click event on memo points to open a detailed memo card modal.",
        "details": "Add an `onClick` event handler to each memo point. When clicked, open a modal dialog displaying the full memo content. Use Zustand to manage the modal state. Implement keyboard navigation within the modal.",
        "testStrategy": "Test the click event on different memo points. Ensure that the modal opens with the correct memo content. Verify keyboard navigation within the modal.",
        "priority": "high",
        "dependencies": [
          23
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Implement Time Zone Filter",
        "description": "Implement time zone filter (All/Morning/Afternoon/Evening/Night).",
        "details": "Create a filter component with radio buttons or a select dropdown for time zone selection. Update the memo point rendering based on the selected time zone. Use Zustand to manage the filter state.",
        "testStrategy": "Test the time zone filter with different options. Ensure that only the memos from the selected time zone are displayed.",
        "priority": "medium",
        "dependencies": [
          24
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Implement Day of the Week Filter",
        "description": "Implement day of the week filter (Monday to Sunday checkboxes).",
        "details": "Create a filter component with checkboxes for each day of the week. Update the memo point rendering based on the selected days. Use Zustand to manage the filter state.",
        "testStrategy": "Test the day of the week filter with different combinations of days. Ensure that only the memos from the selected days are displayed.",
        "priority": "medium",
        "dependencies": [
          25
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Implement Date Range Filter",
        "description": "Implement date range selection filter.",
        "details": "Use a date picker library like `react-datepicker` or a custom date range input. Update the memo point rendering based on the selected date range. Use Zustand to manage the filter state.",
        "testStrategy": "Test the date range filter with different date ranges. Ensure that only the memos within the selected date range are displayed.",
        "priority": "medium",
        "dependencies": [
          26
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Apply Debouncing to Filtering",
        "description": "Apply debouncing to the filtering logic to improve performance.",
        "details": "Use a debouncing function (e.g., from Lodash or a custom implementation) to delay the filter application until the user has stopped typing or interacting with the filter controls for a certain period (e.g., 300ms).",
        "testStrategy": "Test the filtering performance with and without debouncing. Verify that the UI remains responsive during filtering.",
        "priority": "medium",
        "dependencies": [
          27
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Implement Memo Point Virtualization",
        "description": "Implement memo point virtualization to render only the visible memo points, improving performance with large datasets.",
        "details": "Use a virtualization library like `react-window` or `react-virtualized` to render only the memo points that are currently visible within the viewport. This significantly reduces the number of DOM elements and improves rendering performance.",
        "testStrategy": "Test the rendering performance with a large number of memo points. Verify that the UI remains smooth and responsive during scrolling and filtering.",
        "priority": "high",
        "dependencies": [
          28
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Apply Memoization to Memo Point Rendering",
        "description": "Apply memoization to the memo point rendering to prevent unnecessary re-renders.",
        "details": "Use `React.memo` to memoize the memo point component. This prevents re-renders if the props haven't changed. Also, use `useMemo` hook to memoize the calculation of memo point styles.",
        "testStrategy": "Use React Profiler to analyze the rendering performance. Verify that the memo point component is not re-rendering unnecessarily.",
        "priority": "medium",
        "dependencies": [
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Implement Responsive Design",
        "description": "Implement responsive design for different screen sizes (desktop, tablet, mobile).",
        "details": "Use Tailwind CSS's responsive modifiers to adjust the layout and styling for different screen sizes. For tablet (2x2 grid), use `md:` prefixes. For mobile (vertical stack), use `sm:` prefixes. Use `react-responsive` library for conditional rendering based on screen size.",
        "testStrategy": "Test the layout on different devices and screen sizes. Verify that the layout adapts correctly and the memo points are displayed appropriately.",
        "priority": "high",
        "dependencies": [
          30
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Implement Keyboard Navigation",
        "description": "Implement keyboard navigation for memo point selection and modal interaction.",
        "details": "Use `tabIndex` to enable keyboard focus on memo points. Implement `onKeyDown` event handlers to handle arrow key navigation. Ensure that the modal is also fully keyboard accessible.",
        "testStrategy": "Test keyboard navigation with different keyboard layouts. Verify that the focus is managed correctly and the user can navigate through the memo points and modal elements.",
        "priority": "medium",
        "dependencies": [
          31
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Implement Accessibility Features",
        "description": "Ensure screen reader compatibility and implement high contrast mode support.",
        "details": "Use semantic HTML elements and ARIA attributes to improve screen reader compatibility. Provide alternative text for images and icons. Implement a high contrast mode using CSS variables and a toggle button.",
        "testStrategy": "Test the application with different screen readers (e.g., NVDA, VoiceOver). Verify that the content is read correctly and the user can navigate through the application. Test the high contrast mode and ensure that the colors are adjusted appropriately.",
        "priority": "low",
        "dependencies": [
          32
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-24T21:49:12.889Z",
      "updated": "2025-07-27T03:22:36.518Z",
      "description": "Tasks for seo-optimization context"
    }
  },
  "memo-time-view": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement TimeBasedMemoView Basic Structure and Time Zone Layout",
        "description": "Create the basic structure of the TimeBasedMemoView component and implement the time zone-based layout. This involves arranging four time zones (Morning, Afternoon, Evening, Midnight) in a clockwise direction and creating a basic UI that divides each time zone into quadrants.",
        "details": "1.  Create a new React component named `TimeBasedMemoView`.\n2.  Implement the basic structure using `div` elements to represent the main container and the four time zones.\n3.  Use CSS to arrange the time zones in a circular (clockwise) layout. Consider using flexbox or grid for layout management.\n4.  Divide each time zone into four quadrants using nested `div` elements.\n5.  Apply basic styling (e.g., borders, background colors) to visually differentiate the time zones and quadrants.\n6.  Ensure the component is responsive and adapts to different screen sizes.\n7.  Add placeholder content or icons to each quadrant to indicate where memos will be displayed.\n8.  Implement a data structure to represent the time zones and their corresponding memos. This structure should be easily adaptable for future memo integration.\n9.  Consider using a library like `styled-components` for managing component styles.\n10. Document the component's structure and usage in the project's documentation.",
        "testStrategy": "1.  Verify that the `TimeBasedMemoView` component renders correctly without any errors.\n2.  Check that the four time zones (Morning, Afternoon, Evening, Midnight) are arranged in a clockwise direction.\n3.  Ensure that each time zone is divided into four quadrants.\n4.  Test the responsiveness of the component by resizing the browser window and verifying that the layout adapts correctly.\n5.  Inspect the CSS to ensure that the correct styles are applied to the time zones and quadrants.\n6.  Verify that the placeholder content or icons are displayed correctly in each quadrant.\n7.  Manually test the component on different devices and browsers to ensure cross-browser compatibility.\n8.  Write unit tests to verify the component's rendering and layout logic.",
        "status": "pending",
        "dependencies": [
          6,
          7
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Memo Dot Rendering Component",
        "description": "Implement a memo dot rendering component with dynamic sizing based on memo length and color coding based on concept understanding score. Add hover functionality to display memo information as a mini card (same as list mode) and navigation to the book details page on click.",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "1. Create a new React component named `MemoDot`. This component will be responsible for rendering a circular dot representing a memo.\n2. Implement logic to determine the size of the dot based on the length of the memo text. Use the following sizes: 6px for short memos, 8px for medium memos, and 12px for long memos. Define thresholds for memo length to categorize them as short, medium, or long.\n3. Implement logic to determine the color of the dot based on the concept understanding score. Use the following colors: red for low scores, orange for medium-low scores, yellow for medium scores, green for medium-high scores, and gray for high scores. Define score ranges for each color.\n4. Add a hover effect to the `MemoDot` component. When the user hovers over the dot, display a mini memo card, mirroring the display from the current list mode.\n5. Implement a click event on the `MemoDot` component. Clicking the dot should navigate the user to the book details page associated with the memo.\n6. Use CSS to style the dot with the appropriate size and color. Ensure that the hover effect is visually appealing and does not obscure other elements on the screen.\n7. Consider using a library like `react-tooltip` or `react-popup` to implement the tooltip/popup functionality for the hover effect.\n8. Ensure the component is performant and handles a large number of memos efficiently.",
        "testStrategy": "1. Verify that the `MemoDot` component renders correctly with different memo lengths and concept understanding scores.\n2. Check that the size of the dot changes dynamically based on the memo length, using the specified sizes (6px, 8px, 12px).\n3. Ensure that the color of the dot changes dynamically based on the concept understanding score, using the specified colors (red, orange, yellow, green, gray).\n4. Test the hover functionality to ensure that a mini memo card (same as list mode) is displayed when the user hovers over the dot.\n5. Verify that the mini memo card is positioned correctly and does not obscure other elements on the screen.\n6. Test the click functionality to ensure that clicking the dot navigates the user to the correct book details page.\n7. Test the component with a large number of memos to ensure that it remains performant and does not cause any performance issues.\n8. Write unit tests to cover all the different scenarios and edge cases.",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Time-Based Filtering with Radio Buttons and Checkboxes",
        "description": "Implement time-based filtering functionality with radio buttons for time zones and checkboxes for days of the week, applying real-time filtering to the memo display.",
        "details": "1.  Add radio buttons for 'All', 'Morning', 'Afternoon', 'Evening', and 'Midnight' time zones.\n2.  Implement checkboxes for each day of the week (Monday to Sunday).\n3.  Use React state to manage the selected time zone and days of the week.\n4.  Implement a filtering function that filters memos based on the selected time zone and days of the week.\n5.  Ensure that the filtering is applied in real-time as the user selects or deselects options.\n6.  Update the TimeBasedMemoView component to display only the filtered memos.\n7.  Consider using a library like Moment.js or date-fns for date and time manipulation.\n8.  Optimize the filtering logic to ensure efficient performance, especially with a large number of memos.",
        "testStrategy": "1.  Verify that the radio buttons and checkboxes are rendered correctly.\n2.  Check that selecting a time zone filters the memos to display only those within the selected time zone.\n3.  Ensure that selecting multiple days of the week filters the memos to display only those on the selected days.\n4.  Test that the filtering is applied in real-time as the user interacts with the controls.\n5.  Verify that the 'All' radio button displays all memos.\n6.  Test with different combinations of time zones and days of the week to ensure accurate filtering.\n7.  Check the performance of the filtering with a large number of memos.\n8.  Ensure that the UI updates correctly when the filter is applied.",
        "status": "pending",
        "dependencies": [
          1,
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Memo Card Details Modal with Edit/Delete Functionality",
        "description": "Update the memo card details modal to navigate to the book details page on click. Modify the mini display mode to only show on hover.",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "details": "1.  Modify the existing React component for the memo card details modal.\n2.  Implement logic to open the book details page when a memo dot is clicked instead of displaying the modal.\n3.  Remove the display of memo details (title, creation time, understanding score, and content) within the modal.\n4.  Remove 'Edit' and 'Delete' buttons from the modal.\n5.  Modify the mini display mode to only show on hover, displaying memo information as a mini card (same as list mode).\n6.  Ensure the modal is styled appropriately for a clear and intuitive user experience.\n7.  Handle edge cases such as missing memo data or failed API requests.",
        "testStrategy": "1.  Verify that clicking a memo dot navigates to the book details page.\n2.  Check that the memo details modal no longer displays memo details (title, creation time, understanding score, content).\n3.  Ensure that the 'Edit' and 'Delete' buttons are removed from the modal.\n4.  Verify that the mini display mode only shows on hover, displaying memo information as a mini card (same as list mode).\n5.  Verify that appropriate error messages are displayed for edge cases such as missing memo data or failed API requests.\n6.  Test the modal's responsiveness on different screen sizes.",
        "subtasks": [
          {
            "id": 1,
            "title": "",
            "description": "Create a new React component for the memo card details modal.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "",
            "description": "Implement logic to open the modal when a memo dot is clicked.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "",
            "description": "Fetch and display the memo title, creation time, understanding score, and content within the modal.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "",
            "description": "Add 'Edit' and 'Delete' buttons to the modal.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "",
            "description": "Implement the 'Edit' functionality to allow users to modify the memo content.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "",
            "description": "Implement the 'Delete' functionality to remove the memo.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "",
            "description": "Ensure the modal is styled appropriately for a clear and intuitive user experience.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "",
            "description": "Handle edge cases such as missing memo data or failed API requests.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "",
            "description": "Modify the existing React component to navigate to the book details page on click.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "",
            "description": "Remove the display of memo details within the modal.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "",
            "description": "Remove 'Edit' and 'Delete' buttons from the modal.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 12,
            "title": "",
            "description": "Modify the mini display mode to only show on hover.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Mini Display Mode Component",
        "description": "Implement a mini display mode component that shows a mini memo card on mouseover, mirroring the list mode's appearance. This component will display memo title, creation time, understanding score, and a content preview.",
        "details": "1. Create a new React component named `MiniMemoDisplay`. This component will be responsible for rendering the mini memo card.\n2. Implement logic to display the memo title, creation time, understanding score, and a content preview within the `MiniMemoDisplay` component.\n3. Ensure the styling of the `MiniMemoDisplay` component matches the appearance of the memo card in list mode.\n4. Implement mouseover functionality to display the `MiniMemoDisplay` component when the user hovers over a memo dot or list item.\n5. Position the `MiniMemoDisplay` component appropriately relative to the hovered element.\n6. Ensure the `MiniMemoDisplay` component disappears when the mouse leaves the hovered element.",
        "testStrategy": "1. Verify that the `MiniMemoDisplay` component renders correctly with all the required information (memo title, creation time, understanding score, content preview).\n2. Check that the styling of the `MiniMemoDisplay` component matches the list mode's memo card appearance.\n3. Ensure that the `MiniMemoDisplay` component appears on mouseover of a memo dot or list item.\n4. Verify that the `MiniMemoDisplay` component is positioned correctly relative to the hovered element.\n5. Check that the `MiniMemoDisplay` component disappears when the mouse leaves the hovered element.\n6. Test with various memo lengths and content to ensure proper display and responsiveness.",
        "status": "pending",
        "dependencies": [
          2,
          4
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Memo Dot Navigation to Book Details Page",
        "description": "Implement navigation from memo details to the book details page by clicking on the memo dot. This will leverage the existing routing system.",
        "details": "1. Modify the `MemoDot` component to include a navigation link to the book details page.\n2. The navigation link should be triggered when the memo dot is clicked.\n3. Extract the book ID from the memo object.\n4. Use the `useNavigate` hook from `react-router-dom` to navigate to the book details page, passing the book ID as a parameter in the URL.\n5. Ensure that the navigation is smooth and does not cause any performance issues.\n6. Update the component to handle cases where the book ID is not available or invalid.",
        "testStrategy": "1. Verify that clicking on a memo dot navigates to the correct book details page.\n2. Check that the correct book ID is passed as a parameter in the URL.\n3. Ensure that the navigation is smooth and does not cause any performance issues.\n4. Test the navigation with different memo objects and book IDs.\n5. Verify that the component handles cases where the book ID is not available or invalid gracefully.",
        "status": "pending",
        "dependencies": [
          4
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Diagram Canvas Feature in 단권화 노트",
        "description": "Implement a diagram canvas feature in the 단권화 노트, featuring a 3-panel layout (memo cards, canvas, markdown editor), intuitive relationship representation, and screenshot saving. The implementation will involve displaying memo cards with sequential numbering and corresponding icons, arranging all icons on the top-left of the canvas panel, allowing users to drag icons onto the canvas and connect them with 5 relationship links, and saving a screenshot of the completed diagram to a fixed location on the 단권화 노트 page.",
        "status": "done",
        "dependencies": [
          2,
          4
        ],
        "priority": "medium",
        "details": "1.  **Layout Implementation:**\n    *   Create a 3-panel layout using a suitable UI framework (e.g., React with a grid system or flexbox). The panels should be resizable.\n    *   Left Panel: Memo cards with sequential numbering and corresponding icons based on the knowledge cart order. \n    *   Center Panel: Diagram canvas for relationship visualization. Use a library like react-flow or similar for interactive diagram creation. Initialize the canvas. All icons should be arranged on the top-left of this panel.\n    *   Right Panel: Markdown editor for detailed notes. Integrate a markdown editor component (e.g., react-markdown or similar).\n2.  **Relationship Representation:**\n    *   Define the 5 relationship types: cause-effect, before-after, base-extension, inclusion, contrast.\n    *   Implement visual cues for each relationship type on the diagram canvas (e.g., different arrow styles, colors, or icons).\n    *   Allow users to create and connect nodes on the canvas by dragging icons, specifying the relationship type for each connection. Users should be able to modify and delete these connections.\n3.  **Memo Card Integration:**\n    *   Assign sequential numbering to memo cards based on their order in the knowledge cart and associate them with corresponding icons.\n4.  **Markdown Editor Integration:**\n    *   Link the markdown editor to the selected node on the canvas. When a node is selected, display its associated markdown content in the editor.\n    *   Implement two-way data binding between the node content and the markdown editor. Changes in the editor should update the node content, and vice versa.\n5.  **Screenshot Saving:**\n    *   Add a button to save the diagram as a screenshot.\n    *   Use a library like html-to-image or dom-to-image to capture the canvas content as an image.\n    *   Save the screenshot to a fixed location on the 단권화 노트 page, outside the markdown editor.\n6.  **Accessibility Considerations:**\n    *   Ensure the diagram canvas is accessible to users with disabilities by providing keyboard navigation and screen reader support.\n    *   Use ARIA attributes to describe the relationships between nodes and the purpose of each element on the canvas.\n7.  **Error Handling:**\n    *   Implement error handling for cases where the diagram cannot be saved or when data cannot be loaded.\n    *   Display informative error messages to the user.\n8.  **Performance Optimization:**\n    *   Optimize the rendering of the diagram canvas to handle large diagrams with many nodes and connections.\n    *   Use virtualization techniques to render only the visible portion of the canvas.\n",
        "testStrategy": "1.  **Layout Verification:**\n    *   Verify that the 3-panel layout is rendered correctly with the memo card panel on the left, the diagram canvas in the center, and the markdown editor on the right.\n    *   Check that the panels are resizable and that the content within each panel is displayed correctly.\n    *   Verify that memo cards in the left panel are sequentially numbered and have corresponding icons.\n    *   Confirm that all icons are arranged on the top-left of the canvas panel.\n2.  **Relationship Representation Verification:**\n    *   Verify that the 5 relationship types are visually represented on the diagram canvas with distinct cues (e.g., different arrow styles, colors, or icons).\n    *   Test the creation and connection of nodes on the canvas by dragging icons, ensuring that the relationship type can be specified for each connection. Verify the ability to modify and delete connections.\n3.  **Memo Card Integration Verification:**\n    *   Verify that memo cards are sequentially numbered based on their order in the knowledge cart and associated with corresponding icons.\n4.  **Markdown Editor Integration Verification:**\n    *   Verify that the markdown editor is linked to the selected node on the canvas and that the content of the node is displayed in the editor.\n    *   Test the two-way data binding between the node content and the markdown editor, ensuring that changes in the editor update the node content, and vice versa.\n5.  **Screenshot Saving Verification:**\n    *   Verify that the diagram can be saved as a screenshot by clicking the save button.\n    *   Check that the screenshot is saved to the specified fixed location on the 단권화 노트 page.\n6.  **Accessibility Testing:**\n    *   Use a screen reader to verify that the diagram canvas is accessible to users with disabilities.\n    *   Check that keyboard navigation is supported and that ARIA attributes are used to describe the relationships between nodes and the purpose of each element on the canvas.\n7.  **Error Handling Testing:**\n    *   Simulate error conditions (e.g., failed save operation, data loading error) and verify that informative error messages are displayed to the user.\n8.  **Performance Testing:**\n    *   Create a large diagram with many nodes and connections and verify that the rendering of the canvas is optimized and that the application remains responsive.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement 3-Panel Layout and Basic Components",
            "description": "Create the 3-panel layout (memo cards, canvas, markdown editor) using React and a suitable UI framework. Implement basic rendering of memo cards with sequential numbering in the left panel. Initialize the diagram canvas in the center panel using a library like react-flow. Integrate a basic markdown editor component in the right panel.",
            "status": "done",
            "dependencies": [],
            "details": "Create a 3-panel layout using a suitable UI framework (e.g., React with a grid system or flexbox). The panels should be resizable. Left Panel: Memo cards with sequential numbering. Fetch memo data and render each memo as a card with its number. Center Panel: Diagram canvas for relationship visualization. Use a library like react-flow or similar for interactive diagram creation. Initialize the canvas. Right Panel: Markdown editor for detailed notes. Integrate a markdown editor component (e.g., react-markdown or similar).",
            "testStrategy": "Verify that the 3-panel layout is rendered correctly with the memo card panel on the left, the diagram canvas in the center, and the markdown editor on the right. Check that the panels are resizable and that the content within each panel is displayed correctly."
          },
          {
            "id": 2,
            "title": "Implement Relationship Representation on Canvas",
            "description": "Define the 5 relationship types (cause-effect, before-after, base-extension, inclusion, contrast) and implement visual cues for each type on the diagram canvas. Allow users to create and connect nodes, specifying the relationship type for each connection.",
            "status": "done",
            "dependencies": [],
            "details": "Define the 5 relationship types: cause-effect, before-after, base-extension, inclusion, contrast. Implement visual cues for each relationship type on the diagram canvas (e.g., different arrow styles, colors, or icons). Allow users to create and connect nodes on the canvas, specifying the relationship type for each connection.",
            "testStrategy": "Verify that the relationship types are correctly represented on the canvas with distinct visual cues. Check that users can create and connect nodes, specifying the relationship type for each connection."
          },
          {
            "id": 3,
            "title": "Implement Memo Card Drag-and-Drop to Canvas",
            "description": "Enable drag-and-drop functionality from the memo card panel to the diagram canvas to create nodes. When a memo card is dragged onto the canvas, create a corresponding node with the memo content.",
            "status": "done",
            "dependencies": [],
            "details": "Enable drag-and-drop functionality from the memo card panel to the diagram canvas to create nodes. When a memo card is dragged onto the canvas, create a corresponding node with the memo content.",
            "testStrategy": "Verify that memo cards can be dragged from the memo card panel to the diagram canvas. Check that a corresponding node is created on the canvas with the memo content when a card is dropped."
          },
          {
            "id": 4,
            "title": "Implement Markdown Editor Integration and Two-Way Data Binding",
            "description": "Link the markdown editor to the selected node on the canvas. When a node is selected, display its associated markdown content in the editor. Implement two-way data binding between the node content and the markdown editor.",
            "status": "done",
            "dependencies": [],
            "details": "Link the markdown editor to the selected node on the canvas. When a node is selected, display its associated markdown content in the editor. Implement two-way data binding between the node content and the markdown editor. Changes in the editor should update the node content, and vice versa.",
            "testStrategy": "Verify that the markdown editor displays the content of the selected node on the canvas. Check that changes in the editor update the node content, and vice versa."
          },
          {
            "id": 5,
            "title": "Implement Screenshot Saving Functionality",
            "description": "Add a button to save the diagram as a screenshot. Use a library like html-to-image or dom-to-image to capture the canvas content as an image. Allow users to download the image as a PNG or JPG file.",
            "status": "done",
            "dependencies": [],
            "details": "Add a button to save the diagram as a screenshot. Use a library like html-to-image or dom-to-image to capture the canvas content as an image. Allow users to download the image as a PNG or JPG file.",
            "testStrategy": "Verify that clicking the save button captures the canvas content as an image. Check that users can download the image as a PNG or JPG file."
          },
          {
            "id": 6,
            "title": "Assign Sequential Numbering and Icons to Memo Cards",
            "description": "Assign sequential numbering to memo cards based on their order in the knowledge cart and associate them with corresponding icons.",
            "status": "done",
            "dependencies": [],
            "details": "Fetch memo data and assign sequential numbers based on the order in the knowledge cart. Associate each number with a corresponding icon. Display the number and icon on the memo card.",
            "testStrategy": "Verify that memo cards are sequentially numbered based on their order in the knowledge cart. Check that each number is associated with a corresponding icon and that both are displayed on the memo card."
          },
          {
            "id": 7,
            "title": "Arrange Icons on Canvas Panel",
            "description": "Arrange all icons on the top-left of the canvas panel.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Position all icons used for relationship representation on the top-left corner of the diagram canvas. Ensure they are visually distinct and easily accessible.",
            "testStrategy": "Verify that all icons are positioned on the top-left corner of the canvas panel. Check that they are visually distinct and easily accessible."
          },
          {
            "id": 8,
            "title": "Implement Drag and Connect Functionality with Relationship Links",
            "description": "Allow users to drag icons onto the canvas and connect them with 5 relationship links. Implement functionality to modify and delete these connections.",
            "status": "done",
            "dependencies": [
              2,
              7
            ],
            "details": "Enable users to drag icons representing memos from the memo card panel or the icon list on the canvas onto the diagram canvas. Allow them to connect these icons using the 5 defined relationship links (cause-effect, before-after, base-extension, inclusion, contrast). Implement functionality to modify the type of relationship and delete existing connections.",
            "testStrategy": "Verify that users can drag icons onto the canvas. Check that they can connect icons using the 5 relationship links. Ensure that they can modify the type of relationship and delete existing connections."
          },
          {
            "id": 9,
            "title": "Save Screenshot to Fixed Location",
            "description": "Save the screenshot of the completed diagram to a fixed location on the 단권화 노트 page, outside the markdown editor.",
            "status": "done",
            "dependencies": [
              5
            ],
            "details": "Modify the screenshot saving functionality to save the captured image to a predefined, fixed location on the 단권화 노트 page. This location should be outside of the markdown editor panel.",
            "testStrategy": "Verify that the screenshot is saved to the correct fixed location on the 단권화 노트 page. Ensure that the saved image is accessible and displays the complete diagram."
          },
          {
            "id": 10,
            "title": "Replace Memo Card Drag with Icon Drag from Canvas Top-Left",
            "description": "Replace the memo card drag-and-drop functionality with the ability to drag memo icons from the top-left of the canvas onto the canvas to create nodes.",
            "status": "done",
            "dependencies": [
              3,
              7
            ],
            "details": "Instead of dragging memo cards, users should drag the sequentially numbered memo icons from the top-left of the canvas panel onto the canvas to create nodes. Remove the existing memo card drag-and-drop functionality.\n<info added on 2025-08-02T07:30:09.735Z>\n현재 구현 상태 확인:\n\n1. 메모카드 자체에는 드래그 기능이 없음 - ✅ 완료\n2. 아이콘 팔레트에서만 드래그 가능 - ✅ 완료  \n3. 순번 표시 - ✅ 완료\n4. 색상 선택 기능 - ✅ 완료\n\n현재 구현이 이미 사용자 요구사항을 만족하고 있습니다:\n- 메모카드들은 단순히 표시만 되고 드래그 기능이 없음\n- 캔버스 상단의 아이콘 팔레트에서만 드래그 가능\n- 각 아이콘에 순번이 표시됨\n- 아이콘 클릭으로 색상 변경 가능\n\n추가 개선사항:\n- 아이콘 팔레트의 UI를 더 명확하게 개선\n- 드래그 시 시각적 피드백 강화\n</info added on 2025-08-02T07:30:09.735Z>",
            "testStrategy": "Verify that users can drag memo icons from the top-left of the canvas onto the canvas to create nodes. Ensure that the original memo card drag-and-drop functionality is removed."
          }
        ]
      },
      {
        "id": 8,
        "title": "Add Diagram Field to Backend SummaryNote Schema",
        "description": "Extend the backend SummaryNote schema to include a diagram field and related subschemas for storing diagram data, enabling the persistence of visual representations within notes.",
        "details": "1.  Define the schema for the diagram field, including subschemas for nodes, edges, and other relevant diagram components. Consider using a JSON-based format for storing the diagram data.\n2.  Integrate the new diagram schema into the existing SummaryNoteSchema.\n3.  Ensure that the diagram field is optional to maintain backward compatibility with existing notes.\n4.  Implement validation logic to ensure that the diagram data conforms to the defined schema.\n5.  Update the data access layer to support saving and retrieving diagram data from the database.\n6.  Consider the performance implications of storing large diagram datasets and implement appropriate optimization strategies.",
        "testStrategy": "1.  Create new SummaryNote objects with diagram data and verify that the data is saved correctly to the database.\n2.  Retrieve SummaryNote objects with diagram data and verify that the data is loaded correctly.\n3.  Update existing SummaryNote objects to include diagram data and verify that the updates are saved correctly.\n4.  Test the validation logic to ensure that invalid diagram data is rejected.\n5.  Measure the performance of saving and retrieving SummaryNote objects with diagram data and identify any performance bottlenecks.\n6.  Verify that the diagram field is optional and that existing notes without diagram data can still be loaded and saved correctly.",
        "status": "done",
        "dependencies": [
          7
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Diagram Update Logic in Backend Controller",
        "description": "Add diagram update logic to the backend controller, including processing the diagram field in the updateSummaryNote function and implementing a diagram data validation function.",
        "details": "1.  Modify the `updateSummaryNote` function in the backend controller to handle the `diagram` field.\n2.  Implement logic to extract the diagram data from the request body.\n3.  Implement a diagram data validation function to ensure that the diagram data conforms to the defined schema (defined in Task 8).\n4.  If the diagram data is valid, update the `diagram` field in the SummaryNote object.\n5.  If the diagram data is invalid, return an error response to the client.\n6.  Ensure that the existing functionality of the `updateSummaryNote` function is not affected by the changes.\n7.  Add logging to track diagram updates and validation results.",
        "testStrategy": "1.  Create a new SummaryNote object with diagram data.\n2.  Update the SummaryNote object with valid diagram data and verify that the data is updated correctly in the database.\n3.  Update the SummaryNote object with invalid diagram data and verify that an error response is returned to the client.\n4.  Verify that the existing functionality of the `updateSummaryNote` function is not affected by the changes.\n5.  Check the logs to ensure that diagram updates and validation results are being tracked correctly.",
        "status": "done",
        "dependencies": [
          8
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Update Frontend Type Definitions for Diagram Field",
        "description": "Update frontend type definitions to include the diagram field and related types in the SummaryNoteData interface, ensuring type safety for diagram data.",
        "details": "1.  Modify the `SummaryNoteData` interface in the frontend to include the `diagram` field.\n2.  Define the type for the `diagram` field based on the backend schema defined in Task 8. This should include types for nodes, edges, and any other relevant diagram components.\n3.  Ensure that the `diagram` field is optional to maintain compatibility with existing notes that may not have diagram data.\n4.  Update any components or services that use the `SummaryNoteData` interface to handle the new `diagram` field.\n5.  Implement type checking and validation to ensure that the diagram data conforms to the defined schema.\n6.  Update the frontend data models to reflect the changes in the backend schema.",
        "testStrategy": "1.  Verify that the `SummaryNoteData` interface includes the `diagram` field with the correct type.\n2.  Create a new SummaryNote object with diagram data in the frontend and verify that it conforms to the updated type definitions.\n3.  Update an existing SummaryNote object with diagram data and verify that the frontend correctly handles the new `diagram` field.\n4.  Test the application with different diagram data scenarios to ensure that the type checking and validation are working correctly.\n5.  Ensure that the frontend components that use the `SummaryNoteData` interface are functioning correctly with the new `diagram` field.",
        "status": "done",
        "dependencies": [
          7,
          8
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Refactor Frontend Diagram Saving Logic",
        "description": "Modify the frontend diagram saving logic to ensure diagram data is transmitted in the correct structure via the saveDiagramAsImage function, while maintaining compatibility with existing code.",
        "details": "1.  Update the `saveDiagramAsImage` function to correctly format the `diagramData` before sending it to the backend.\n2.  Ensure that the diagram data structure matches the backend schema defined in Task 8 and used in Task 9.\n3.  Implement a transformation or mapping function to convert the current diagram data structure to the required format.\n4.  Add versioning or conditional logic to maintain compatibility with older versions of the frontend that may not have the new diagram structure.\n5.  Thoroughly test the updated `saveDiagramAsImage` function with different diagram configurations to ensure correct data transmission.\n6.  Consider adding logging or debugging statements to help identify any issues during data transformation or transmission.\n7.  Review and update any related documentation to reflect the changes in the diagram data structure and saving logic.",
        "testStrategy": "1.  Create various diagrams with different nodes, edges, and relationships.\n2.  Use the `saveDiagramAsImage` function to save each diagram.\n3.  Verify that the data sent to the backend is in the correct format by inspecting the network requests.\n4.  Check that the saved diagrams can be correctly loaded and displayed in the 단권화 노트.\n5.  Test the saving logic with older versions of the frontend to ensure compatibility is maintained.\n6.  Monitor the logs for any errors or warnings during the saving process.\n7.  Implement automated tests to verify the data transformation and transmission logic.",
        "status": "done",
        "dependencies": [
          7,
          10
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Modify Frontend Diagram Loading Logic",
        "description": "Modify the frontend diagram loading logic to correctly restore saved diagramData upon page load, ensuring compatibility with existing data structures.",
        "details": "1.  Update the diagram loading logic to retrieve diagramData from the appropriate storage (e.g., local storage or backend).\n2.  Implement a transformation function to convert the stored diagramData into the format expected by the diagram canvas component.\n3.  Handle cases where diagramData is missing or invalid, providing a default diagram or displaying an error message.\n4.  Ensure that the loading logic is compatible with different versions of diagramData, potentially using versioning or conditional logic.\n5.  Integrate the loading logic into the page load sequence, ensuring that the diagram is loaded as soon as possible after the page is ready.\n6.  Optimize the loading process to minimize performance impact, especially for large diagrams.",
        "testStrategy": "1.  Create diagrams with different nodes, edges, and relationships, and save them using the updated saving logic (Task 11).\n2.  Reload the page and verify that the saved diagrams are correctly restored on the canvas.\n3.  Test with different browsers and devices to ensure cross-browser compatibility.\n4.  Simulate scenarios where diagramData is missing or invalid and verify that the loading logic handles these cases gracefully.\n5.  Measure the loading time for different diagram sizes and optimize the loading process as needed.\n6.  Verify that the restored diagrams are fully interactive and that all features (e.g., node dragging, edge creation) work as expected.",
        "status": "done",
        "dependencies": [
          7,
          11
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Integration Testing and Validation - Diagram Save/Load Functionality",
        "description": "Perform integration testing and validation to ensure the diagram saving/loading functionality works correctly and is compatible with existing features.",
        "status": "done",
        "dependencies": [
          7,
          11,
          12
        ],
        "priority": "medium",
        "details": "1. Create comprehensive test cases covering various scenarios, including different diagram sizes, complexities, and data types.\n2. Verify that diagrams can be saved correctly using the updated saving logic (Task 11).\n3. Verify that saved diagrams can be loaded correctly using the modified loading logic (Task 12).\n4. Check for data integrity during the save and load processes, ensuring no data loss or corruption.\n5. Test compatibility with existing features, such as memo cards and markdown editor, to ensure no conflicts arise.\n6. Perform cross-browser testing to ensure consistent behavior across different browsers.\n7. Conduct performance testing to ensure that the saving and loading operations do not introduce significant delays or performance bottlenecks.\n8. Implement error handling to gracefully handle cases where saving or loading fails, providing informative error messages to the user.\n\nBased on the recent backend and frontend updates, the following validations are now included:\n- Backend schema validation for SummaryNote with diagram field, DiagramNode, and DiagramConnection subschemas.\n- Backend controller validation for updateSummaryNote function with diagram field processing and data validation using validateDiagramData function.\n- Frontend type definition validation for SummaryNoteData interface with diagram field and related types.\n- Frontend saving logic validation with improved saveDiagramAsImage function and data validation.\n- Frontend loading logic validation with improved fetchSummaryNoteDetails function and data filtering.",
        "testStrategy": "1. Create a suite of integration tests that cover the save and load functionality.\n2. Use a testing framework (e.g., Jest, Mocha) to automate the tests.\n3. Assert that the saved diagram data matches the original diagram data after loading.\n4. Verify that the diagram is rendered correctly on the canvas after loading.\n5. Test with different browsers and devices to ensure cross-browser compatibility.\n6. Monitor performance metrics, such as save and load times, to identify potential performance issues.\n7. Simulate error conditions, such as network failures or invalid data, to verify error handling.\n8. Verify the correct handling of the new diagram field in the SummaryNote schema during save and load operations.\n9. Ensure the updated saveDiagramAsImage function correctly formats and transmits diagram data.\n10. Validate the fetchSummaryNoteDetails function correctly loads and processes diagram data, maintaining compatibility with existing data.\n11. Confirm that the backend controller's updateSummaryNote function correctly processes the diagram field and validates diagram data.",
        "subtasks": [
          {
            "id": 1,
            "title": "Backend Schema Validation",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "- SummaryNote schema updated with diagram field\n- DiagramNode, DiagramConnection subschemas defined\n- RelationshipType enum defined\n- Indexes configured",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Backend Controller Validation",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "- updateSummaryNote function updated to handle diagram field\n- validateDiagramData function implemented for data validation\n- Error handling and logging added",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Frontend Type Definition Validation",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "- SummaryNoteData interface updated with diagram field\n- DiagramNode, DiagramConnection, DiagramData types defined\n- Type safety ensured",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Frontend Save Logic Validation",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "- saveDiagramAsImage function improved\n- Data validation and error handling enhanced\n- Data transmitted in a structure matching the backend schema",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Frontend Load Logic Validation",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "- Diagram data loading logic improved in fetchSummaryNoteDetails function\n- Data validation and filtering added\n- Compatibility with existing data ensured",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Execute and validate actual tests",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-27T03:22:40.035Z",
      "updated": "2025-08-02T10:49:17.924Z",
      "description": "메모카드 시간대별 보기모드 개발 작업"
    }
  }
}