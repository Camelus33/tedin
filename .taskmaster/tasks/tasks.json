{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Dependency Installation",
        "description": "Set up the React/Next.js project environment with Tailwind CSS, ensuring compatibility with existing TSNoteCard component and react-pdf library.",
        "details": "1.  Verify Node.js and npm are installed (>=18.x and >=8.x respectively).\n2.  Initialize a new Next.js project or navigate to the existing project directory.\n3.  Install Tailwind CSS and its dependencies: `npm install -D tailwindcss postcss autoprefixer`\n4.  Configure Tailwind CSS by running `npx tailwindcss init -p` and updating `tailwind.config.js` with necessary configurations.\n5.  Install `react-pdf` library: `npm install react-pdf`\n6.  Verify that the TSNoteCard component is correctly set up and styled.\n7.  Address any compatibility issues between Tailwind CSS and existing styles.\n8.  Create necessary folders and files for components and utilities.",
        "testStrategy": "1.  Run the development server (`npm run dev`) and ensure the application compiles without errors.\n2.  Verify that Tailwind CSS styles are applied correctly.\n3.  Check that the TSNoteCard component renders as expected.\n4.  Ensure `react-pdf` is installed correctly and can be imported.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement View Mode State Management",
        "description": "Implement the view mode state management using React's useState hook, including the 'grid' and 'more' modes.",
        "details": "1.  In the main dashboard component, declare a state variable `viewMode` using `useState('grid')`.\n2.  Create a function `setViewMode` to update the `viewMode` state.\n3.  Pass the `viewMode` state and `setViewMode` function to the relevant components.\n4.  Implement logic to switch between 'grid' and 'more' modes based on user interaction (e.g., button click).\n5.  Ensure the initial state is set to 'grid'.",
        "testStrategy": "1.  Verify that the `viewMode` state is initialized correctly.\n2.  Test the functionality to switch between 'grid' and 'more' modes.\n3.  Ensure that the UI updates correctly when the `viewMode` changes.\n4.  Check for any unexpected side effects when updating the state.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Memo Card Loading and '더보기' Functionality",
        "description": "Modify the dashboard to initially load only the recent 3 memo cards in 'grid' mode and implement the '더보기' (more) button functionality to load all memo cards.",
        "details": "1.  Fetch the initial 3 memo cards and store them in a state variable `recentMemos`.\n2.  Display `recentMemos` in a 3-column grid layout when `viewMode` is 'grid'.\n3.  Implement an API call to fetch all memo cards when the '더보기' button is clicked.\n4.  Store all memo cards in a state variable `allMemos`.\n5.  Update the UI to display `allMemos` in a 6-column grid layout when `viewMode` is 'more'.\n6.  Implement error handling for the API call.",
        "testStrategy": "1.  Verify that only 3 memo cards are loaded initially in 'grid' mode.\n2.  Test the '더보기' button to ensure all memo cards are loaded and displayed in 'more' mode.\n3.  Check for correct grid layout in both 'grid' and 'more' modes.\n4.  Test error handling for API call failures.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement UI Components for Grid and More Views",
        "description": "Implement the UI components for both Grid and More views, ensuring the correct layout and styling.",
        "details": "1.  Create a `GridView` component to display memo cards in a 3-column grid layout.\n2.  Create a `MoreView` component to display memo cards in a 6-column grid layout.\n3.  Use Tailwind CSS to style the components, ensuring responsiveness.\n4.  Implement smaller card sizes in `MoreView`.\n5.  Ensure the `TSNoteCard` component is reused in both views.",
        "testStrategy": "1.  Verify that the `GridView` component displays memo cards in a 3-column grid.\n2.  Verify that the `MoreView` component displays memo cards in a 6-column grid.\n3.  Check for correct styling and responsiveness in both views.\n4.  Ensure that the `TSNoteCard` component is rendered correctly in both views.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Hover Animation",
        "description": "Add hover animation to the memo cards in the 'more' view using Tailwind CSS.",
        "details": "1.  Add the `hover:scale-110` class to the `TSNoteCard` component in the `MoreView`.\n2.  Add the `transition-all duration-300 ease-out` class to the `TSNoteCard` component to ensure a smooth animation.\n3.  Test the hover animation to ensure it scales the card up smoothly.",
        "testStrategy": "1.  Verify that the memo cards scale up on hover in the `MoreView`.\n2.  Check that the animation is smooth and lasts for 300ms.\n3.  Ensure that the animation does not cause any layout shifts.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Continuous Vertical Scrolling in PDF Viewer",
        "description": "Modify PdfViewer.tsx to enable continuous vertical scrolling, stacking all pages vertically.",
        "details": "1.  Modify the `PdfViewer.tsx` component to render all pages of the PDF in a vertical stack.\n2.  Remove the existing page navigation buttons.\n3.  Adjust the container height and styles to accommodate the continuous scroll.\n4.  Ensure the existing props interface is maintained.",
        "testStrategy": "1.  Verify that all pages are rendered in a vertical stack.\n2.  Check that the page navigation buttons are removed.\n3.  Ensure the container height and styles are adjusted correctly.\n4.  Test that the existing props interface is maintained.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Lazy Loading with IntersectionObserver",
        "description": "Implement lazy loading using IntersectionObserver to optimize performance for large PDFs.",
        "details": "1.  Use `IntersectionObserver` to detect when a page enters the viewport.\n2.  Only render pages that are currently in or near the viewport.\n3.  Implement a placeholder for pages that are not yet rendered.\n4.  Optimize memory usage by unloading pages that are far from the viewport.",
        "testStrategy": "1.  Verify that only pages in or near the viewport are rendered.\n2.  Check that placeholders are displayed for pages that are not yet rendered.\n3.  Monitor memory usage to ensure it is optimized.\n4.  Test scrolling performance with large PDFs (100+ pages).",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Scroll-Based Page Tracking and Control Bar Synchronization",
        "description": "Implement scroll-based page tracking and synchronize it with the control bar, ensuring compatibility with existing highlight and text selection features.",
        "details": "1.  Use the `IntersectionObserver` to track the currently visible page based on scroll position.\n2.  Update the control bar to reflect the current page number.\n3.  Ensure that the highlight overlay and text selection features continue to function correctly.\n4.  Maintain compatibility with existing zoom and rotation features.",
        "testStrategy": "1.  Verify that the control bar updates correctly as the user scrolls.\n2.  Check that the highlight overlay and text selection features continue to function correctly.\n3.  Ensure compatibility with existing zoom and rotation features.\n4.  Test with various PDF documents to ensure consistent behavior.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement IntersectionObserver-based Page Tracking",
            "description": "Set up IntersectionObserver to track which page is currently in view based on scroll position. Determine the logic for identifying the 'current' page when multiple pages are partially visible.",
            "dependencies": [],
            "details": "Use IntersectionObserver API to monitor the visibility of each page element. Define a threshold for determining when a page is considered 'in view'. Handle edge cases where multiple pages are partially visible.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Control Bar Update Logic",
            "description": "Develop the logic to update the control bar with the current page information based on the output from the IntersectionObserver. Ensure the control bar accurately reflects the currently viewed page.",
            "dependencies": [
              1
            ],
            "details": "Create a function that receives the current page information from the IntersectionObserver and updates the control bar's page number display. Handle cases where no page is in view (e.g., at the very beginning or end of the document).",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Ensure Compatibility with Highlight and Text Selection",
            "description": "Test and ensure that the scroll-based page tracking and control bar synchronization do not interfere with existing highlight and text selection functionalities. Address any conflicts that arise.",
            "dependencies": [
              1,
              2
            ],
            "details": "Test highlighting and text selection on different pages after implementing the scroll-based tracking. Identify and resolve any issues where the tracking logic prevents or disrupts highlighting or text selection.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Ensure Compatibility with Zoom and Rotation",
            "description": "Test and ensure that the scroll-based page tracking and control bar synchronization remain accurate and functional when the document is zoomed in/out or rotated. Adjust the IntersectionObserver thresholds or logic as needed.",
            "dependencies": [
              1,
              2
            ],
            "details": "Test the page tracking and control bar updates at different zoom levels and rotations. Adjust the IntersectionObserver's thresholds or the page detection logic to maintain accuracy under these conditions.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-07T08:48:57.524Z",
      "updated": "2025-07-07T08:49:24.607Z",
      "description": "Tasks for pdf-scroll-feature context"
    }
  },
  "pdf-knowledge-capture": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement PDF Upload API and Update Book Model",
        "description": "Extend the Book model with pdfUrl and pdfFileSize fields and implement an API endpoint for uploading PDF files to cloud storage, including server-side validation.",
        "details": "1.  Modify the Book model in the database schema to include the `pdfUrl` (string) and `pdfFileSize` (integer) fields.\n2.  Implement a new API endpoint `/books/{bookId}/upload-pdf` that accepts a PDF file as input.\n3.  Implement server-side validation to check the file format (must be PDF) and file size (must be less than 20MB).\n4.  Upon successful validation, upload the PDF file to cloud storage (e.g., AWS S3, Google Cloud Storage, or Azure Blob Storage).\n5.  Store the URL of the uploaded PDF file in the `pdfUrl` field of the Book model.\n6.  Store the size of the uploaded PDF file in the `pdfFileSize` field of the Book model.\n7.  Return a success response with the updated Book model.\n8.  Handle potential errors such as invalid file format, file size exceeding the limit, and cloud storage upload failures, returning appropriate error responses.",
        "testStrategy": "1.  Create a test PDF file.\n2.  Send a POST request to the `/books/{bookId}/upload-pdf` endpoint with the test PDF file.\n3.  Verify that the API returns a success response with the updated Book model, including the `pdfUrl` and `pdfFileSize` fields.\n4.  Verify that the PDF file is successfully uploaded to cloud storage.\n5.  Verify that the `pdfUrl` field in the Book model contains the correct URL of the uploaded PDF file.\n6.  Verify that the `pdfFileSize` field in the Book model contains the correct size of the uploaded PDF file.\n7.  Test with a file larger than 20MB and verify that the API returns an error response.\n8.  Test with a non-PDF file and verify that the API returns an error response.\n9.  Test error handling for cloud storage upload failures.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "현재 백엔드 구조 분석",
            "description": "backend/ 폴더의 기존 코드를 분석하여 Prisma 스키마와 Book 모델 구조를 파악한다",
            "details": "- backend/prisma/schema.prisma 파일 확인\n- Book 모델의 현재 필드 구조 파악\n- 기존 Book 관련 API 엔드포인트 확인\n- 파일 업로드 관련 기존 구현 확인\n<info added on 2025-07-07T03:14:11.703Z>\n**현재 상황:**\n- 프로젝트는 MongoDB + Mongoose 사용\n- Book 모델은 `backend/src/models/Book.ts`에 정의\n- Book API는 `backend/src/routes/books.ts`에 구현\n- 이미 multer를 사용한 이미지 업로드 기능 존재 (5MB 제한)\n- 업로드 디렉토리: `uploads/` (프로젝트 루트)\n\n**Book 모델 현재 필드:**\n- userId, title, author, bookType, totalPages, currentPage\n- isbn, coverImage, category, status, completionPercentage\n- estimatedRemainingMinutes, avgPpm, readingPurpose, purchaseLink\n- createdAt, updatedAt (timestamps)\n\n**다음 단계:**\n1. Book 모델에 pdfUrl, pdfFileSize 필드 추가\n2. PDF 파일 업로드를 위한 multer 설정 추가\n3. PDF 업로드 API 엔드포인트 구현\n4. PDF 파일 검증 로직 구현\n</info added on 2025-07-07T03:14:11.703Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 1
          },
          {
            "id": 2,
            "title": "Book 모델에 PDF 필드 추가",
            "description": "Book 모델의 인터페이스와 스키마에 pdfUrl과 pdfFileSize 필드를 추가한다",
            "details": "- IBook 인터페이스에 pdfUrl?: string, pdfFileSize?: number 필드 추가\n- BookSchema에 해당 필드들의 Mongoose 스키마 정의 추가\n- 기존 Book 타입과의 호환성 유지\n<info added on 2025-07-07T03:15:28.807Z>\n- pdfUrl은 String 타입, trim 적용, 기본값 null\n- pdfFileSize는 Number 타입, 최소값 0, 기본값 null\n- backend/src/models/Book.ts 파일 수정\n- 기존 필드들에는 영향 없음\n- 새로운 필드들은 옵셔널이므로 기존 데이터와 호환\n</info added on 2025-07-07T03:15:28.807Z>",
            "status": "done",
            "dependencies": [
              1
            ],
            "parentTaskId": 1
          },
          {
            "id": 3,
            "title": "PDF 업로드를 위한 multer 설정 구성",
            "description": "PDF 파일 업로드를 위한 별도의 multer 인스턴스를 생성하고 PDF 파일 검증 로직을 구현한다",
            "details": "- PDF 파일만 허용하는 fileFilter 함수 구현\n- 20MB 파일 크기 제한 설정\n- PDF 전용 업로드 디렉토리 설정 (uploads/pdfs/)\n- MIME 타입 검증 (application/pdf)\n- 파일 확장자 검증 (.pdf)\n<info added on 2025-07-07T03:16:36.856Z>\nPDF 업로드 multer 설정 완료:\n\n**완료된 작업:**\n- PDF 전용 업로드 디렉토리 생성 (uploads/pdfs/)\n- PDF 파일 전용 multer 인스턴스 (uploadPdf) 구성\n- PDF 파일 검증 로직 구현:\n  - MIME 타입 검증: application/pdf만 허용\n  - 파일 확장자 검증: .pdf 확장자만 허용\n  - 파일 크기 제한: 20MB\n- 상세한 로깅 추가로 디버깅 용이성 확보\n- 기존 이미지 업로드 기능과 분리하여 독립적 운영\n\n**변경 사항:**\n- backend/src/routes/books.ts 파일에 PDF 업로드 설정 추가\n- pdfStorage, pdfFileFilter, uploadPdf 인스턴스 생성\n- 에러 메시지 한국어로 사용자 친화적 구성\n</info added on 2025-07-07T03:16:36.856Z>",
            "status": "done",
            "dependencies": [
              2
            ],
            "parentTaskId": 1
          },
          {
            "id": 4,
            "title": "PDF 업로드 API 엔드포인트 구현",
            "description": "책에 PDF 파일을 업로드하는 API 엔드포인트를 구현하고 Book 모델을 업데이트한다",
            "details": "- POST /books/:bookId/upload-pdf 엔드포인트 생성\n- bookController에 uploadPdf 함수 구현\n- 업로드된 PDF 파일 정보를 Book 모델에 저장\n- 파일 URL과 크기 정보 업데이트\n- 에러 핸들링 및 검증 로직 추가\n- 응답 형식 정의\n<info added on 2025-07-07T03:19:34.472Z>\n**완료된 작업:**\n- POST /books/:bookId/upload-pdf 엔드포인트 생성\n- bookController에 uploadPdf 함수 구현\n- 업로드된 PDF 파일 정보를 Book 모델에 저장 (pdfUrl, pdfFileSize)\n- 상세한 에러 핸들링 및 검증 로직:\n  - 사용자 인증 확인\n  - 파일 존재 여부 확인\n  - 책 소유권 확인\n  - 기존 PDF 파일 삭제 (교체 시)\n  - 업로드 실패 시 파일 정리\n- 응답 형식 정의 (성공 메시지, 업데이트된 책 정보, PDF 정보)\n- multer 인스턴스 이름 충돌 해결 (pdfUpload로 변경)\n\n**API 사용법:**\n- POST /books/:bookId/upload-pdf\n- Content-Type: multipart/form-data\n- Field name: pdfFile\n- 최대 파일 크기: 20MB\n- 지원 형식: PDF (.pdf, application/pdf)\n\n**응답 형식:**\n```json\n{\n  \"message\": \"PDF 파일이 성공적으로 업로드되었습니다.\",\n  \"book\": { /* 업데이트된 책 정보 */ },\n  \"pdfInfo\": {\n    \"originalName\": \"document.pdf\",\n    \"url\": \"/uploads/pdfs/pdfFile-1234567890-123456789.pdf\",\n    \"size\": 1234567\n  }\n}\n```\n</info added on 2025-07-07T03:19:34.472Z>",
            "status": "done",
            "dependencies": [
              3
            ],
            "parentTaskId": 1
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement PDF Upload Book Registration UI",
        "description": "Implement the UI for registering books via PDF upload, adding a 'Register via PDF' tab to the existing book registration page. This includes file upload, drag-and-drop functionality, and automatic metadata extraction using pdf.js.",
        "details": "1.  Modify the existing book registration page to include a new tab labeled 'Register via PDF'.\n2.  Implement a file upload component within the 'Register via PDF' tab, allowing users to select PDF files from their local system.\n3.  Implement drag-and-drop functionality for PDF files onto the upload component.\n4.  Integrate pdf.js to extract metadata from the uploaded PDF file, including title, author, and other relevant information.\n5.  Automatically populate the corresponding form fields on the book registration page with the extracted metadata.\n6.  Handle cases where metadata extraction fails or is incomplete, providing users with the option to manually enter the missing information.\n7.  Ensure the UI is responsive and handles large PDF files efficiently, providing appropriate loading indicators.\n8.  Implement client-side validation to ensure that only PDF files are accepted.\n9.  Consider accessibility requirements when designing the UI, ensuring it is usable by people with disabilities.",
        "testStrategy": "1.  Upload a variety of PDF files with different metadata structures.\n2.  Verify that the metadata is correctly extracted and populated into the corresponding form fields.\n3.  Test the drag-and-drop functionality with different PDF files.\n4.  Test the UI with large PDF files to ensure it remains responsive.\n5.  Verify that the client-side validation prevents non-PDF files from being uploaded.\n6.  Manually enter data into the form fields and submit the form to ensure that the data is correctly saved.\n7.  Test the UI on different browsers and devices to ensure compatibility.\n8.  Verify that the UI is accessible to users with disabilities, using assistive technologies such as screen readers.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "PDF.js 라이브러리 설치 및 설정",
            "description": "PDF 메타데이터 추출을 위한 PDF.js 라이브러리를 프론트엔드에 설치하고 설정합니다.",
            "details": "- npm install pdfjs-dist 실행\n- PDF.js worker 설정\n- TypeScript 타입 정의 추가\n- 기본 PDF 파싱 함수 구현\n<info added on 2025-07-07T03:26:31.637Z>\n**구현 내용:**\n1. ✅ pdfjs-dist 라이브러리 설치 완료\n2. ✅ @types/pdfjs-dist TypeScript 타입 정의 설치 완료\n3. ✅ frontend/lib/pdfUtils.ts 파일 생성\n4. ✅ PDF.js worker 설정 구현\n5. ✅ PDF 메타데이터 추출 함수 구현\n6. ✅ PDF 파일 유효성 검사 함수 구현\n7. ✅ 파일 크기 포맷팅 유틸리티 함수 구현\n\n**주요 기능:**\n- extractPdfMetadata(): PDF에서 제목, 저자, 페이지 수 추출\n- validatePdfFile(): PDF 파일 유효성 검사 (타입, 크기, 확장자)\n- formatFileSize(): 파일 크기를 읽기 쉬운 형태로 변환\n- 20MB 파일 크기 제한\n- 에러 핸들링 및 폴백 로직 포함\n\n**TypeScript 타입:**\n- PdfMetadata 인터페이스\n- PdfExtractionResult 인터페이스\n- 완전한 타입 안전성 보장\n</info added on 2025-07-07T03:26:31.637Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 2,
            "title": "PDF 업로드 UI 컴포넌트 생성",
            "description": "드래그앤드롭 기능이 포함된 PDF 업로드 UI 컴포넌트를 생성합니다.",
            "details": "- PdfUploadComponent.tsx 파일 생성\n- 드래그앤드롭 기능 구현\n- PDF 파일 검증 로직\n- 업로드 진행상태 표시\n- 에러 핸들링 UI\n<info added on 2025-07-07T03:28:14.881Z>\n**구현 내용:**\n1. ✅ PdfUploadComponent.tsx 컴포넌트 생성 완료\n2. ✅ 드래그앤드롭 기능 구현\n3. ✅ PDF 파일 검증 로직 구현\n4. ✅ 업로드 진행상태 표시 구현\n5. ✅ 에러 핸들링 UI 구현\n6. ✅ 메타데이터 표시 UI 구현\n\n**주요 기능:**\n- 클릭 또는 드래그앤드롭으로 PDF 파일 업로드\n- 실시간 파일 유효성 검증 (타입, 크기, 확장자)\n- PDF 메타데이터 자동 추출 및 표시\n- 로딩 상태 및 진행률 표시\n- 상세한 에러 메시지 및 경고\n- 업로드된 파일 정보 미리보기\n- 파일 제거 기능\n\n**UI/UX 특징:**\n- Habitus33 사이버펑크 테마 적용\n- 반응형 디자인\n- 접근성 고려 (키보드 네비게이션, 스크린 리더)\n- 직관적인 아이콘 및 상태 표시\n- 부드러운 애니메이션 효과\n\n**기술적 특징:**\n- TypeScript 완전 지원\n- React hooks 활용 (useState, useRef, useCallback)\n- 메모리 누수 방지\n- 에러 경계 처리\n- 컴포넌트 재사용성 고려\n</info added on 2025-07-07T03:28:14.881Z>",
            "status": "done",
            "dependencies": [
              "2.1"
            ],
            "parentTaskId": 2
          },
          {
            "id": 3,
            "title": "PDF 메타데이터 추출 함수 구현",
            "description": "PDF.js를 사용하여 PDF 파일에서 메타데이터(제목, 저자, 페이지 수)를 추출하는 함수를 구현합니다.",
            "details": "- extractPdfMetadata 함수 구현\n- PDF 문서 정보 파싱\n- 제목, 저자, 페이지 수 추출\n- 에러 핸들링 및 폴백 로직\n- TypeScript 타입 정의",
            "status": "done",
            "dependencies": [
              "2.1"
            ],
            "parentTaskId": 2
          },
          {
            "id": 4,
            "title": "기존 책 등록 페이지에 PDF 업로드 기능 통합",
            "description": "기존 /books/new/page.tsx에 PDF 업로드 기능을 통합하고 자동 폼 채우기 기능을 구현합니다.",
            "details": "- 기존 폼에 PDF 업로드 섹션 추가\n- PDF 업로드 시 자동 폼 필드 채우기\n- 수동 입력과 PDF 업로드 방식 병행 지원\n- 반응형 레이아웃 조정\n- 상태 관리 로직 구현\n<info added on 2025-07-07T03:31:31.278Z>\n**구현 내용:**\n1. ✅ 기존 책 등록 페이지에 PDF 업로드 기능 통합 완료\n2. ✅ PDF 업로드 상태 관리 추가 (pdfFile, pdfMetadata, inputMethod)\n3. ✅ PDF 업로드 핸들러 함수 구현 (handlePdfSelected, handlePdfError, clearPdfFile)\n4. ✅ 자동 폼 채우기 기능 구현 (제목, 저자, 페이지 수)\n5. ✅ 수동 입력과 PDF 업로드 방식 병행 지원\n6. ✅ PDF 업로드 UI 섹션 추가 (오른쪽 컬럼)\n7. ✅ 책 등록 후 PDF 업로드 API 연동\n8. ✅ 반응형 레이아웃 조정\n\n**주요 기능:**\n- PDF 파일 업로드 시 메타데이터 자동 추출 및 폼 필드 자동 채우기\n- 수동 입력 모드와 PDF 모드 간 전환 가능\n- PDF 업로드 성공/실패 상태 표시\n- 책 등록 후 자동 PDF 업로드 처리\n- PDF 업로드 실패 시에도 책 등록은 유지 (부분 성공 처리)\n\n**UI/UX 개선:**\n- 직관적인 PDF 업로드 인터페이스\n- 자동 추출된 정보 표시 및 안내\n- 사용자 피드백 메시지 (성공/실패/진행 상태)\n- 기존 디자인과 일관성 유지\n\n**에러 처리:**\n- PDF 업로드 실패 시 적절한 에러 메시지\n- 부분 성공 시나리오 처리 (책 등록 성공, PDF 업로드 실패)\n- 사용자 친화적인 오류 안내\n</info added on 2025-07-07T03:31:31.278Z>",
            "status": "done",
            "dependencies": [
              "2.2",
              "2.3"
            ],
            "parentTaskId": 2
          }
        ]
      },
      {
        "id": 3,
        "title": "Integrate PDF Viewer and Implement Highlighting in TS Reading Session",
        "description": "Integrate a PDF viewer into the TS reading session page using react-pdf and implement a rounded-corner highlighting feature using SVG overlays. This includes text selection, coordinate calculation, and PDF note modal invocation.",
        "details": "1. Integrate the react-pdf library into the TS reading session page.\n2. Implement an SVG overlay to enable rounded-corner highlighting functionality.\n3. Implement text selection functionality within the PDF viewer.\n4. Calculate text coordinates upon selection for highlighting purposes.\n5. Implement a PDF note modal that is invoked upon text selection, allowing users to add notes to highlighted sections.\n6. Ensure the highlighting feature is visually appealing with rounded corners and a subtle color scheme.\n7. Optimize the PDF viewer for performance, ensuring smooth scrolling and rendering even with large PDF documents.\n8. Implement error handling for cases where PDF loading fails or the PDF format is invalid.",
        "testStrategy": "1. Load various PDF documents into the TS reading session page to test the PDF viewer integration.\n2. Select text within the PDF viewer and verify that the rounded-corner highlighting is applied correctly.\n3. Test the text selection functionality with different text sizes and fonts.\n4. Verify that the correct text coordinates are calculated upon selection.\n5. Invoke the PDF note modal and ensure that it displays correctly with the selected text.\n6. Test the performance of the PDF viewer with large PDF documents, ensuring smooth scrolling and rendering.\n7. Simulate PDF loading errors and invalid PDF formats to verify that the error handling is implemented correctly.",
        "status": "done",
        "dependencies": [
          1,
          2
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "react-pdf 라이브러리 설치 및 설정",
            "description": "react-pdf 라이브러리를 설치하고 프로젝트에서 사용할 수 있도록 기본 설정을 구성합니다.",
            "details": "- react-pdf 및 필요한 peer dependencies 설치\\n- PDF 뷰어 기본 컴포넌트 설정\\n- TypeScript 타입 정의 추가\\n- Worker 설정 및 최적화\n<info added on 2025-07-07T03:36:49.893Z>\n**구현 내용:**\n1. ✅ react-pdf 라이브러리 설치 완료\n2. ✅ @types/react-pdf TypeScript 타입 정의 설치 완료\n3. ✅ PdfViewer.tsx 컴포넌트 생성 완료\n4. ✅ PDF.js worker 설정 구현\n5. ✅ 기본 PDF 뷰어 기능 구현\n\n**주요 기능:**\n- 완전한 PDF 문서 렌더링\n- 페이지 네비게이션 (이전/다음 페이지)\n- 줌 인/아웃 기능 (50% ~ 300%)\n- 90도 회전 기능\n- 텍스트 선택 지원 (onTextSelect 콜백)\n- 로딩 상태 및 에러 핸들링\n- 반응형 디자인\n\n**UI/UX 특징:**\n- Habitus33 사이버펑크 테마 적용\n- 직관적인 컨트롤 버튼\n- 실시간 페이지/줌 상태 표시\n- 텍스트 선택 안내 메시지\n- 부드러운 애니메이션 효과\n\n**기술적 특징:**\n- TypeScript 완전 지원\n- React hooks 활용 (useState, useCallback, useRef, useEffect)\n- 텍스트 선택 이벤트 처리\n- 좌표 계산 기능 (하이라이트 준비)\n- 에러 경계 처리\n- 메모리 누수 방지\n</info added on 2025-07-07T03:36:49.893Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          },
          {
            "id": 2,
            "title": "TSReadingPage에 PDF 뷰어 통합",
            "description": "TSReadingPage 컴포넌트에 PDF 뷰어를 통합하여 PDF가 있는 책의 경우 조건부로 렌더링합니다.",
            "details": "- TSReadingPage에서 책의 PDF 파일 존재 여부 확인\\n- PDF가 있는 경우 PdfViewer 컴포넌트 렌더링\\n- PDF 로딩 및 에러 상태 처리\\n- 기존 TS 세션 플로우와의 호환성 유지\n<info added on 2025-07-07T03:39:14.801Z>\n**구현 내용:**\n1. ✅ TSReadingPage에 PDF 뷰어 통합 완료\n2. ✅ SessionData 타입에 PDF 정보 필드 추가 (pdfUrl, pdfFileSize)\n3. ✅ PDF 뷰어 상태 관리 추가 (showPdfViewer, currentPdfPage, pdfError)\n4. ✅ PDF 뷰어 토글 버튼 구현\n5. ✅ 조건부 렌더링 구현 (PDF 있음/없음)\n6. ✅ PDF 텍스트 선택 시 자동 일시정지 기능\n7. ✅ PDF 에러 핸들링 및 사용자 안내\n\n**주요 기능:**\n- PDF가 있는 책: PDF 뷰어 토글 버튼 표시\n- PDF가 없는 책: 기존 호흡 텍스트 유지\n- PDF 뷰어 표시/숨기기 토글 기능\n- 텍스트 선택 시 타이머 자동 일시정지\n- PDF 로딩 에러 시 사용자 친화적 메시지\n\n**UI/UX 특징:**\n- 사이버펑크 테마 일관성 유지\n- 직관적인 PDF 뷰어 토글 버튼\n- 반응형 디자인 (최대 너비 4xl)\n- 부드러운 상태 전환 애니메이션\n\n**기술적 특징:**\n- 기존 TS 세션 플로우와 완전 호환\n- PDF URL 자동 구성 (API URL + 상대 경로)\n- 메모리 효율적인 상태 관리\n- 타입 안전성 보장\n\n**다음 단계 준비:**\n- 텍스트 선택 이벤트 핸들러 준비 완료\n- 메모 모달 연동 준비 (Phase 4)\n- 하이라이트 기능 연동 준비\n</info added on 2025-07-07T03:39:14.801Z>",
            "status": "done",
            "dependencies": [
              "3.1"
            ],
            "parentTaskId": 3
          },
          {
            "id": 3,
            "title": "SVG 오버레이 하이라이트 시스템 구현",
            "description": "PDF 텍스트 위에 SVG 오버레이를 사용하여 둥근 모서리 하이라이트 기능을 구현합니다.",
            "details": "- SVG 오버레이 컴포넌트 생성\\n- 텍스트 좌표를 SVG 좌표로 변환\\n- 둥근 모서리 하이라이트 렌더링\\n- 하이라이트 상태 관리\\n- 여러 하이라이트 지원\n<info added on 2025-07-07T03:44:04.886Z>\n**구현 내용:**\n1. ✅ PDF 하이라이트 타입 정의 완료 (types/pdf.ts)\n2. ✅ 하이라이트 유틸리티 함수 구현 (lib/pdfHighlightUtils.ts)\n3. ✅ SVG 오버레이 하이라이트 컴포넌트 생성 (PdfHighlightOverlay.tsx)\n4. ✅ PdfViewer에 하이라이트 시스템 통합 완료\n5. ✅ 하이라이트 모드 토글 기능 구현\n6. ✅ 둥근 모서리 하이라이트 렌더링 구현\n7. ✅ 다중 하이라이트 지원\n\n**주요 기능:**\n- **하이라이트 생성**: 텍스트 선택 시 자동 하이라이트 생성\n- **둥근 모서리**: SVG rect에 rx/ry 속성으로 세련된 모양\n- **다중 색상 지원**: 6가지 하이라이트 색상 (yellow, green, blue, purple, pink, orange)\n- **인터랙티브**: 클릭, 더블클릭, 우클릭 이벤트 지원\n- **시각적 피드백**: 호버 시 투명도 변경 및 테두리 표시\n- **메모 표시**: 메모가 있는 하이라이트에 작은 원 아이콘\n\n**기술적 특징:**\n- **좌표 변환**: DOM 좌표 → SVG 좌표 정확한 변환\n- **성능 최적화**: MutationObserver로 컨테이너 변경 감지\n- **반응형**: 스케일 변경 시 하이라이트 크기 자동 조정\n- **페이지별 필터링**: 현재 페이지의 하이라이트만 렌더링\n- **메모리 관리**: 컴포넌트 언마운트 시 이벤트 리스너 정리\n\n**UI/UX 특징:**\n- **하이라이트 모드 토글**: 노란색 아이콘으로 직관적 표시\n- **상태별 안내 메시지**: 일반 모드와 하이라이트 모드 구분\n- **부드러운 애니메이션**: 호버 및 상태 전환 효과\n- **접근성**: 키보드 네비게이션 및 툴팁 지원\n\n**다음 단계 준비:**\n- 하이라이트 생성 이벤트 준비 완료\n- 메모 모달 연동 준비 (Phase 4)\n- TSReadingPage 통합 준비\n</info added on 2025-07-07T03:44:04.886Z>",
            "status": "done",
            "dependencies": [
              "3.2"
            ],
            "parentTaskId": 3
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement PDF Note-Taking Modal",
        "description": "Implement a reusable PDF note-taking modal with the same UI/UX as the existing review session memo input form. This modal will be triggered upon highlighting text in the PDF viewer, pausing the timer and pre-filling the modal with the highlighted text.",
        "details": "1.  Create a new, reusable component for the PDF note-taking modal, mirroring the UI/UX of the existing review session memo input form.\n2.  Implement logic to pause the timer when text is highlighted in the PDF viewer.\n3.  Implement logic to invoke the PDF note-taking modal upon text highlighting.\n4.  Automatically populate the modal with the highlighted text.\n5.  Implement functionality to save the note and return to the TS reading session upon saving, resuming the timer.\n6. Ensure the modal is properly integrated with the highlighting functionality implemented in Task 3.",
        "testStrategy": "1.  Highlight text in the PDF viewer and verify that the timer pauses.\n2.  Verify that the PDF note-taking modal is invoked upon text highlighting.\n3.  Ensure that the highlighted text is automatically populated in the modal.\n4.  Save the note and verify that the user is returned to the TS reading session and the timer resumes.\n5.  Test the modal with different lengths of highlighted text.\n6.  Verify that the saved note is correctly associated with the highlighted text.",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "기존 TS 리뷰 메모 UI 분석 및 재사용 컴포넌트 추출",
            "description": "TSReviewPage의 메모 입력 폼을 분석하고 재사용 가능한 컴포넌트로 추출",
            "details": "TSReviewPage.client.tsx의 메모 입력 폼 UI/UX를 분석하여 PDF 메모 작성에 재사용할 수 있도록 별도 컴포넌트로 추출\n<info added on 2025-07-07T03:51:48.988Z>\n✅ 서브태스크 4.1 완료!\n\n**완료 내용:**\n- TSReviewPage의 메모 입력 폼 UI/UX를 분석 완료\n- 동일한 cyberTheme와 스타일을 사용하는 PdfMemoModal 컴포넌트 생성\n- 기존 TS 리뷰 폼과 동일한 필드들 구현:\n  - 메모 성격 선택 (생각/인용/질문)\n  - 메모 텍스트 입력 (하이라이트된 텍스트 자동 입력)\n  - 키워드 입력\n  - 셀프 평가 (별점 1-5)\n- 모달 형태로 구현하여 PDF 뷰어 위에 오버레이\n- 반응형 디자인 및 접근성 고려\n- 에러 핸들링 및 로딩 상태 관리\n- PdfMemoData 타입 정의 및 export 추가\n</info added on 2025-07-07T03:51:48.988Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 2,
            "title": "PDF 메모 모달 컴포넌트 생성",
            "description": "하이라이트된 텍스트를 받아 메모를 작성할 수 있는 모달 컴포넌트 생성",
            "details": "기존 TS 리뷰 메모 UI와 동일한 스타일의 PDF 메모 모달 컴포넌트를 생성하고, 하이라이트된 텍스트를 자동으로 입력하는 기능 구현\n<info added on 2025-07-07T03:52:30.188Z>\nPdfMemoModal 컴포넌트는 서브태스크 4.1에서 이미 완성됨\n- 하이라이트된 텍스트를 자동으로 메모 필드에 입력하는 기능 구현\n- 기존 TS 리뷰 메모와 동일한 UI/UX 스타일 적용\n- 모든 필수 기능 구현:\n  - 메모 성격 선택 (생각/인용/질문)\n  - 메모 텍스트 입력 (하이라이트 텍스트 자동 입력)\n  - 키워드 입력\n  - 중요도 평가 (별점)\n  - 에러 핸들링 및 로딩 상태\n- PdfMemoData 타입 정의 및 export\n- 모달 형태로 구현하여 PDF 뷰어 위에 오버레이\n\n**다음 단계:** TSReadingPage에 모달을 통합하고 하이라이트 이벤트와 연동\n</info added on 2025-07-07T03:52:30.188Z>",
            "status": "done",
            "dependencies": [
              "4.1"
            ],
            "parentTaskId": 4
          },
          {
            "id": 3,
            "title": "TSReadingPage에 PDF 메모 모달 통합",
            "description": "TSReadingPage에 PDF 메모 모달을 통합하고 하이라이트 이벤트와 연동",
            "details": "TSReadingPage에 PDF 메모 모달을 추가하고, 하이라이트 생성 시 타이머 일시정지 및 모달 호출 로직 구현\n<info added on 2025-07-07T03:54:51.529Z>\n- TSReadingPage에 PdfMemoModal 컴포넌트 import 및 통합 완료\n- PDF 메모 모달 상태 관리 추가:\n  - isMemoModalOpen: 모달 열림/닫힘 상태\n  - selectedText: 하이라이트된 텍스트\n  - selectedPageNumber: 현재 페이지 번호\n- 하이라이트 이벤트와 모달 연동 구현:\n  - handlePdfTextSelect에서 타이머 자동 일시정지\n  - 선택된 텍스트와 페이지 정보 저장\n  - 메모 모달 자동 호출\n- 모달 핸들러 구현:\n  - handleMemoModalClose: 모달 닫기 및 타이머 재개\n  - handleMemoSave: 메모 저장 로직 (임시로 localStorage 사용)\n- 메모 저장 후 타이머 자동 재개 구현\n- Phase 5 API 연동을 위한 TODO 주석 추가\n\n**다음 단계:** 타이머 일시정지/재개 로직 최적화\n</info added on 2025-07-07T03:54:51.529Z>",
            "status": "done",
            "dependencies": [
              "4.2"
            ],
            "parentTaskId": 4
          },
          {
            "id": 4,
            "title": "타이머 일시정지/재개 로직 구현",
            "description": "하이라이트 시 타이머 일시정지, 메모 저장 후 타이머 재개 로직 구현",
            "details": "PDF 하이라이트 생성 시 자동으로 타이머를 일시정지하고, 메모 저장 완료 후 타이머를 자동으로 재개하는 로직 구현\n<info added on 2025-07-07T03:55:20.886Z>\n🔍 서브태스크 4.4 분석 시작\n\n**현재 타이머 로직 검토:**\n- 기본 일시정지/재개 기능은 이미 구현됨\n- PDF 하이라이트 시 자동 일시정지 구현됨\n- 메모 저장 후 자동 재개 구현됨\n- 모달 닫기 시 자동 재개 구현됨\n\n**추가 최적화 필요 사항:**\n1. 중복 일시정지 방지 로직\n2. 타이머 상태 표시 개선\n3. 메모 작성 중 타이머 상태 명확화\n4. 에지 케이스 처리 (모달 열림 중 수동 일시정지 등)\n\n**구현 진행:**\n- 현재 로직이 이미 요구사항을 충족하고 있음을 확인\n- 필요한 경우에만 최소한의 개선 적용\n</info added on 2025-07-07T03:55:20.886Z>\n<info added on 2025-07-07T03:56:34.974Z>\n✅ 서브태스크 4.4 완료!\n\n**완료된 타이머 로직 최적화:**\n\n1. **메모 작성 상태 구분**:\n   - `isPausedForMemo` 상태 추가로 메모 작성으로 인한 일시정지와 수동 일시정지 구분\n   - 타이머 상태 텍스트 개선 (몰입하는 중/일시정지됨/메모 작성 중)\n\n2. **중복 방지 로직**:\n   - 메모 모달이 이미 열려있을 때 텍스트 선택 무시\n   - 이미 일시정지된 상태에서 중복 일시정지 방지\n\n3. **수동 컨트롤 제한**:\n   - 메모 작성 중에는 수동 일시정지/재개 버튼 비활성화\n   - 메모 작성 중에는 수동 종료 버튼 비활성화\n   - 버튼 상태에 따른 시각적 피드백 개선\n\n4. **정확한 타이머 재개**:\n   - 메모 저장 완료 시에만 타이머 재개\n   - 모달 닫기 시에도 정확한 타이머 재개\n   - 메모 작성으로 인한 일시정지인 경우에만 자동 재개\n\n**사용자 경험 개선:**\n- 타이머 상태가 명확하게 표시됨\n- 메모 작성 중 실수로 타이머 조작 방지\n- 일관된 타이머 동작 보장\n</info added on 2025-07-07T03:56:34.974Z>",
            "status": "done",
            "dependencies": [
              "4.3"
            ],
            "parentTaskId": 4
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement PDF Memo Saving API",
        "description": "Develop a dedicated API endpoint to save PDF memos generated during TS reading sessions to the database. This API will handle data persistence for PDF notes.",
        "details": "1. Create a new API endpoint `/api/ts-notes` that accepts POST requests.\n2. Implement server-side validation to ensure the request body contains `bookId` (integer), `pageNumber` (integer), `highlightedText` (string), `memoContent` (string), and `memoType` (string).\n3. Create a `Note` model in the database with fields corresponding to the validated request body parameters.\n4. Upon successful validation, create a new record in the `Note` table with the provided data.\n5. Return a success response with the newly created note's ID.\n6. Implement error handling to return appropriate error codes and messages for invalid requests or database errors.\n7. Ensure the API is secured with appropriate authentication and authorization mechanisms.\n8. Optimize database queries for performance, especially when retrieving notes for a specific book and page.",
        "testStrategy": "1. Send a POST request to `/api/ts-notes` with valid data for `bookId`, `pageNumber`, `highlightedText`, `memoContent`, and `memoType`.\n2. Verify that a new record is created in the `Note` table with the provided data.\n3. Verify that the API returns a success response with the newly created note's ID.\n4. Send a POST request with invalid data (e.g., missing fields, incorrect data types) and verify that the API returns an appropriate error response.\n5. Test the API with different combinations of `bookId`, `pageNumber`, `highlightedText`, `memoContent`, and `memoType` to ensure it handles various scenarios correctly.\n6. Test the API's performance by sending multiple concurrent requests and monitoring response times.\n7. Verify that the API is properly secured by attempting to access it without proper authentication and authorization.",
        "status": "done",
        "dependencies": [
          3,
          4
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "기존 Note 모델 및 API 구조 분석",
            "description": "기존 Note 모델의 스키마와 API 엔드포인트를 분석하여 PDF 메모와 호환 가능한 구조 파악",
            "details": "1. Note 모델 스키마 분석 (필드, 타입, 제약조건)\\n2. notes API 엔드포인트 분석 (/notes 라우트)\\n3. PDF 메모를 위한 추가 필드 필요성 검토\\n4. 기존 TS 메모와 PDF 메모 구분 방법 설계\n<info added on 2025-07-07T04:00:32.568Z>\n✅ 기존 Note 모델 및 API 구조 분석 완료\n\n**Note 모델 분석 결과:**\n1. **기존 필드들:**\n   - 필수: userId, bookId, type ('quote'|'thought'|'question'), content\n   - 옵셔널: tags[], originSession, importanceReason, momentContext, relatedKnowledge, mentalImage, relatedLinks[], inlineThreads[]\n   - 시간: createdAt, clientCreatedAt\n\n2. **PDF 메모를 위해 추가 필요한 필드들:**\n   - pageNumber: PDF 페이지 번호 (number)\n   - highlightedText: 하이라이트된 원문 텍스트 (string)\n   - highlightData: 하이라이트 좌표 정보 (object, 옵셔널)\n   - isPdfMemo: PDF 메모 구분 플래그 (boolean, 기본값 false)\n\n3. **기존 API 엔드포인트:**\n   - GET /notes - 전체 노트 목록\n   - POST /notes - 새 노트 생성 (기존 TS 메모용)\n   - GET /notes/book/:bookId - 책별 노트 조회\n   - PUT /notes/:noteId - 노트 수정\n   - DELETE /notes/:noteId - 노트 삭제\n\n4. **PDF 메모 전용 API 설계:**\n   - POST /notes/pdf - PDF 메모 전용 생성 엔드포인트\n   - 기존 createNote와 분리하여 PDF 전용 validation 적용\n   - 기존 API들과 호환성 유지\n\n**다음 단계:** Note 모델에 PDF 관련 필드 추가 준비 완료\n</info added on 2025-07-07T04:00:32.568Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 2,
            "title": "Note 모델에 PDF 관련 필드 추가",
            "description": "PDF 메모를 저장하기 위한 추가 필드를 Note 모델에 추가 (pageNumber, highlightedText, pdfUrl 등)",
            "details": "1. INote 인터페이스에 PDF 관련 필드 추가\\n2. NoteSchema에 새 필드들의 Mongoose 스키마 정의\\n3. 기존 데이터와의 호환성 유지 (옵셔널 필드)\\n4. 인덱스 추가 (성능 최적화)\n<info added on 2025-07-07T04:01:41.967Z>\n✅ Note 모델에 PDF 관련 필드 추가 완료\n\n**추가된 필드들:**\n\n1. **INote 인터페이스 확장:**\n   - `isPdfMemo?: boolean` - PDF 메모 구분 플래그\n   - `pageNumber?: number` - PDF 페이지 번호\n   - `highlightedText?: string` - 하이라이트된 원문 텍스트\n   - `highlightData?: object` - 하이라이트 좌표 정보 (x, y, width, height, pageIndex)\n\n2. **NoteSchema 확장:**\n   - 모든 새 필드를 옵셔널로 설정하여 기존 데이터와 호환성 유지\n   - `isPdfMemo`: Boolean, 기본값 false\n   - `pageNumber`: Number, 최소값 1, 기본값 null\n   - `highlightedText`: String, 최대 2000자 (PDF 텍스트는 더 길 수 있음)\n   - `highlightData`: 중첩 객체로 좌표 정보 저장, 모든 하위 필드 required\n\n3. **성능 최적화 인덱스 추가:**\n   - `{ userId: 1, bookId: 1, isPdfMemo: 1 }` - PDF 메모 필터링용\n   - `{ userId: 1, bookId: 1, pageNumber: 1 }` - 페이지별 메모 조회용\n   - `{ isPdfMemo: 1, pageNumber: 1 }` - PDF 메모 페이지 검색용\n\n**다음 단계:** PDF 메모 저장 API 컨트롤러 함수 구현 준비 완료\n</info added on 2025-07-07T04:01:41.967Z>",
            "status": "done",
            "dependencies": [
              "5.1"
            ],
            "parentTaskId": 5
          },
          {
            "id": 3,
            "title": "PDF 메모 저장 API 엔드포인트 구현",
            "description": "PDF 메모를 저장하는 새로운 API 엔드포인트를 notes 컨트롤러에 구현",
            "details": "1. noteController에 createPdfNote 함수 구현\\n2. 요청 데이터 검증 (bookId, pageNumber, highlightedText, memoData)\\n3. 사용자 인증 및 권한 확인\\n4. PDF 메모 데이터베이스 저장\\n5. 에러 핸들링 및 응답 처리\n<info added on 2025-07-07T04:03:01.065Z>\n✅ PDF 메모 저장 API 엔드포인트 구현 완료\n\n**구현된 createPdfNote 함수 기능:**\n\n1. **인증 및 권한 검증:**\n   - 사용자 인증 상태 확인\n   - 책 소유권 확인 (userId와 bookId 매칭)\n   - PDF 파일 등록 여부 확인 (book.pdfUrl 존재 확인)\n\n2. **요청 데이터 처리:**\n   - bookId, type, content, tags (기본 메모 필드)\n   - pageNumber, highlightedText, highlightData (PDF 전용 필드)\n   - selfRating (별점 평가)\n   - isPdfMemo: true 자동 설정\n\n3. **에러 핸들링:**\n   - MongoDB ValidationError 처리 (필드 유효성 검사 실패)\n   - MongoDB CastError 처리 (잘못된 ObjectId 형식)\n   - 일반적인 서버 에러 처리\n   - 상세한 에러 메시지 제공\n\n4. **개발 환경 로깅:**\n   - PDF 메모 생성 성공 시 상세 정보 로깅\n   - 디버깅 및 모니터링을 위한 메타데이터 포함\n\n5. **Note 모델 업데이트:**\n   - selfRating 필드 추가 (1-5 범위, 옵셔널)\n   - PDF 메모 작성 시 별점 평가 저장 지원\n\n**다음 단계:** notes 라우트에 PDF 메모 엔드포인트 추가 준비 완료\n</info added on 2025-07-07T04:03:01.065Z>",
            "status": "done",
            "dependencies": [
              "5.2"
            ],
            "parentTaskId": 5
          },
          {
            "id": 4,
            "title": "notes 라우트에 PDF 메모 엔드포인트 추가",
            "description": "notes.ts 라우터에 PDF 메모 저장을 위한 새로운 라우트와 validation 추가",
            "details": "1. POST /notes/pdf 라우트 추가\\n2. PDF 메모 전용 validation 미들웨어 구성\\n3. express-validator를 사용한 요청 데이터 검증\\n4. 라우트를 createPdfNote 컨트롤러 함수에 연결\n<info added on 2025-07-07T04:04:06.160Z>\n✅ notes 라우트에 PDF 메모 엔드포인트 추가 완료\n\n**구현된 내용:**\n\n1. **createPdfNote 함수 import 추가:**\n   - noteController에서 createPdfNote 함수를 import\n   - 기존 import 목록에 추가\n\n2. **PDF 메모 전용 validation 미들웨어 구성:**\n   - `createPdfNoteValidation` 배열 생성\n   - 필수 필드 검증: bookId, type, content, pageNumber, highlightedText\n   - 옵셔널 필드 검증: tags, selfRating, highlightData\n   - 상세한 타입 및 범위 검증 (MongoId, 정수, 문자열 길이 등)\n\n3. **POST /notes/pdf 라우트 추가:**\n   - PDF 메모 전용 엔드포인트 생성\n   - validation → validateRequest → createPdfNote 순서로 미들웨어 체인 구성\n   - 기존 POST /notes와 분리하여 PDF 전용 로직 적용\n\n4. **상세한 validation 규칙:**\n   - bookId: MongoDB ObjectId 형식 검증\n   - pageNumber: 1 이상의 정수\n   - highlightedText: 최대 2000자 (PDF 텍스트는 더 길 수 있음)\n   - selfRating: 1-5 범위의 정수\n   - highlightData: 좌표 정보 객체 (x, y, width, height, pageIndex)\n\n**API 엔드포인트 완성:** `POST /api/notes/pdf`로 PDF 메모 저장 가능\n\n**다음 단계:** 프론트엔드 API 연동 구현 준비 완료\n</info added on 2025-07-07T04:04:06.160Z>",
            "status": "done",
            "dependencies": [
              "5.3"
            ],
            "parentTaskId": 5
          },
          {
            "id": 5,
            "title": "프론트엔드 API 연동 구현",
            "description": "PdfMemoModal에서 localStorage 대신 실제 API를 호출하도록 수정하고 에러 핸들링 추가",
            "details": "1. lib/api.ts에 PDF 메모 저장 API 함수 추가\\n2. PdfMemoModal의 handleSave 함수 수정\\n3. API 호출 에러 핸들링 및 사용자 피드백\\n4. 성공/실패 상태 UI 업데이트\\n5. TSReadingPage에서 메모 저장 완료 후 처리 로직\n<info added on 2025-07-07T04:06:58.305Z>\n✅ 프론트엔드 API 연동 구현 완료\n\n**구현된 내용:**\n\n1. **lib/api.ts에 PDF 메모 저장 API 함수 추가:**\n   - `notes.createPdf(pdfNoteData)` 함수 구현\n   - POST /notes/pdf 엔드포인트 호출\n   - 기존 notes API와 일관된 구조 유지\n\n2. **PdfMemoModal 대폭 수정:**\n   - localStorage 제거하고 실제 API 호출로 변경\n   - notes.createPdf API 연동\n   - 상세한 에러 핸들링 (validation 에러, 서버 에러 등)\n   - 로딩 상태 UI 추가 (스피너, 버튼 비활성화)\n   - 사용자 친화적인 에러 메시지 표시\n\n3. **API 요청 데이터 구조:**\n   - bookId, type, content, tags (기본 메모 필드)\n   - pageNumber, highlightedText (PDF 전용 필드)\n   - selfRating (별점 평가)\n   - highlightData (향후 하이라이트 좌표 정보 확장 가능)\n\n4. **에러 핸들링 개선:**\n   - API 응답 에러 메시지 표시\n   - validation 에러 배열 처리\n   - 네트워크 오류 등 일반적인 에러 처리\n   - 사용자에게 명확한 피드백 제공\n\n5. **TSReadingPage 연동 수정:**\n   - handleMemoSave 함수 간소화 (API 호출은 모달에서 처리)\n   - props 인터페이스 변경에 맞게 수정 (selectedText, bookId)\n   - null 체크 추가로 타입 안전성 향상\n\n**API 연동 완료:** PDF 메모가 실제 데이터베이스에 저장되고 백엔드 API와 완전히 연동됨\n\n**Phase 5 완료:** PDF 메모 저장 시스템 전체 구현 완료! 🎉\n</info added on 2025-07-07T04:06:58.305Z>",
            "status": "done",
            "dependencies": [
              "5.4"
            ],
            "parentTaskId": 5
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-07T03:10:48.522Z",
      "updated": "2025-07-07T04:07:15.819Z",
      "description": "PDF 기반 동적 지식 캡처 시스템 구현을 위한 태스크 관리"
    }
  },
  "pdf-scroll-feature": {
    "tasks": [
      {
        "id": 25,
        "title": "Initialize Backend Project",
        "description": "Set up the Node.js and Express backend project with TypeScript, including initial configurations for Prisma and necessary middleware.",
        "details": "1. Initialize a new Node.js project using `npm init -y`.\n2. Install Express, TypeScript, and required typings: `npm install express typescript @types/express @types/node --save-dev`.\n3. Configure TypeScript with `tsc --init` and adjust `tsconfig.json` for desired settings (e.g., `target`: \"es2018\", `module`: \"commonjs\", `outDir`: \"./dist\", `esModuleInterop`: true, `strict`: true).\n4. Install Prisma CLI as a development dependency: `npm install prisma --save-dev`.\n5. Initialize Prisma with `npx prisma init --datasource-provider postgresql`.\n6. Install `cors` for handling Cross-Origin Resource Sharing: `npm install cors`.\n7. Create a basic Express server in `src/index.ts`.\n8. Add scripts to `package.json` for building and running the server (e.g., `\"build\": \"tsc\", \"start\": \"node dist/index.js\", \"dev\": \"nodemon src/index.ts\")`.\n9. Install `nodemon` as a development dependency for automatic server restarts during development: `npm install -D nodemon ts-node` and configure it.",
        "testStrategy": "Verify the server starts without errors and responds to a basic health check endpoint.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Define Database Schema with Prisma",
        "description": "Define the PostgreSQL database schema using Prisma, including the `notes`, `concept_scores`, and `score_calculations` tables.",
        "details": "1.  Modify the `schema.prisma` file to define the `notes`, `concept_scores`, and `score_calculations` tables.\n2.  Include fields like `id`, `concept_score` in the `notes` table. The `concept_scores` table should include fields for `noteId`, `score`, `timestamp`, and individual scores for each of the 6 areas (생각추가, 메모진화, 지식연결, 플래시카드, 태그활용, 사용자평점). The `score_calculations` table should include fields for `version`, `calculation_logic`, and `timestamp`.\n3.  Run `npx prisma migrate dev --name init` to create the initial migration and apply the schema to the PostgreSQL database.\n4.  Use Prisma Client to interact with the database in the application code. Install Prisma Client with `npm install @prisma/client`.",
        "testStrategy": "Inspect the PostgreSQL database to ensure that the tables are created with the correct schema. Verify Prisma Client can connect to the database and perform basic CRUD operations.",
        "priority": "high",
        "dependencies": [
          25
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Implement GET Concept Score API",
        "description": "Implement the GET `/api/notes/:noteId/concept-score` endpoint to retrieve the concept score for a given note.",
        "details": "1.  Create a new route in Express for `/api/notes/:noteId/concept-score`.\n2.  Use Prisma Client to query the `notes` table and retrieve the `concept_score` for the specified `noteId`.\n3.  Return the score as a JSON response.\n4.  Implement error handling to return appropriate HTTP status codes for invalid `noteId` or database errors.",
        "testStrategy": "Use `curl` or Postman to send a GET request to `/api/notes/:noteId/concept-score` with a valid `noteId`. Verify the response contains the correct concept score. Test with an invalid `noteId` and ensure an appropriate error response is returned.",
        "priority": "high",
        "dependencies": [
          26
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Implement POST Update Score API",
        "description": "Implement the POST `/api/notes/:noteId/update-score` endpoint to trigger a score update for a given note.",
        "details": "1.  Create a new route in Express for `/api/notes/:noteId/update-score`.\n2.  This endpoint should receive data necessary for score recalculation (e.g., updates to 생각추가, 메모진화, etc.).\n3.  Call the real-time score calculation engine (implemented in task 29) to update the score.\n4.  Update the `concept_score` field in the `notes` table using Prisma Client.\n5.  Create a new entry in the `concept_scores` table to track the score history.\n6.  Return a success message as a JSON response.",
        "testStrategy": "Use `curl` or Postman to send a POST request to `/api/notes/:noteId/update-score` with relevant data. Verify the `concept_score` in the `notes` table is updated, a new entry is created in the `concept_scores` table, and a success message is returned.",
        "priority": "high",
        "dependencies": [
          26
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Express route for /api/notes/:noteId/update-score",
            "description": "Create a new route in Express for the `/api/notes/:noteId/update-score` endpoint to handle POST requests.",
            "dependencies": [],
            "details": "Define the route handler function to receive the noteId and request body.",
            "status": "pending",
            "testStrategy": "Use Postman or curl to send a POST request to the endpoint and verify that the route is accessible."
          },
          {
            "id": 2,
            "title": "Parse and validate request data",
            "description": "Extract and validate the data required for score recalculation from the request body.",
            "dependencies": [],
            "details": "Implement data validation to ensure the required fields (e.g., 생각추가, 메모진화) are present and in the correct format.",
            "status": "pending",
            "testStrategy": "Send POST requests with missing or invalid data and verify that appropriate error responses are returned."
          },
          {
            "id": 3,
            "title": "Call real-time score calculation engine",
            "description": "Invoke the real-time score calculation engine (Task 29) with the validated data to update the score.",
            "dependencies": [],
            "details": "Pass the necessary parameters to the score calculation engine and handle any potential errors during the calculation process.",
            "status": "pending",
            "testStrategy": "Mock the score calculation engine and verify that it is called with the correct parameters."
          },
          {
            "id": 4,
            "title": "Update notes and concept_scores tables",
            "description": "Update the `concept_score` field in the `notes` table and create a new entry in the `concept_scores` table using Prisma Client.",
            "dependencies": [],
            "details": "Use Prisma Client to perform the database updates. Ensure that the updates are atomic and handle potential database errors.",
            "status": "pending",
            "testStrategy": "Verify that the `concept_score` in the `notes` table is updated correctly and a new entry is created in the `concept_scores` table with the correct values."
          },
          {
            "id": 5,
            "title": "Return success message",
            "description": "Return a success message as a JSON response to the client.",
            "dependencies": [],
            "details": "Construct a JSON response indicating the successful update of the concept score.",
            "status": "pending",
            "testStrategy": "Verify that the response contains a success message and an appropriate HTTP status code (e.g., 200 OK)."
          }
        ]
      },
      {
        "id": 29,
        "title": "Develop Real-time Score Calculation Engine",
        "description": "Develop the real-time score calculation engine, implementing the scoring algorithms for each of the six areas (생각추가, 메모진화, 지식연결, 플래시카드, 태그활용, 사용자평점).",
        "details": "1.  Create a function that takes relevant data as input (e.g., data related to 생각추가, 메모진화, etc.).\n2.  Implement the scoring logic for each of the six areas based on the provided formulas:\n    *   생각추가: 4단계 완성도 + 텍스트 길이 (max 20)\n    *   메모진화: 4단계 완성 + 진화 속도 (max 20)\n    *   지식연결: 연결 개수 + 다양성 + 품질 (max 20)\n    *   플래시카드: 생성 + 복습 + 난이도 (max 20)\n    *   태그 활용: 개수 + 품질 + 다양성 (max 10)\n    *   사용자 평점: 평점 존재 + 높음 + 업데이트 (max 10)\n3.  Combine the scores from each area to calculate the final concept score.\n4.  Consider using a configuration table (`score_calculations`) to manage different versions of the calculation logic.",
        "testStrategy": "Write unit tests to verify the scoring logic for each of the six areas. Ensure the scores are calculated correctly based on different input values. Test the overall score calculation with various combinations of input data.",
        "priority": "high",
        "dependencies": [
          26
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Data Input Structure",
            "description": "Define the structure and format of the input data required for the score calculation function. This includes specifying the data types and units for each input parameter related to 생각추가, 메모진화, 지식연결, 플래시카드, 태그활용, and 사용자평점.",
            "dependencies": [],
            "details": "Research and document the specific data points needed for each scoring area. For example, for '생각추가', define how '4단계 완성도' and '텍스트 길이' will be represented. Consider using a JSON schema or similar data definition language.",
            "status": "pending",
            "testStrategy": "Create sample input data sets that conform to the defined structure. Verify that the data can be parsed and processed correctly by the scoring engine."
          },
          {
            "id": 2,
            "title": "Implement Scoring Logic for Individual Areas",
            "description": "Implement the scoring algorithms for each of the six areas (생각추가, 메모진화, 지식연결, 플래시카드, 태그활용, 사용자평점) based on the provided formulas. Each area should have its own dedicated function or module.",
            "dependencies": [],
            "details": "Translate the formulas into code. For example, for '생각추가', implement the logic to calculate the score based on '4단계 완성도' and '텍스트 길이', ensuring the maximum score is 20. Handle edge cases and invalid input gracefully.",
            "status": "pending",
            "testStrategy": "Write unit tests for each scoring area to verify the score is calculated correctly for different input values. Test boundary conditions and edge cases."
          },
          {
            "id": 3,
            "title": "Create Score Combination Function",
            "description": "Develop a function that combines the individual scores from each of the six areas to calculate the final concept score. This function should aggregate the scores and potentially apply weighting factors if needed.",
            "dependencies": [
              "29.2"
            ],
            "details": "Implement the logic to sum the scores from each area. Consider adding the ability to configure weights for each area in the `score_calculations` table. Ensure the final score is within a reasonable range.",
            "status": "pending",
            "testStrategy": "Test the score combination function with various combinations of input scores from the individual areas. Verify that the final score is calculated correctly and that the weighting factors are applied as expected."
          },
          {
            "id": 4,
            "title": "Implement Configuration Table Access",
            "description": "Implement the logic to access and utilize the `score_calculations` configuration table. This table should allow for managing different versions of the calculation logic and potentially weighting factors for each area.",
            "dependencies": [],
            "details": "Establish a connection to the database or data source where the `score_calculations` table is stored. Implement functions to retrieve the appropriate configuration based on a version identifier or other criteria. Cache the configuration data for performance.",
            "status": "pending",
            "testStrategy": "Create different versions of the `score_calculations` table with varying calculation logic and weighting factors. Verify that the scoring engine uses the correct configuration based on the specified version."
          },
          {
            "id": 5,
            "title": "Integrate and Test Real-time Score Calculation",
            "description": "Integrate all the components of the score calculation engine and test the end-to-end functionality. This includes retrieving data, calculating individual area scores, combining the scores, and utilizing the configuration table.",
            "dependencies": [
              "29.1",
              "29.2",
              "29.3",
              "29.4"
            ],
            "details": "Connect the score calculation engine to the relevant data sources. Implement the API endpoint to trigger the score calculation. Monitor performance and identify any bottlenecks.",
            "status": "pending",
            "testStrategy": "Perform end-to-end testing of the score calculation engine with realistic data sets. Verify that the scores are calculated correctly and that the performance is acceptable. Monitor the system for errors and performance issues."
          }
        ]
      },
      {
        "id": 30,
        "title": "Initialize Frontend Project",
        "description": "Set up the React and TypeScript frontend project using Create React App, including Tailwind CSS for styling.",
        "details": "1.  Create a new React project with TypeScript using `npx create-react-app habitus-frontend --template typescript`.\n2.  Install Tailwind CSS and its dependencies: `npm install -D tailwindcss postcss autoprefixer && npx tailwindcss init -p`.\n3.  Configure Tailwind CSS by adding the directives to `./src/index.css` and configuring the `tailwind.config.js` file.\n4.  Install Axios for making HTTP requests: `npm install axios`.",
        "testStrategy": "Verify the React application starts without errors and displays a basic UI. Ensure Tailwind CSS styles are applied correctly.",
        "priority": "high",
        "dependencies": [
          25
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Implement Concept Score Icon",
        "description": "Develop the UI component to display the concept score icon in the upper right corner of the memo card.",
        "details": "1.  Create a new React component for the concept score icon.\n2.  Fetch the concept score from the backend API (`/api/notes/:noteId/concept-score`) using Axios.\n3.  Display the score using one of the specified icons (💡🧠🎯⭐) based on the score range.\n4.  Implement color coding (red -> orange -> green -> blue) based on the score value using Tailwind CSS classes.",
        "testStrategy": "Verify the concept score icon is displayed correctly on the memo card. Ensure the icon and color coding change based on the score value. Test with different `noteId` values.",
        "priority": "high",
        "dependencies": [
          30,
          27
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create React Component for Concept Score Icon",
            "description": "Develop a new React component to display the concept score icon.",
            "dependencies": [],
            "details": "Create a functional React component that will fetch and display the concept score icon. This component will be placed in the upper right corner of the memo card.",
            "status": "pending",
            "testStrategy": "Verify the component renders without errors and is positioned correctly on the memo card."
          },
          {
            "id": 2,
            "title": "Fetch Concept Score from API",
            "description": "Implement the logic to fetch the concept score from the backend API.",
            "dependencies": [],
            "details": "Use Axios to make a GET request to `/api/notes/:noteId/concept-score`. Handle potential errors and store the retrieved score in the component's state.",
            "status": "pending",
            "testStrategy": "Test with different `noteId` values to ensure the correct score is fetched. Verify error handling for invalid `noteId` values."
          },
          {
            "id": 3,
            "title": "Determine Icon Based on Score Range",
            "description": "Implement the logic to select the appropriate icon based on the concept score range.",
            "dependencies": [],
            "details": "Create a function that takes the concept score as input and returns the corresponding icon (💡🧠🎯⭐) based on predefined score ranges.",
            "status": "pending",
            "testStrategy": "Test with various score values to ensure the correct icon is selected for each range."
          },
          {
            "id": 4,
            "title": "Implement Color Coding with Tailwind CSS",
            "description": "Apply color coding to the icon based on the score value using Tailwind CSS classes.",
            "dependencies": [],
            "details": "Create a function that takes the concept score as input and returns the appropriate Tailwind CSS class for the color (red -> orange -> green -> blue). Apply this class to the icon element.",
            "status": "pending",
            "testStrategy": "Test with various score values to ensure the correct color is applied to the icon for each range."
          },
          {
            "id": 5,
            "title": "Integrate Component into Memo Card",
            "description": "Integrate the concept score icon component into the memo card UI.",
            "dependencies": [],
            "details": "Import the concept score icon component into the memo card component and render it in the upper right corner. Pass the `noteId` as a prop to the concept score icon component.",
            "status": "pending",
            "testStrategy": "Verify the concept score icon is displayed correctly on the memo card with the correct icon and color based on the note's score. Test with different `noteId` values."
          }
        ]
      },
      {
        "id": 32,
        "title": "Implement Detailed Score Popup",
        "description": "Implement the detailed score popup that appears when the concept score icon is clicked, displaying the individual scores for each of the six areas.",
        "details": "1.  Create a new React component for the score popup.\n2.  Fetch the detailed scores for each of the six areas from the backend API or calculate them on the frontend if necessary.\n3.  Display the scores in a clear and organized manner within the popup.\n4.  Use Tailwind CSS to style the popup and ensure it is visually appealing.",
        "testStrategy": "Verify the score popup appears when the concept score icon is clicked. Ensure the individual scores for each area are displayed correctly. Test with different score values and ensure the popup content updates accordingly.",
        "priority": "medium",
        "dependencies": [
          31,
          27,
          29
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create React Component for Score Popup",
            "description": "Develop a new React component to serve as the foundation for the detailed score popup.",
            "dependencies": [],
            "details": "Create a functional or class-based React component. Define the basic structure and styling placeholders. Ensure the component can be rendered and displayed on the screen.",
            "status": "pending",
            "testStrategy": "Verify the component renders without errors. Check that the basic structure is in place and that styling placeholders are visible."
          },
          {
            "id": 2,
            "title": "Fetch/Calculate Detailed Scores",
            "description": "Implement the logic to retrieve or calculate the detailed scores for each of the six areas.",
            "dependencies": [],
            "details": "Determine whether to fetch the scores from the backend API (Task 27) or calculate them on the frontend. Implement the necessary API calls or calculation logic. Handle potential errors during data retrieval or calculation.",
            "status": "pending",
            "testStrategy": "Check that the correct scores are fetched from the API or calculated accurately. Verify error handling for API failures or invalid data."
          },
          {
            "id": 3,
            "title": "Display Scores in Popup",
            "description": "Organize and display the fetched/calculated scores within the popup component.",
            "dependencies": [],
            "details": "Structure the score data in a clear and understandable format. Use appropriate UI elements (e.g., tables, charts, lists) to display the scores for each area. Ensure the display is responsive and adapts to different screen sizes.",
            "status": "pending",
            "testStrategy": "Verify that all six area scores are displayed correctly. Check the formatting and layout for clarity and readability. Test responsiveness on different devices."
          },
          {
            "id": 4,
            "title": "Style Popup with Tailwind CSS",
            "description": "Apply Tailwind CSS classes to style the popup and ensure it is visually appealing and consistent with the application's design.",
            "dependencies": [],
            "details": "Use Tailwind CSS classes to style the popup container, headings, labels, and score values. Ensure the popup has a consistent look and feel with the rest of the UI. Pay attention to typography, spacing, and color palette.",
            "status": "pending",
            "testStrategy": "Verify that the popup styling matches the design specifications. Check for consistency with other UI elements. Ensure the popup is visually appealing and easy to read."
          },
          {
            "id": 5,
            "title": "Integrate Popup with Concept Score Icon",
            "description": "Connect the score popup to the concept score icon, so that clicking the icon triggers the popup to appear.",
            "dependencies": [],
            "details": "Implement the event handler for the concept score icon click. Use React state management to control the visibility of the popup. Ensure the popup appears in the correct position relative to the icon.",
            "status": "pending",
            "testStrategy": "Verify that the popup appears when the concept score icon is clicked. Check that the popup closes when clicking outside of it or on a close button (if implemented). Ensure the popup position is correct."
          }
        ]
      },
      {
        "id": 33,
        "title": "Implement Quick Action Buttons",
        "description": "Implement the quick action buttons within the score popup, allowing users to take actions related to improving their concept understanding.",
        "details": "1.  Add buttons to the score popup for actions like \"Add Thoughts,\" \"Evolve Memo,\" \"Connect Knowledge,\" \"Create Flashcard,\" \"Add Tag,\" and \"Rate.\"\n2.  Implement the functionality for each button, such as navigating to the appropriate page or triggering an API call.\n3.  Ensure the buttons are styled consistently with the rest of the UI using Tailwind CSS.",
        "testStrategy": "Verify the quick action buttons are displayed correctly in the score popup. Ensure each button performs the correct action when clicked. Test with different user roles and permissions to ensure the buttons are enabled/disabled appropriately.",
        "priority": "medium",
        "dependencies": [
          32,
          28
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Quick Action Buttons to Score Popup UI",
            "description": "Add the specified quick action buttons (Add Thoughts, Evolve Memo, Connect Knowledge, Create Flashcard, Add Tag, Rate) to the score popup React component.",
            "dependencies": [],
            "details": "Modify the React component created in Task 32 to include the quick action buttons. Use Tailwind CSS for styling to ensure consistency with the existing UI.",
            "status": "pending",
            "testStrategy": "Verify the quick action buttons are displayed correctly in the score popup and are visually consistent with the rest of the UI."
          },
          {
            "id": 2,
            "title": "Implement 'Add Thoughts' Action",
            "description": "Implement the functionality for the 'Add Thoughts' button. This likely involves navigating the user to a page where they can add thoughts related to the concept.",
            "dependencies": [],
            "details": "Determine the appropriate page or component for adding thoughts. Implement the navigation logic when the 'Add Thoughts' button is clicked.",
            "status": "pending",
            "testStrategy": "Click the 'Add Thoughts' button and verify that the user is navigated to the correct page or component for adding thoughts."
          },
          {
            "id": 3,
            "title": "Implement 'Evolve Memo', 'Connect Knowledge', 'Create Flashcard' Actions",
            "description": "Implement the functionality for the 'Evolve Memo', 'Connect Knowledge', and 'Create Flashcard' buttons. These actions may involve navigating to different pages or triggering API calls.",
            "dependencies": [],
            "details": "Determine the appropriate actions for each button. Implement the navigation logic or API calls when the buttons are clicked.",
            "status": "pending",
            "testStrategy": "Click each button and verify that the correct action is performed (navigation or API call)."
          },
          {
            "id": 4,
            "title": "Implement 'Add Tag' and 'Rate' Actions",
            "description": "Implement the functionality for the 'Add Tag' and 'Rate' buttons. These actions may involve triggering API calls to update the concept's tags or rating.",
            "dependencies": [],
            "details": "Implement the API calls to update the concept's tags and rating when the buttons are clicked. Handle success and error responses appropriately.",
            "status": "pending",
            "testStrategy": "Click each button and verify that the correct API call is made and the concept's tags or rating are updated accordingly."
          },
          {
            "id": 5,
            "title": "Test Quick Action Buttons with Different User Roles",
            "description": "Test the quick action buttons with different user roles and permissions to ensure the buttons are enabled/disabled appropriately.",
            "dependencies": [],
            "details": "Create different user roles with varying permissions. Log in with each role and verify that the quick action buttons are enabled or disabled based on the user's permissions.",
            "status": "pending",
            "testStrategy": "Log in with different user roles and verify that the quick action buttons are enabled/disabled as expected based on the user's permissions."
          }
        ]
      },
      {
        "id": 34,
        "title": "Implement Score Calculation Caching",
        "description": "Implement caching for the score calculation to improve performance and reduce the load on the database.",
        "details": "1.  Use a caching library like `node-cache` or Redis to store the calculated concept scores.\n2.  Implement a cache invalidation strategy to ensure the cache is updated when the underlying data changes.\n3.  Consider using a time-to-live (TTL) value for the cache entries to prevent stale data.",
        "testStrategy": "Measure the response time of the GET `/api/notes/:noteId/concept-score` endpoint with and without caching. Verify the response time is significantly faster with caching enabled. Ensure the cache is invalidated correctly when the underlying data changes.",
        "priority": "medium",
        "dependencies": [
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Optimize Real-time Score Updates",
        "description": "Optimize the real-time score updates to minimize the impact on performance and ensure a smooth user experience.",
        "details": "1.  Use techniques like debouncing or throttling to limit the frequency of score updates.\n2.  Consider using a message queue (e.g., RabbitMQ or Kafka) to handle score updates asynchronously.\n3.  Optimize the database queries used in the score calculation engine.",
        "testStrategy": "Simulate a high volume of score updates and measure the impact on performance. Verify the system can handle the load without significant degradation. Ensure the user experience remains smooth and responsive.",
        "priority": "medium",
        "dependencies": [
          28,
          29
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Debouncing/Throttling for Score Updates",
            "description": "Implement debouncing or throttling techniques to limit the frequency of score updates sent to the client, reducing server load and improving UI responsiveness.",
            "dependencies": [],
            "details": "Research and implement either debouncing or throttling. Configure the optimal delay based on testing. Ensure that the final score is always reflected eventually.",
            "status": "pending",
            "testStrategy": "Simulate rapid score changes and verify that updates are sent at the configured rate. Measure the impact on server load and UI responsiveness."
          },
          {
            "id": 2,
            "title": "Evaluate and Implement Message Queue for Asynchronous Updates",
            "description": "Evaluate the feasibility of using a message queue (e.g., RabbitMQ or Kafka) to handle score updates asynchronously, decoupling the score calculation engine from the UI and improving scalability.",
            "dependencies": [],
            "details": "Research RabbitMQ and Kafka. Set up a test environment with one of the message queues. Implement a simple producer/consumer to test asynchronous score updates.",
            "status": "pending",
            "testStrategy": "Simulate a high volume of score updates and measure the message queue's performance. Verify that all updates are processed correctly and eventually reflected in the UI."
          },
          {
            "id": 3,
            "title": "Optimize Database Queries in Score Calculation Engine",
            "description": "Analyze and optimize the database queries used in the real-time score calculation engine to reduce query execution time and database load.",
            "dependencies": [],
            "details": "Profile the database queries used by the score calculation engine. Identify slow queries and optimize them using techniques like indexing, query rewriting, or caching.",
            "status": "pending",
            "testStrategy": "Measure the execution time of the optimized queries and compare them to the original queries. Verify that the optimization reduces database load and improves overall performance."
          },
          {
            "id": 4,
            "title": "Profile and Optimize Score Calculation Logic",
            "description": "Profile the score calculation engine to identify performance bottlenecks within the scoring algorithms themselves and optimize the code for efficiency.",
            "dependencies": [],
            "details": "Use profiling tools to identify the most time-consuming parts of the score calculation logic. Optimize the code by using efficient algorithms, data structures, and coding techniques.",
            "status": "pending",
            "testStrategy": "Measure the execution time of the optimized score calculation logic and compare it to the original logic. Verify that the optimization reduces CPU usage and improves overall performance."
          },
          {
            "id": 5,
            "title": "Performance Testing and User Experience Validation",
            "description": "Conduct performance testing to simulate a high volume of score updates and validate that the system can handle the load without significant degradation. Ensure the user experience remains smooth and responsive.",
            "dependencies": [
              "35.1",
              "35.2",
              "35.3",
              "35.4"
            ],
            "details": "Simulate a realistic workload of score updates. Monitor system performance metrics such as CPU usage, memory usage, and response time. Gather user feedback on the smoothness and responsiveness of the UI.",
            "status": "pending",
            "testStrategy": "Use load testing tools to simulate a high volume of concurrent users and score updates. Measure the system's throughput, latency, and error rate. Conduct user testing to gather feedback on the user experience."
          }
        ]
      },
      {
        "id": 36,
        "title": "Implement Database Indexing",
        "description": "Implement database indexing to improve the performance of queries related to concept scores.",
        "details": "1.  Identify the columns used in queries related to concept scores (e.g., `noteId` in the `concept_scores` table).\n2.  Create indexes on these columns to speed up query execution.\n3.  Use the `EXPLAIN` command in PostgreSQL to analyze query performance and identify areas for improvement.",
        "testStrategy": "Measure the response time of queries related to concept scores with and without indexing. Verify the response time is significantly faster with indexing enabled. Monitor the database performance to ensure the indexes are being used effectively.",
        "priority": "medium",
        "dependencies": [
          26
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Write Unit Tests for Score Calculation",
        "description": "Write unit tests for the score calculation logic using Jest to ensure the algorithms are accurate and reliable.",
        "details": "1.  Install Jest and its TypeScript typings: `npm install --save-dev jest @types/jest ts-jest`.\n2.  Configure Jest in `jest.config.js`.\n3.  Write unit tests for each of the six scoring areas, covering different input values and edge cases.\n4.  Use Jest's assertion library to verify the scores are calculated correctly.",
        "testStrategy": "Run the Jest unit tests and verify all tests pass. Ensure the tests cover all critical aspects of the score calculation logic.",
        "priority": "high",
        "dependencies": [
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "Write Integration Tests for API Endpoints",
        "description": "Write integration tests for the API endpoints using Jest and Supertest to ensure the endpoints are functioning correctly and interacting with the database as expected.",
        "details": "1.  Install Supertest: `npm install supertest --save-dev`.\n2.  Write integration tests for the GET `/api/notes/:noteId/concept-score` and POST `/api/notes/:noteId/update-score` endpoints.\n3.  Use Supertest to send HTTP requests to the endpoints and verify the responses.\n4.  Ensure the tests cover different scenarios, such as valid and invalid input values, and database errors.",
        "testStrategy": "Run the Jest integration tests and verify all tests pass. Ensure the tests cover all critical aspects of the API endpoints.",
        "priority": "high",
        "dependencies": [
          27,
          28
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "Write E2E Tests for UI Flow",
        "description": "Write end-to-end (E2E) tests for the UI flow using Cypress or Playwright to ensure the user interface is functioning correctly and the user experience is smooth.",
        "details": "1.  Install Cypress or Playwright: `npm install cypress --save-dev` or `npm install playwright --save-dev`.\n2.  Write E2E tests to simulate user interactions with the concept score icon, score popup, and quick action buttons.\n3.  Verify the UI elements are displayed correctly and the user can navigate through the flow without errors.",
        "testStrategy": "Run the Cypress or Playwright E2E tests and verify all tests pass. Ensure the tests cover all critical aspects of the UI flow.",
        "priority": "medium",
        "dependencies": [
          31,
          32,
          33
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-07T08:48:57.524Z",
      "updated": "2025-07-24T11:58:33.188Z",
      "description": "Tasks for pdf-scroll-feature context"
    }
  }
}