# Habitus33 지식 흐름: 메모 입력부터 온톨로지까지

이 문서는 Habitus33 서비스에서 사용자가 자연어 메모를 입력하고, 이 메모가 어떻게 '지식'으로 진화하며, 최종적으로 온톨로지 기반의 구조화된 데이터로 기록되어 AI 에이전트가 사용자를 '프롬프트 없이' 깊이 이해하는지 전 과정을 설명합니다.

---

## 1. 지식 기록의 시작: 3가지 메모 유형

Habitus33에서는 사용자가 자신의 생각을 기록하는 방식에 따라 크게 세 가지 종류의 메모를 제공합니다. 모든 메모는 궁극적으로 백엔드의 `Note` 모델로 저장되며, 프론트엔드에서는 `TSNoteCard`라는 UI 컴포넌트를 통해 관리됩니다.

### 1.1. TS 메모 (Thought Sprints Memo)

*   **작성 시퀀스**: 사용자가 '생각 스프린트(TS)' 모드에서 책을 읽는 독서 세션 도중 실시간으로 작성하는 1줄 메모입니다. 이 메모는 특정 독서 활동의 맥락과 함께 기록됩니다.
*   **데이터 흐름**:
    1.  **프론트엔드**: 독서 세션 UI(`frontend/app/reading-session/page.client.tsx`)에서 메모를 입력합니다.
    2.  **API 호출**: 세션이 완료될 때, 메모 내용과 함께 독서 속도(PPM), 시간 등의 세션 정보가 백엔드의 `sessionController.ts`에 전송됩니다.
    3.  **백엔드 저장**: `sessionController.ts`는 이 데이터를 `Note` 모델(`backend/src/models/Note.ts`)로 생성하여 데이터베이스에 저장합니다. 이때, `originSession` 필드를 통해 해당 메모가 어떤 독서 세션에서 나왔는지 명확히 연결됩니다.

### 1.2. PDF 메모

*   **작성 시퀀스**: 사용자가 업로드된 PDF 문서를 열람하면서, 중요한 부분에 하이라이트를 하거나 특정 위치에 직접 메모를 추가하는 방식입니다.
*   **데이터 흐름**:
    1.  **프론트엔드**: PDF 뷰어 UI(`frontend/components/pdf/` 관련 컴포넌트)에서 텍스트를 선택하거나 메모를 입력합니다.
    2.  **API 호출**: 메모 내용과 함께 PDF 문서 내의 페이지 번호, 하이라이트된 텍스트, 좌표 정보 등이 백엔드로 전송됩니다.
    3.  **백엔드 저장**: 이 데이터는 `Note` 모델(`backend/src/models/Note.ts`)로 저장되며, `isPdfMemo: true`, `pageNumber`, `highlightedText`, `highlightData` 등의 필드가 채워져 PDF 원본과의 연결성을 명확히 합니다.

### 1.3. Notebook 메모 (독립 메모)

*   **작성 시퀀스**: 특정 독서 세션이나 PDF 문서와 직접적인 연관 없이, 사용자가 자유롭게 아이디어나 생각을 기록하고 싶을 때 사용하는 독립적인 메모 방식입니다. 마치 개인 노트에 자유롭게 필기하는 것과 유사합니다.
*   **데이터 흐름**:
    1.  **프론트엔드**: 독립적인 메모 작성 UI(`frontend/app/memo/new/page.tsx`)를 통해 내용을 입력합니다.
    2.  **API 호출**: 메모 내용이 백엔드의 `noteController.ts` (또는 유사한 메모 생성 API)로 전송됩니다.
    3.  **백엔드 저장**: 이 데이터도 `Note` 모델(`backend/src/models/Note.ts`)로 저장되지만, `originSession`이나 `isPdfMemo` 필드는 비어있어 독립적인 메모임을 나타냅니다.

---

## 2. `TSNoteCard`로의 수렴과 '지식 진화'

위에서 설명한 세 가지 유형의 메모는 모두 백엔드의 `Note` 모델 인스턴스로 데이터베이스에 저장됩니다. 프론트엔드에서는 이 `Note` 모델 데이터를 기반으로 **`TSNoteCard`** 라는 통합된 UI 컴포넌트가 만들어집니다. `TSNoteCard`는 단순한 메모 표시를 넘어, 지식을 '발전'시키기 위한 다양한 상호작용의 중심이 됩니다.

### 2.1. 인라인 메모 쓰레드 (Inline Threads)

*   **개념**: `TSNoteCard` 내에서 특정 메모 내용에 대해 추가적인 질문, 답변, 또는 논의를 '댓글'처럼 이어나가는 기능입니다.
*   **데이터 흐름**: `Note` 모델의 `inlineThreads` 필드가 `InlineThread` 모델을 참조하여, 하나의 메모에 여러 개의 대화 쓰레드가 연결될 수 있도록 합니다. 이는 메모의 맥락을 풍부하게 하고 다각적인 사고를 유도합니다.

### 2.2. 4단계 메모 진화 (Memo Evolution)

*   **개념**: 하비투스33의 핵심적인 '지식 내재화' 과정으로, 사용자가 다음 4가지 질문에 답변하며 메모를 심층적으로 발전시킵니다.
    1.  **중요성 인식**: "왜 이것이 중요한가?" (필드: `importanceReason`)
    2.  **맥락 기록**: "언제, 어떤 상황에서 이 생각을 했나?" (필드: `momentContext`)
    3.  **지식 연결**: "기존 지식과 어떻게 연결되나?" (필드: `relatedKnowledge`)
    4.  **심상 형성**: "이것을 하나의 이미지나 비유로 표현한다면?" (필드: `mentalImage`)
*   **데이터 흐름**:
    1.  **프론트엔드**: `TSNoteCard` UI에서 사용자가 각 질문에 대한 답변을 입력합니다.
    2.  **백엔드 저장**: 답변 내용은 `Note` 모델의 해당 필드(`importanceReason` 등)에 저장됩니다. 이때 `memoEvolutionTimestamp` 필드가 업데이트되어 진화가 발생한 시점이 기록됩니다.
    3.  **온톨로지화**: `backend/src/utils/jsonLdBuilder.ts`는 이 4단계 진화 필드와 `memoEvolutionTimestamp`를 활용하여, JSON-LD 내에서 '메모 진화 이벤트'를 `UpdateAction` 형태로 온톨로지화합니다. 이는 AI가 사용자의 사고 과정과 지식의 내재화 단계를 이해하는 핵심 데이터가 됩니다.

### 2.3. 지식 연결 (Knowledge Linking)

*   **개념**: `TSNoteCard`에서 해당 메모와 관련된 외부 지식 리소스(책, 논문, 유튜브, 웹사이트)나 다른 메모/개념들을 연결하여 지식 네트워크를 확장합니다.
*   **데이터 흐름**:
    1.  **프론트엔드**: `TSNoteCard` UI에서 관련 리소스를 추가하거나, 다른 메모/개념과의 관계를 정의합니다.
    2.  **백엔드 저장**:
        *   `Note` 모델의 `relatedLinks` 필드에 연결된 리소스 정보(유형, URL)가 저장됩니다.
        *   `backend/src/services/BeliefNetworkService.ts`는 메모의 내용(특히 진화된 필드들)을 분석하여 '개념(BeliefNode)'과 '관계(BeliefEdge)'를 추출하고, 이를 Fuseki라는 지식 그래프 데이터베이스에 저장합니다. 이는 파편화된 메모를 연결하여 하나의 큰 지식 네트워크를 만듭니다.
    3.  **AI 맥락 부여**: `backend/src/services/ResponseHandler.ts`는 AI 응답 시, 이 연결 여부에 따라 지식의 출처(사용자 순수 vs AI 보조) 및 '지식 진화 단계'(`connected`, `synthesized`, `gap_filled`) 같은 메타데이터를 추가합니다.

### 2.4. 플래시카드 (Flashcard)

*   **개념**: `TSNoteCard`의 내용을 기반으로 '질문-답변' 형태의 플래시카드를 생성하여, 간격 반복(Spaced Repetition) 학습을 통해 장기 기억으로 전환을 돕습니다.
*   **데이터 흐름**:
    1.  **프론트엔드**: `TSNoteCard` UI에서 특정 메모를 바탕으로 플래시카드 생성을 요청합니다.
    2.  **API 호출**: `flashcardController.ts`의 `fromMemo` API가 호출되며, 원본 `Note`의 ID, 질문, 답변 등이 전송됩니다.
    3.  **백엔드 저장**: `backend/src/models/Flashcard.ts`의 `Flashcard` 모델 인스턴스가 생성되어 저장됩니다. 이 플래시카드는 `memoId`를 통해 원본 `Note`에 직접 연결되며, `srsState` 필드를 통해 복습 주기와 같은 학습 상태가 관리됩니다.

---

## 3. 지식의 종합: '단권화 노트' 제작 및 온톨로지 기록

개별 메모들이 `TSNoteCard`를 통해 진화하는 것을 넘어, 사용자는 자신이 관심 있는 여러 메모들을 한데 모아 '단권화 노트'를 제작함으로써 지식을 종합합니다.

### 3.1. '단권화 노트' 제작 과정

*   **지식 카트 (Knowledge Cart)**: 사용자는 `TSNoteCard` UI에서 자신이 '단권화'하고자 하는 메모들을 임시적인 '지식 카트' (주로 프론트엔드 상태 관리, 예: `frontend/store/cartStore.ts`)에 담습니다.
*   **단권화 노트 생성 요청**: 사용자가 단권화 노트 생성 UI(`frontend/app/summary-notes/create/page.tsx`)에서 카트에 담긴 메모들을 바탕으로 새로운 노트를 만듭니다. 이때 노트의 제목, 설명, 그리고 사용자가 직접 작성하는 '인사이트(마크다운 콘텐츠)'가 함께 입력될 수 있습니다.
*   **백엔드 저장**: 백엔드는 `backend/src/models/SummaryNote.ts`의 `SummaryNote` 모델 인스턴스를 생성하여 데이터베이스에 저장합니다.
    *   **`orderedNoteIds`**: 이 필드는 '지식 카트'에서 선택된 모든 개별 `Note`들의 ID 목록을 순서대로 저장합니다. 이를 통해 여러 메모들이 하나의 단권화 노트 아래 논리적으로 묶이게 됩니다.
    *   **`userMarkdownContent`**: 사용자가 직접 작성한 마크다운 형식의 종합적인 통찰이나 요약 내용이 저장됩니다. 이는 AI가 사용자의 '고차원적 사고'를 이해하는 데 매우 중요한 정보입니다.

### 3.2. 단권화 노트의 JSON-LD 온톨로지 기록

'단권화 노트'는 하비투스33의 지식 종합 결과물이자, AI 에이전트에게 사용자의 최고 수준의 '생각 진화'를 전달하는 핵심 데이터입니다.

*   **`jsonLdBuilder.ts` 활용**: `backend/src/utils/jsonLdBuilder.ts`의 `buildJsonLd` 함수는 `SummaryNote` 데이터를 입력으로 받아 최종 JSON-LD를 생성합니다.
*   **JSON-LD에 기록되는 내용**:
    *   **메인 엔티티**: `SummaryNote`의 제목(`title`), 설명(`description`), 그리고 사용자가 직접 작성한 마크다운 콘텐츠(`userMarkdownContent`)는 JSON-LD의 최상위 스키마(예: Schema.org의 `HowTo`, `Article` 등)의 핵심 정보로 통합됩니다. 이는 AI가 단권화 노트의 전체적인 주제와 사용자 통찰을 파악하는 데 사용됩니다.
    *   **개별 메모 진화 과정 통합**: `SummaryNote`에 포함된 모든 개별 `Note`들의 상세한 '메모 진화 이벤트'(4단계 답변, 진화 타임스탬프)가 JSON-LD의 큰 '학습 여정'(`learningEvents` 배열) 내에 다시 기록됩니다. 즉, 단권화된 지식은 그 안에 담긴 모든 개별 지식 조각들의 진화 히스토리를 포함하게 됩니다.
    *   **AI 링크 결과물**: 최종적으로 이 단권화 노트 자체가 AI 에이전트가 이해하고 활용할 수 있는 '구조화된 생각진화 데이터'의 중요한 결과물로 JSON-LD에 표현됩니다.

---

## 4. 결론: 'Prompt-Free'를 향한 지식 그래프

이 모든 과정은 하비투스33이 추구하는 "Prompt Free" 철학의 핵심입니다. 사용자가 직접 '프롬프트'를 작성하지 않아도, 시스템은 사용자의 다양한 메모 입력 방식과 '메모 진화', '지식 연결', '단권화'와 같은 모든 지적 활동을 시계열적 타임스탬프와 온톨로지 기반의 구조화된 데이터(JSON-LD)로 상세하게 기록하고 지식 그래프에 통합합니다.

이를 통해 AI 에이전트는 사용자의 **생각의 종류, 진화 과정, 관심사, 지식의 연결성, 그리고 최종적인 통찰**까지 깊이 이해할 수 있게 됩니다. AI는 이 방대한 지식 그래프를 바탕으로 사용자의 명시적인 질문(프롬프트) 없이도 맥락에 맞는 초개인화된 정보 제공, 지식 추론, 그리고 능동적인 학습 지원이 가능해집니다.

---

이 문서가 Habitus33의 지식 흐름을 이해하는 데 도움이 되기를 바랍니다. 