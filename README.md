# Habitus33 - 당신의 생각을 이해하는 AI 학습 플랫폼

> **"Prompt Free, Habitus33"**  
> 당신의 생각은, 그 자체로 가장 완벽한 프롬프트가 됩니다.

Habitus33은 더 이상 사용자가 AI에게 질문하는 법을 배울 필요 없는 세상을 꿈꿉니다.
당신의 작은 독서와 메모가 만들어내는 자연스러운 생각의 흐름, 그 '파도'를 AI가 먼저 이해하고, 가장 깊은 곳의 통찰을 건져 올리는 **Prompt-Free 학습 경험**을 제공합니다.

## 🎯 **핵심 가치**
- **지식 캡슐화**: AI-Link를 통한 맥락 보존 및 전달
- **개인화된 학습**: 읽기 목적별 차별화된 메모진화 시스템
- **온톨로지 기반**: 구조화된 지식그래프로 AI 이해도 극대화
- **시간 정보 보존**: 학습 여정의 모든 시간적 맥락 추적

---

## 🧠 **AMFA 엔진: 4단계 지식 내재화 시스템**

Habitus33의 핵심인 **AMFA(Atomic Reading, Memo Evolve, Furnace Knowledge, AI-Link) 엔진**은 당신의 생각을 AI가 완벽히 이해할 수 있는 '지식 캡슐'로 변환합니다.

### **A**tomic Reading (3분 집중독서)
- 3분간 집중하여 핵심 내용을 읽고 1줄 메모 작성
- PPM(분당 페이지 수), 읽기 속도, 집중도 등 인지 메트릭 자동 측정
- 독서 목적별 차별화: `exam_prep`, `practical_knowledge`, `humanities_self_reflection`, `reading_pleasure`

### **M**emo Evolve (4단계 메모진화)
각 읽기 목적에 맞는 차별화된 질문으로 메모를 진화시킵니다:
- **시험 준비**: "어떤 부분이 중요하다고 느껴졌나요?" → "표현할 수 있는 방법은 무엇인가요?"
- **실무 지식**: "어떻게 내 업무와 연결되나요?" → "이것의 핵심을 한 문장으로 설명해 본다면?"
- **인문학 성찰**: "어떤 감정/생각을 불러일으켰나요?" → "한 폭의 그림이나 장면으로 묘사한다면?"

### **F**urnace Knowledge (단권화 노트)
- 다수의 1줄메모를 하나의 통합된 지식 덩어리로 응축
- 사용자의 개인적 인사이트와 메타인지적 성찰 기록
- 지식 연결망 구조화 및 태그 시스템

### **A**I-Link (온톨로지 기반 지식 캡슐)
- JSON-LD 형식의 구조화된 지식그래프 생성
- 시간 정보, 인지 성능, 학습 맥락 모두 보존
- 외부 링크 크롤링 지시사항 포함으로 완전한 맥락 제공

## 🤔 Habitus33은 어떻게 동작하나요?: 5단계 고객 여정

### **1단계: 당신만의 '지식의 바다'를 만들다**
Habitus33 안에서 당신이 읽는 모든 문장, 기록하는 모든 메모는 당신만의 '지식의 바다'에 파문을 일으킵니다. 이 바다는 당신의 고유한 생각과 맥락이 담긴, 세상에 단 하나뿐인 공간이 됩니다.

### **2단계: 단 한 번의 클릭으로, 바다의 정수를 담아내다**
AI의 도움이 필요한 순간, 당신은 그저 "내 바다의 지도를 만들어줘"라고 요청(원클릭)하기만 하면 됩니다. 이 신호는 **AMFA 엔진**을 깨우는 열쇠입니다. 엔진은 당신의 바다 전체를 탐사하며 모든 생각의 흐름과 지식의 맥락을 정제하고 구조화하여 그 정수만을 응축합니다.

### **3단계: 생각의 본질을 담은 'AI-Link'를 손에 쥐다**
잠시 후, 당신의 손에는 **'AI-Link'**라는 눈부신 지식 캡슐이 쥐어집니다. 이것은 당신이 탐험해 온 '지식의 바다' 전체의 항해 지도이자, 당신 생각의 DNA가 담긴 나침반입니다.

### **4단계: 'AI-Link'를 건네, AI를 당신의 바다로 초대하다**
당신은 이 'AI-Link'를 AI 에이전트에게 건네줍니다. 이것은 AI에게 보내는 '명령'이 아닌, 당신의 바다로의 정중한 '초대장'입니다. AI는 프롬프트 한 마디 없이도 당신의 세계를 유영하기 시작합니다.

### **5단계: '질문'이 아닌, '사유'의 결과물을 얻다**
AI는 당신의 바다 가장 깊은 곳에서, 당신의 의도와 완벽하게 공명하는 보석 같은 통찰을 건져 올릴 것입니다. 당신이 얻는 것은 단순한 '답변'이 아닌, 당신의 오랜 사유와 AI의 분석력이 만나 탄생한 '창조적 결과물'입니다.

---

## 🛠️ 기술 스택

### **프론트엔드**
- **Framework**: Next.js 14 (App Router), TypeScript
- **상태관리**: Redux Toolkit, Zustand
- **스타일링**: TailwindCSS, Framer Motion
- **시각화**: Chart.js, Lottie Animations
- **UI 라이브러리**: Headless UI, React Hook Form

### **백엔드**
- **Runtime**: Node.js, Express.js
- **데이터베이스**: MongoDB Atlas, Mongoose ODM
- **인증**: JWT, bcrypt
- **검증**: express-validator, SHACL
- **온톨로지**: JSON-LD, OWL, SPARQL

### **배포 & 인프라**
- **프론트엔드**: Vercel
- **백엔드**: Render
- **데이터베이스**: MongoDB Atlas
- **CDN**: Vercel Edge Network

---

## ⚡️ 설치 및 실행 (Installation & Usage)

이 프로젝트는 [NPM Workspaces](https://docs.npmjs.com/cli/v7/using-npm/workspaces)를 사용하여 `frontend`와 `backend`를 모노레포(monorepo) 구조로 관리합니다.

### 1. 필수 조건
- Node.js v18 이상
- npm v7 이상
- MongoDB Atlas 계정 및 Connection String

### 2. 의존성 설치
프로젝트 루트 디렉토리에서 아래 명령어를 실행하면, `frontend`와 `backend`의 모든 패키지가 한 번에 설치됩니다.
```bash
npm install
```

### 3. 환경 변수 설정
실행에 필요한 환경 변수 파일을 각각 생성하고 내용을 채워야 합니다.
- **백엔드:** `backend/.env` 파일을 생성하고 아래 내용을 참고하여 채웁니다.
  ```
  PORT=8000
  MONGODB_URI=your_mongodb_connection_string
  JWT_SECRET=your_jwt_secret
  ```
- **프론트엔드:** `frontend/.env.local` 파일을 생성하고, 백엔드 서버 주소를 지정합니다.
  ```
  NEXT_PUBLIC_API_URL=http://localhost:8000
  ```

### 4. 개발 서버 실행
각 워크스페이스(frontend, backend)의 개발 서버를 개별적으로 실행할 수 있습니다.

**프론트엔드 서버 실행 (http://localhost:3000):**
```bash
npm run dev --workspace=frontend
```

**백엔드 서버 실행 (http://localhost:8000):**
```bash
npm run dev --workspace=backend
```

**✅ 모든 서버 동시에 실행하기:**
```bash
npm run dev --workspaces
```

---

## 📂 디렉토리 구조 (Directory Structure)

```
habitus33/
│
├── README.md                # 👈 바로 이 파일!
├── package.json             # ✅ 루트 패키지 매니저 (워크스페이스 설정)
├── package-lock.json        # 의존성 lock 파일
├── .gitignore
├── tsconfig.json            # 공통 TypeScript 설정
│
├── backend/                 # 📦 Express + MongoDB 기반 API 서버 (워크스페이스)
│   ├── package.json         # 백엔드 의존성 및 스크립트
│   ├── src/                 # 핵심 서버 코드 (controllers, models, routes 등)
│   └── ...
│
├── frontend/                # 📦 Next.js 기반 프론트엔드 앱 (워크스페이스)
│   ├── package.json         # 프론트엔드 의존성 및 스크립트
│   ├── app/                 # App Router 기반 페이지/라우트
│   ├── components/          # 재사용 UI 컴포넌트
│   ├── store/               # Redux Toolkit 상태 관리
│   └── ...
│
├── node_modules/            # 🤖 설치된 모든 의존성 (루트/워크스페이스 공통)
└── scripts/                 # 유틸리티 스크립트
```
> 상세한 내부 구조는 각 `backend`와 `frontend` 디렉토리 내부를 참고해주세요.

---

## 🚀 **주요 기능 현황**

### ✅ **완성된 핵심 기능**
- **AI-Link 생성 시스템**: JSON-LD 기반 온톨로지 구조 완성
- **메모진화 4단계**: 읽기 목적별 차별화된 질문 시스템
- **인지 메트릭 측정**: PPM, 집중도, 읽기 패턴 분석
- **시간 정보 보존**: ISO 8601 형식의 정밀한 학습 여정 추적
- **외부 링크 크롤링**: AI 지시사항 포함된 맥락 확장
- **지식 페르소나 분석**: Visualizer, Connector, Theorist, Pragmatist 자동 분류

### 🔄 **진행 중인 기능**
- **젠고 오리지널 오픈마켓**: 노트 거래, 큐레이션, 평점 시스템
- **메모진화 트리 시각화**: 메모 간 연결 및 진화 경로 UI
- **사용자 제작 젠고 게임**: 커스터마이즈/공유 기능 확장
- **실시간 협업 노트**: 다중 사용자 동시 편집

### 🎯 **계획된 기능**
- **AMFA 엔진 최적화**: 개인화된 학습 패턴 예측
- **모바일 앱**: React Native 기반 네이티브 앱
- **음성 메모**: STT 기반 음성 입력 지원

---

## 🤝 **기여하기**

Habitus33은 오픈소스 프로젝트로, 다양한 형태의 기여를 환영합니다.

### 📋 **기여 가능 영역**
- **코드 개발**: 프론트엔드/백엔드 기능 개발
- **온톨로지 설계**: AI-Link 온톨로지 모델 개선
- **UI/UX 디자인**: 사용자 경험 개선
- **문서화**: 기술 문서, 가이드 작성
- **테스트**: 버그 리포트, QA 테스트
- **번역**: 다국어 지원

### 🔧 **개발 환경 설정**
1. Repository Fork 및 Clone
2. `npm install` 실행
3. 환경 변수 설정 (`.env` 파일)
4. `npm run dev --workspaces` 실행

### 📖 **필독 문서**
- [온톨로지 개발 가이드](./ONTOLOGY_GUIDELINES.md)
- [브랜드 가이드라인](./HABITUS33_Brand_Guidelines_v3.4.md)
- [모바일 최적화 가이드](./모바일_텍스트_Overflow_해결_가이드.md)

### 💬 **소통 채널**
- GitHub Issues: 버그 리포트, 기능 제안
- GitHub Discussions: 일반적인 질문, 아이디어 논의

---

## 💎 **AI-Link: 온톨로지 기반 지식 캡슐**

Habitus33의 핵심 기술인 `AI-Link`는 단순한 데이터 묶음이 아닙니다.
사용자의 학습 활동과 지식 구조를 의미론적으로 표현하기 위해 **웹 온톨로지 언어(OWL) 기반의 자체 온톨로지 모델**을 정의하고 사용합니다.

### 🧬 **온톨로지 구조**
```
h33o: 네임스페이스 (Habitus33 Ontology)
├── KnowledgePersonality (지식 페르소나)
├── CognitiveProvenance (인지적 출처)  
├── LearningJourney (학습 여정)
└── EducationalAlignment (교육적 정렬)
```

### 🔗 **AI-Link 생성 과정**
1. **데이터 수집**: 1줄메모, 세션 정보, 메모진화 답변
2. **온톨로지 매핑**: JSON-LD 컨텍스트를 통한 의미 부여
3. **그래프 연결**: @id 기반 엔티티 간 관계 설정
4. **AI 지시사항**: 외부 링크 크롤링 및 분석 가이드 포함

### 📊 **실제 AI-Link 예시**
```json
{
  "@context": [
    "https://schema.org",
    "https://habitus33.vercel.app/ai-link-context.jsonld"
  ],
  "@type": "TechArticle",
  "headline": "미분의 연쇄법칙 학습 노트",
  "hasPart": [
    {
      "@type": "Question",
      "name": "어떤 부분이 중요하다고 느껴졌나요?",
      "educationalAlignment": {
        "readingPurpose": "exam_prep",
        "evolutionStage": 1,
        "cognitiveGoal": "중요성 인식"
      },
      "acceptedAnswer": {
        "text": "미분의 연쇄법칙이 중요하다고 생각함",
        "learningContext": "중요성 인식 단계에서 학습자가 직접 성찰하고 기록한 내용"
      }
    }
  ]
}
```

### 📁 **주요 산출물**

- **[온톨로지 개발 가이드](./ONTOLOGY_GUIDELINES.md)**
  - 설계 원칙, 핵심 클래스/속성, 추론 규칙 정의
- **[AI-Link 컨텍스트](./frontend/public/ai-link-context.jsonld)**
  - JSON-LD 컨텍스트 파일로 데이터를 지식그래프로 변환
- **[온톨로지 스크립트](./scripts/ontology/)**
  - SHACL 검증 및 SPIN/SPARQL 추론 규칙

### 🎯 **AI 활용 시나리오**
사용자가 AI에게 AI-Link URL을 제공하면:
1. **맥락 이해**: 읽기 목적, 학습 패턴, 인지 성능 파악
2. **개인화 분석**: 지식 페르소나 기반 맞춤형 접근
3. **시간적 맥락**: 학습 여정의 시간 흐름 고려
4. **외부 자료 연결**: 관련 링크 크롤링으로 완전한 맥락 구성

---

## 📜 **라이선스**

이 프로젝트는 MIT 라이선스 하에 배포됩니다. 자세한 내용은 [LICENSE](./LICENSE) 파일을 참조하세요.

---

## 🔗 **관련 링크**

- **프로덕션 사이트**: [https://habitus33.vercel.app](https://habitus33.vercel.app)
- **백엔드 API**: [https://habitus33-backend.onrender.com](https://habitus33-backend.onrender.com)
- **브랜드 가이드**: [Habitus33 Brand Guidelines](./HABITUS33_Brand_Guidelines_v3.4.md)
- **마케팅 전략**: [Marketing Strategy Guide](./Habitus33_Marketing_Strategy_Guide.md)

---

<div align="center">

**Habitus33** - *Prompt Free, Habitus33*

당신의 생각이 가장 완벽한 프롬프트입니다 🌊

</div>