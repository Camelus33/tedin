import _extends from '@babel/runtime/helpers/esm/extends';
import * as React from 'react';
import { useRef, useMemo, useLayoutEffect } from 'react';
import { extend, useThree } from '@react-three/fiber';
import { MeshBVH, SAH } from 'three-mesh-bvh';
import { MeshRefractionMaterial as MeshRefractionMaterial$1 } from '../materials/MeshRefractionMaterial.js';

function MeshRefractionMaterial({
  frames = 1,
  resolution = 256,
  near = 0.1,
  far = 1000,
  aberrationStrength = 0,
  ...props
}) {
  extend({
    MeshRefractionMaterial_: MeshRefractionMaterial$1
  });
  const material = useRef();
  const {
    size
  } = useThree();
  const defines = useMemo(() => {
    const temp = {};
    if (aberrationStrength > 0) temp.CHROMATIC_ABERRATIONS = '';
    return temp;
  }, [aberrationStrength]);
  useLayoutEffect(() => {
    var _material$current, _material$current$__r, _material$current$__r2;

    const geometry = (_material$current = material.current) == null ? void 0 : (_material$current$__r = _material$current.__r3f) == null ? void 0 : (_material$current$__r2 = _material$current$__r.parent) == null ? void 0 : _material$current$__r2.geometry;
    if (geometry) material.current.bvh.updateFrom(new MeshBVH(geometry.toNonIndexed(), {
      lazyGeneration: false,
      strategy: SAH
    }));
  }, []);
  return /*#__PURE__*/React.createElement("meshRefractionMaterial", _extends({
    // @ts-ignore
    key: JSON.stringify(!!aberrationStrength) // @ts-ignore
    ,
    defines: defines,
    ref: material,
    resolution: [size.width, size.height],
    aberrationStrength: aberrationStrength
  }, props));
}

export { MeshRefractionMaterial };
