"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var r=require("three"),e=require("../core/shaderMaterial.cjs.js"),n=require("three-mesh-bvh");function i(r){if(r&&r.__esModule)return r;var e=Object.create(null);return r&&Object.keys(r).forEach((function(n){if("default"!==n){var i=Object.getOwnPropertyDescriptor(r,n);Object.defineProperty(e,n,i.get?i:{enumerable:!0,get:function(){return r[n]}})}})),e.default=r,Object.freeze(e)}var o=i(r);const t=e.shaderMaterial({envMap:null,bounces:3,ior:2.4,correctMips:!0,aberrationStrength:.01,fresnel:0,bvh:new n.MeshBVHUniformStruct,color:new o.Color("white"),resolution:new o.Vector2},"\n  varying vec3 vWorldPosition;  \n  varying vec3 vNormal;\n  varying mat4 projectionMatrixInv;\n  varying mat4 viewMatrixInv;\n  varying vec3 viewDirection;\n\n  void main() {\n    projectionMatrixInv = inverse(projectionMatrix);\n    viewMatrixInv = inverse(viewMatrix);\n    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;    \n    vNormal = (viewMatrixInv * vec4(normalMatrix * normal, 0.0)).xyz;\n    viewDirection = normalize(vWorldPosition - cameraPosition);\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n  }",`\n  precision highp isampler2D;\n  precision highp usampler2D;\n  varying vec3 vWorldPosition;\n  varying vec3 vNormal;\n  uniform samplerCube envMap;\n  uniform float bounces;\n  ${n.shaderStructs}\n  ${n.shaderIntersectFunction}\n  uniform BVH bvh;\n  uniform float ior;\n  uniform vec3 color;\n  uniform bool correctMips;\n  uniform vec2 resolution;\n  uniform float fresnel;\n  uniform mat4 modelMatrix;\n\n  uniform float aberrationStrength;\n  varying mat4 projectionMatrixInv;\n  varying mat4 viewMatrixInv;\n  varying vec3 viewDirection;  \n  \n  float fresnelFunc(vec3 viewDirection, vec3 worldNormal) {\n    return pow( 1.0 + dot( viewDirection, worldNormal), 10.0 );\n  }\n\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 normal, float ior, mat4 modelMatrixInverse) {\n    vec3 rayOrigin = ro;\n    vec3 rayDirection = rd;\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\n    rayOrigin = vWorldPosition + rayDirection * 0.001;\n    rayOrigin = (modelMatrixInverse * vec4(rayOrigin, 1.0)).xyz;\n    rayDirection = normalize((modelMatrixInverse * vec4(rayDirection, 0.0)).xyz);\n    for(float i = 0.0; i < bounces; i++) {\n      uvec4 faceIndices = uvec4( 0u );\n      vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n      vec3 barycoord = vec3( 0.0 );\n      float side = 1.0;\n      float dist = 0.0;\n      bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n      vec3 hitPos = rayOrigin + rayDirection * max(dist - 0.001, 0.0);\n      // faceNormal *= side;\n      vec3 tempDir = refract(rayDirection, faceNormal, ior);\n      if (length(tempDir) != 0.0) {\n        rayDirection = tempDir;\n        break;\n      }\n      rayDirection = reflect(rayDirection, faceNormal);\n      rayOrigin = hitPos + rayDirection * 0.01;\n    }\n    rayDirection = normalize((modelMatrix * vec4(rayDirection, 0.0)).xyz);\n    return rayDirection;\n  }\n\n  void main() {\n    mat4 modelMatrixInverse = inverse(modelMatrix);\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec3 directionCamPerfect = (projectionMatrixInv * vec4(uv * 2.0 - 1.0, 0.0, 1.0)).xyz;\n    directionCamPerfect = (viewMatrixInv * vec4(directionCamPerfect, 0.0)).xyz;\n    directionCamPerfect = normalize(directionCamPerfect);\n    vec3 normal = vNormal;\n    vec3 rayOrigin = cameraPosition;\n    vec3 rayDirection = normalize(vWorldPosition - cameraPosition);\n    vec3 finalColor;\n    #ifdef CHROMATIC_ABERRATIONS\n      vec3 rayDirectionR = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 - aberrationStrength), 1.0), modelMatrixInverse);\n      vec3 rayDirectionG = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), modelMatrixInverse);\n      vec3 rayDirectionB = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 + aberrationStrength), 1.0), modelMatrixInverse);\n      float finalColorR = textureGrad(envMap, rayDirectionR, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection)).r;\n      float finalColorG = textureGrad(envMap, rayDirectionG, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection)).g;\n      float finalColorB = textureGrad(envMap, rayDirectionB, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection)).b;\n      finalColor = vec3(finalColorR, finalColorG, finalColorB) * color;\n    #else\n      rayDirection = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), modelMatrixInverse);\n      finalColor = textureGrad(envMap, rayDirection, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection)).rgb;\n      finalColor *= color;\n    #endif\n    float nFresnel = fresnelFunc(viewDirection, normal * (1.0 - fresnel));\n    gl_FragColor = vec4(mix(finalColor, vec3(1.0), nFresnel), 1.0);\n    \n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n  }`);exports.MeshRefractionMaterial=t;
